
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>500 Lines or Less | Static Analysis &#8212; Learn-Computer-and-Math-again 0.0.1 文档</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lines-or-less-static-analysis">
<h1>500 Lines or Less | Static Analysis<a class="headerlink" href="#lines-or-less-static-analysis" title="永久链接至标题">¶</a></h1>
<div class="container"><div class="row"><div class="hero-unit"><p><a href="#id1"><span class="problematic" id="id2">``</span></a>_
.. rubric:: Static Analysis</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">static-analysis</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p class="author rubric" id="leah-hanson">Leah Hanson</p>
</div></div><div class="row"><div id="content" class="span10 offset1"><p><em>Leah Hanson is a proud alumni of Hacker School and loves helping people
learn about Julia. She blogs at http://blog.leahhanson.us/ and tweets at
`&#64;astrieanna`_.</em></p>
<p class="rubric" id="introduction">Introduction</p>
<p>You may be familiar with a fancy IDE that draws red underlines under
parts of your code that don't compile. You may have run a linter on your
code to check for formatting or style problems. You might run your
compiler in super-picky mode with all the warnings turned on. All of
these tools are applications of static analysis.</p>
<p>Static analysis is a way to check for problems in your code without
running it. &quot;Static&quot; means at compile time rather than at run time, and
&quot;analysis&quot; means we're analyzing the code. When you've used the tools I
mentioned above, it may have felt like magic. But those tools are just
programs—they are made of source code that was written by a person, a
programmer like you. In this chapter, we're going to talk about how to
implement a couple of static analysis checks. In order to do this, we
need to know what we want the check to do and how we want to do it.</p>
<p>We can get more specific about what you need to know by describing the
process as three stages:</p>
<p class="rubric" id="deciding-what-you-want-to-check-for">1. Deciding what you want to check for.</p>
<p>You should be able to explain the general problem you'd like to solve,
in terms that a user of the programming language would recognize.
Examples include:</p>
<ul class="simple">
<li>Finding misspelled variable names</li>
<li>Finding race conditions in parallel code</li>
<li>Finding calls to unimplemented functions</li>
</ul>
<p class="rubric" id="deciding-how-exactly-to-check-for-it">2. Deciding how exactly to check for it.</p>
<p>While we could ask a friend to do one of the tasks listed above, they
aren't specific enough to explain to a computer. To tackle &quot;misspelled
variable names&quot;, for example, we'd need to decide what misspelled means
here. One option would be to claim variable names should be composed of
English words from the dictionary; another option is to look for
variables that are only used once (the one time you mistyped it).</p>
<p>If we know we're looking for variables that are only used once, we can
talk about kinds of variable usages (having their value assigned versus
read) and what code would or would not trigger a warning.</p>
<p class="rubric" id="implementation-details">3. Implementation details.</p>
<p>This covers the actual act of writing the code, the time spent reading
the documentation for libraries you use, and figuring out how to get at
the information you need to write the analysis. This could involve
reading in a file of code, parsing it to understand the structure, and
then making your specific check on that structure.</p>
<p>We're going to work through these steps for each of the individual
checks implemented in this chapter. Step 1 requires enough understanding
of the language we're analyzing to empathize with the problems its users
face. All the code in this chapter is Julia code, written to analyze
Julia code.</p>
<p class="rubric" id="a-very-brief-introduction-to-julia">A Very Brief Introduction to Julia</p>
<p>Julia is a young language aimed at technical computing. It was released
at version 0.1 in the spring of 2012; as of the start of 2015, it has
reached version 0.3. In general, Julia looks a lot like Python, but with
some optional type annotations and without any object-oriented stuff.
The feature that most programmers will find novel in Julia is multiple
dispatch, which has a pervasive impact on both API design and on other
design choices in the language.</p>
<p>Here is a snippet of Julia code:</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="c1"># A comment about increment</span>
<span class="n">function</span> <span class="n">increment</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Int64</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">end</span>

<span class="n">increment</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>This code defines a method of the function <code class="docutils literal"><span class="pre">increment</span></code> that takes one
argument, named <code class="docutils literal"><span class="pre">x</span></code>, of type <code class="docutils literal"><span class="pre">Int64</span></code>. The method returns the value
of <code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code>. Then, this freshly defined method is called with the value
<code class="docutils literal"><span class="pre">5</span></code>; the function call, as you may have guessed, will evaluate to
<code class="docutils literal"><span class="pre">6</span></code>.</p>
<p><code class="docutils literal"><span class="pre">Int64</span></code> is a type whose values are signed integers represented in
memory by 64 bits; they are the integers that your hardware understands
if your computer has a 64-bit processor. Types in Julia define the
representation of data in memory, in addition to influencing method
dispatch.</p>
<p>The name <code class="docutils literal"><span class="pre">increment</span></code> refers to a generic function, which may have many
methods. We have just defined one method of it. In many languages, the
terms &quot;function&quot; and &quot;method&quot; are used interchangeably; in Julia, they
have distinct meanings. This chapter will make more sense if you are
careful to understand &quot;function&quot; as a named collection of methods, where
a &quot;method&quot; is a specific implementation for a specific type signature.</p>
<p>Let's define another method of the <code class="docutils literal"><span class="pre">increment</span></code> function:</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Increment x by y</span>
<span class="n">function</span> <span class="n">increment</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Int64</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">Number</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">end</span>

<span class="n">increment</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># =&gt; 6</span>
<span class="n">increment</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># =&gt; 9</span>
</pre></div>
</div>
<p>Now the function <code class="docutils literal"><span class="pre">increment</span></code> has two methods. Julia decides which
method to run for a given call based on the number and types of the
arguments; this is called <em>dynamic multiple dispatch</em>:</p>
<ul class="simple">
<li><strong>Dynamic</strong> because it's based on the types of the values used at
runtime.</li>
<li><strong>Multiple</strong> because it looks at the types and order of all the
arguments.</li>
<li><strong>Dispatch</strong> because this is a way of matching function calls to
method definitions.</li>
</ul>
<p>To put this in the context of languages you may already know,
object-oriented languages use single dispatch because they only consider
the first argument. (In <code class="docutils literal"><span class="pre">x.foo(y)</span></code>, the first argument is <code class="docutils literal"><span class="pre">x</span></code>.)</p>
<p>Both single and multiple dispatch are based on the types of the
arguments. The <code class="docutils literal"><span class="pre">x::Int64</span></code> above is a type annotation purely for
dispatch. In Julia's dynamic type system, you could assign a value of
any type to <code class="docutils literal"><span class="pre">x</span></code> during the function without an error.</p>
<p>We haven't really seen the &quot;multiple&quot; part yet, but if you're curious
about Julia, you'll have to look that up on your own. We need to move on
to our first check.</p>
<p class="rubric" id="checking-the-types-of-variables-in-loops">Checking the Types of Variables in Loops</p>
<p>As in most programming languages, writing very fast code in Julia
involves an understanding of how the computer works and how Julia works.
An important part of helping the compiler create fast code for you is
writing type-stable code; this is important in Julia and JavaScript, and
is also helpful in other JIT’d languages. When the compiler can see that
a variable in a section of code will always contain the same specific
type, the compiler can do more optimizations than if it believes
(correctly or not) that there are multiple possible types for that
variable. You can read more about why type stability (also called
“monomorphism”) is important for JavaScript <a class="reference external" href="http://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">online</a>.</p>
<p class="rubric" id="why-this-is-important">Why This Is Important</p>
<p>Let's write a function that takes an <code class="docutils literal"><span class="pre">Int64</span></code> and increases it by some
amount. If the number is small (less than 10), let's increase it by a
big number (50), but if it's big, let's only increase it by 0.5.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">increment</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Int64</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">50</span>
  <span class="k">else</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span>
  <span class="n">end</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="n">end</span>
</pre></div>
</div>
<p>This function looks pretty straightforward, but the type of <code class="docutils literal"><span class="pre">x</span></code> is
unstable. I selected two numbers: 50, an <code class="docutils literal"><span class="pre">Int64</span></code>, and 0.5, a
<code class="docutils literal"><span class="pre">Float64</span></code>. Depending on the value of <code class="docutils literal"><span class="pre">x</span></code>, it might be added to
either one of them. If you add an <code class="docutils literal"><span class="pre">Int64</span></code> like 22, to a <code class="docutils literal"><span class="pre">Float64</span></code>
like 0.5, you'll get a <code class="docutils literal"><span class="pre">Float64</span></code> (22.5). Because the type of variable
in the function (<code class="docutils literal"><span class="pre">x</span></code>) could change depending on the value of the
arguments to the function (<code class="docutils literal"><span class="pre">x</span></code>), this method of <code class="docutils literal"><span class="pre">increment</span></code> and
specifically the variable <code class="docutils literal"><span class="pre">x</span></code> are type-unstable.</p>
<p><code class="docutils literal"><span class="pre">Float64</span></code> is a type that represents floating-point values stored in 64
bits; in C, it is called a <code class="docutils literal"><span class="pre">double</span></code>. This is one of the floating-point
types that 64-bit processors understand.</p>
<p>As with most efficiency problems, this issue is more pronounced when it
happens during loops. Code inside for loops and while loops is run many,
many times, so making it fast is more important than speeding up code
that is only run once or twice. Therefore, our first check is to look
for variables that have unstable types inside loops.</p>
<p>First, let's look at an example of what we want to catch. We'll be
looking at two functions. Each of them sums the numbers 1 to 100, but
instead of summing the whole numbers, they divide each one by 2 before
summing it. Both functions will get the same answer (2525.0); both will
return the same type (<code class="docutils literal"><span class="pre">Float64</span></code>). However, the first function,
<code class="docutils literal"><span class="pre">unstable</span></code>, suffers from type-instability, while the second one,
<code class="docutils literal"><span class="pre">stable</span></code>, does not.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">unstable</span><span class="p">()</span>
  <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">100</span>
    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span>
  <span class="n">end</span>
  <span class="k">return</span> <span class="nb">sum</span>
<span class="n">end</span>
</pre></div>
</div>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">stable</span><span class="p">()</span>
  <span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">100</span>
    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span>
  <span class="n">end</span>
  <span class="k">return</span> <span class="nb">sum</span>
<span class="n">end</span>
</pre></div>
</div>
<p>The only textual difference between the two functions is in the
initialization of <code class="docutils literal"><span class="pre">sum</span></code>: <code class="docutils literal"><span class="pre">sum</span> <span class="pre">=</span> <span class="pre">0</span></code> versus <code class="docutils literal"><span class="pre">sum</span> <span class="pre">=</span> <span class="pre">0.0</span></code>. In Julia,
<code class="docutils literal"><span class="pre">0</span></code> is an <code class="docutils literal"><span class="pre">Int64</span></code> literal and <code class="docutils literal"><span class="pre">0.0</span></code> is a <code class="docutils literal"><span class="pre">Float64</span></code> literal. How
big of a difference could this tiny change make?</p>
<p>Because Julia is Just-In-Time (JIT) compiled, the first run of a
function will take longer than subsequent runs. (The first run includes
the time it takes to compile the function for these argument types.)
When we benchmark functions, we have to be sure to run them once (or
precompile them) before timing them.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">unstable</span><span class="p">()</span>
<span class="mf">2525.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">stable</span><span class="p">()</span>
<span class="mf">2525.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@time</span> <span class="n">unstable</span><span class="p">()</span>
<span class="n">elapsed</span> <span class="n">time</span><span class="p">:</span> <span class="mf">9.517e-6</span> <span class="n">seconds</span> <span class="p">(</span><span class="mi">3248</span> <span class="nb">bytes</span> <span class="n">allocated</span><span class="p">)</span>
<span class="mf">2525.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@time</span> <span class="n">stable</span><span class="p">()</span>
<span class="n">elapsed</span> <span class="n">time</span><span class="p">:</span> <span class="mf">2.285e-6</span> <span class="n">seconds</span> <span class="p">(</span><span class="mi">64</span> <span class="nb">bytes</span> <span class="n">allocated</span><span class="p">)</span>
<span class="mf">2525.0</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">&#64;time</span></code> macro prints out how long the function took to run and how
many bytes were allocated while it was running. The number of bytes
allocated increases every time new memory is needed; it does not
decrease when the garbage collector vacuums up memory that's no longer
being used. This means that the bytes allocated is related to the amount
of time we spend allocating and managing memory, but does not imply that
we had all of that memory in use at the same time.</p>
<p>If we wanted to get solid numbers for <code class="docutils literal"><span class="pre">stable</span></code> versus <code class="docutils literal"><span class="pre">unstable</span></code> we
would need to make the loop much longer or run the functions many times.
However, it looks like <code class="docutils literal"><span class="pre">unstable</span></code> is probably slower. More
interestingly, we can see a large gap in the number of bytes allocated;
<code class="docutils literal"><span class="pre">unstable</span></code> has allocated around 3 KB of memory, where <code class="docutils literal"><span class="pre">stable</span></code> is
using 64 bytes.</p>
<p>Since we can see how simple <code class="docutils literal"><span class="pre">unstable</span></code> is, we might guess that this
allocation is happening in the loop. To test this, we can make the loop
longer and see if the allocations increase accordingly. Let's make the
loop go from 1 to 10000, which is 100 times more iterations; we'll look
for the number of bytes allocated to also increase about 100 times, to
around 300 KB.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">unstable</span><span class="p">()</span>
  <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10000</span>
    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span>
  <span class="n">end</span>
  <span class="k">return</span> <span class="nb">sum</span>
<span class="n">end</span>
</pre></div>
</div>
<p>Since we redefined the function, we'll need to run it so it gets
compiled before we measure it. We expect to get a different, larger
answer from the new function definition, since it's summing more numbers
now.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">unstable</span><span class="p">()</span>
<span class="mf">2.50025e7</span>

<span class="n">julia</span><span class="o">&gt;</span><span class="nd">@time</span> <span class="n">unstable</span><span class="p">()</span>
<span class="n">elapsed</span> <span class="n">time</span><span class="p">:</span> <span class="mf">0.000667613</span> <span class="n">seconds</span> <span class="p">(</span><span class="mi">320048</span> <span class="nb">bytes</span> <span class="n">allocated</span><span class="p">)</span>
<span class="mf">2.50025e7</span>
</pre></div>
</div>
<p>The new <code class="docutils literal"><span class="pre">unstable</span></code> allocated about 320 KB, which is what we would
expect if the allocations are happening in the loop. To explain what's
going on here, we're going to look at how Julia works under the hood.</p>
<p>This difference between <code class="docutils literal"><span class="pre">unstable</span></code> and <code class="docutils literal"><span class="pre">stable</span></code> occurs because
<code class="docutils literal"><span class="pre">sum</span></code> in <code class="docutils literal"><span class="pre">unstable</span></code> must be boxed while <code class="docutils literal"><span class="pre">sum</span></code> in <code class="docutils literal"><span class="pre">stable</span></code> can be
unboxed. Boxed values consist of a type tag and the actual bits that
represent the value; unboxed values only have their actual bits. But the
type tag is small, so that's not why boxing values allocates a lot more
memory.</p>
<p>The difference comes from what optimizations the compiler can make. When
a variable has a concrete, immutable type, the compiler can unbox it
inside the function. If that's not the case, then the variable must be
allocated on the heap, and participate in the garbage collector.
Immutable types are a concept specific to Julia. A value of an immutable
type can't be changed.</p>
<p>Immutable types are usually types that represent values, rather than
collections of values. For example, most numeric types, including
<code class="docutils literal"><span class="pre">Int64</span></code> and <code class="docutils literal"><span class="pre">Float64</span></code>, are immutable. (Numeric types in Julia are
normal types, not special primitive types; you could define a new
<code class="docutils literal"><span class="pre">MyInt64</span></code> that's the same as the provided one.) Because immutable
types cannot be modified, you must make a new copy every time you want
change one. For example <code class="docutils literal"><span class="pre">4</span> <span class="pre">+</span> <span class="pre">6</span></code> must make a new <code class="docutils literal"><span class="pre">Int64</span></code> to hold the
result. In contrast, the members of a mutable type can be updated
in-place; this means you don't have to make a copy of the whole thing to
make a change.</p>
<p>The idea of <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">2</span></code> allocating memory probably sounds pretty
weird; why would you make such a basic operation slow by making
<code class="docutils literal"><span class="pre">Int64</span></code> values immutable? This is where those compiler optimizations
come in: using immutable types doesn't (usually) slow this down. If
<code class="docutils literal"><span class="pre">x</span></code> has a stable, concrete type (such as <code class="docutils literal"><span class="pre">Int64</span></code>), then the compiler
is free to allocate <code class="docutils literal"><span class="pre">x</span></code> on the stack and mutate <code class="docutils literal"><span class="pre">x</span></code> in place. The
problem is only when <code class="docutils literal"><span class="pre">x</span></code> has an unstable type (so the compiler doesn't
know how big or what type it will be); once <code class="docutils literal"><span class="pre">x</span></code> is boxed and on the
heap, the compiler isn't completely sure that some other piece of code
isn't using the value, and thus can't edit it.</p>
<p>Because <code class="docutils literal"><span class="pre">sum</span></code> in <code class="docutils literal"><span class="pre">stable</span></code> has a concrete type (<code class="docutils literal"><span class="pre">Float64</span></code>), the
compiler knows that it can store it unboxed locally in the function and
mutate its value; <code class="docutils literal"><span class="pre">sum</span></code> will not be allocated on the heap and new
copies don't have to be made every time we add <code class="docutils literal"><span class="pre">i/2</span></code>.</p>
<p>Because <code class="docutils literal"><span class="pre">sum</span></code> in <code class="docutils literal"><span class="pre">unstable</span></code> does not have a concrete type, the
compiler allocates it on the heap. Every time we modify sum, we
allocated a new value on the heap. All this time spent allocating values
on the heap (and retrieving them every time we want to read the value of
<code class="docutils literal"><span class="pre">sum</span></code>) is expensive.</p>
<p>Using <code class="docutils literal"><span class="pre">0</span></code> versus <code class="docutils literal"><span class="pre">0.0</span></code> is an easy mistake to make, especially when
you're new to Julia. Automatically checking that variables used in loops
are type-stable helps programmers get more insight into what the types
of their variables are in performance-critical sections of their code.</p>
<p class="rubric" id="id3">Implementation Details</p>
<p>We'll need to find out which variables are used inside loops and we'll
need to find the types of those variables. We'll then need to decide how
to print them in a human-readable format.</p>
<ul class="simple">
<li>How do we find loops?</li>
<li>How do we find variables in loops?</li>
<li>How do we find the types of a variable?</li>
<li>How do we print the results?</li>
<li>How do we tell if the type is unstable?</li>
</ul>
<p>I'm going to tackle the last question first, since this whole endeavour
hinges on it. We've looked at an unstable function and seen, as
programmers, how to identify an unstable variable, but we need our
program to find them. This sounds like it would require simulating the
function to look for variables whose values might change—which sounds
like it would take some work. Luckily for us, Julia's type inference
already traces through the function's execution to determine the types.</p>
<p>The type of <code class="docutils literal"><span class="pre">sum</span></code> in <code class="docutils literal"><span class="pre">unstable</span></code> is <code class="docutils literal"><span class="pre">Union(Float64,Int64)</span></code>. This is
a <code class="docutils literal"><span class="pre">UnionType</span></code>, a special kind of type that indicates that the variable
may hold any of a set of types of values. A variable of type
<code class="docutils literal"><span class="pre">Union(Float64,Int64)</span></code> can hold values of type <code class="docutils literal"><span class="pre">Int64</span></code> or
<code class="docutils literal"><span class="pre">Float64</span></code>; a value can only have one of those types. A <code class="docutils literal"><span class="pre">UnionType</span></code>
joins any number of types (e.g., <code class="docutils literal"><span class="pre">UnionType(Float64,</span> <span class="pre">Int64,</span> <span class="pre">Int32)</span></code>
joins three types). We're going to look for is <code class="docutils literal"><span class="pre">UnionType</span></code>d
variables inside loops.</p>
<p>Parsing code into a representative structure is a complicated business,
and gets more complicated as the language grows. In this chapter, we'll
be depending on internal data structures used by the compiler. This
means that we don't have to worry about reading files or parsing them,
but it does mean we have to work with data structures that are not in
our control and that sometimes feel clumsy or ugly.</p>
<p>Besides all the work we'll save by not having to parse the code by
ourselves, working with the same data structures that the compiler uses
means that our checks will be based on an accurate assessment of the
compilers understanding—which means our check will be consistent with
how the code actually runs.</p>
<p>This process of examining Julia code from Julia code is called
introspection. When you or I introspect, we're thinking about how and
why we think and feel. When code introspects, it examines the
representation or execution properties of code in the same language
(possibly its own code). When code's introspection extends to modifying
the examined code, it's called metaprogramming (programs that write or
modify programs).</p>
<p class="rubric" id="introspection-in-julia">Introspection in Julia</p>
<p>Julia makes it easy to introspect. There are four functions built in to
let us see what the compiler is thinking: <code class="docutils literal"><span class="pre">code_lowered</span></code>,
<code class="docutils literal"><span class="pre">code_typed</span></code>, <code class="docutils literal"><span class="pre">code_llvm</span></code>, and <code class="docutils literal"><span class="pre">code_native</span></code>. Those are listed in
order of what step in the compilation process their output is from; the
first one is closest to the code we'd type in and the last one is the
closest to what the CPU runs. For this chapter, we'll focus on
<code class="docutils literal"><span class="pre">code_typed</span></code>, which gives us the optimized, type-inferred abstract
syntax tree (AST).</p>
<p><code class="docutils literal"><span class="pre">code_typed</span></code> takes two arguments: the function of interest, and a
tuple of argument types. For example, if we wanted to see the AST for a
function <code class="docutils literal"><span class="pre">foo</span></code> when called with two <code class="docutils literal"><span class="pre">Int64</span></code>s, then we would call
<code class="docutils literal"><span class="pre">code_typed(foo,</span> <span class="pre">(Int64,Int64))</span></code>.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
  <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
  <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">z</span>
<span class="n">end</span>

<span class="n">code_typed</span><span class="p">(</span><span class="n">foo</span><span class="p">,(</span><span class="n">Int64</span><span class="p">,</span><span class="n">Int64</span><span class="p">))</span>
</pre></div>
</div>
<p>This is the structure that <code class="docutils literal"><span class="pre">code_typed</span></code> would return:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>1-element Array{Any,1}:
:($(Expr(:lambda, {:x,:y}, {{:z},{{:x,Int64,0},{:y,Int64,0},{:z,Int64,18}},{}},
 :(begin  # none, line 2:
        z = (top(box))(Int64,(top(add_int))(x::Int64,y::Int64))::Int64 # line 3:
        return (top(box))(Int64,(top(mul_int))(2,z::Int64))::Int64
    end::Int64))))
</pre></div>
</div>
<p>This is an <code class="docutils literal"><span class="pre">Array</span></code>; this allows <code class="docutils literal"><span class="pre">code_typed</span></code> to return multiple
matching methods. Some combinations of functions and argument types may
not completely determine which method should be called. For example, you
could pass in a type like <code class="docutils literal"><span class="pre">Any</span></code> (instead of <code class="docutils literal"><span class="pre">Int64</span></code>). <code class="docutils literal"><span class="pre">Any</span></code> is the
type at the top of the type hierarchy; all types are subtypes of <code class="docutils literal"><span class="pre">Any</span></code>
(including <code class="docutils literal"><span class="pre">Any</span></code>). If we included <code class="docutils literal"><span class="pre">Any</span></code> in our tuple of argument
types, and had multiple matching methods, then the <code class="docutils literal"><span class="pre">Array</span></code> from
<code class="docutils literal"><span class="pre">code_typed</span></code> would have more than one element in it; it would have one
element per matching method.</p>
<p>Let's pull our example <code class="docutils literal"><span class="pre">Expr</span></code> out to make it easier to talk about.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>julia&gt; e = code_typed(foo,(Int64,Int64))[1]
:($(Expr(:lambda, {:x,:y}, {{:z},{{:x,Int64,0},{:y,Int64,0},{:z,Int64,18}},{}},
 :(begin  # none, line 2:
        z = (top(box))(Int64,(top(add_int))(x::Int64,y::Int64))::Int64 # line 3:
        return (top(box))(Int64,(top(mul_int))(2,z::Int64))::Int64
    end::Int64))))
</pre></div>
</div>
<p>The structure we're interested in is inside the <code class="docutils literal"><span class="pre">Array</span></code>: it is an
<code class="docutils literal"><span class="pre">Expr</span></code>. Julia uses <code class="docutils literal"><span class="pre">Expr</span></code> (short for expression) to represent its
AST. (An abstract syntax tree is how the compiler thinks about the
meaning of your code; it's kind of like when you had to diagram
sentences in grade school.) The <code class="docutils literal"><span class="pre">Expr</span></code> we get back represents one
method. It has some metadata (about the variables that appear in the
method) and the expressions that make up the body of the method.</p>
<p>Now we can ask some questions about <code class="docutils literal"><span class="pre">e</span></code>.</p>
<p>We can ask what properties an <code class="docutils literal"><span class="pre">Expr</span></code> has by using the <code class="docutils literal"><span class="pre">names</span></code>
function, which works on any Julia value or type. It returns an
<code class="docutils literal"><span class="pre">Array</span></code> of names defined by that type (or the type of the value).</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="n">Symbol</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="p">:</span><span class="n">head</span>
 <span class="p">:</span><span class="n">args</span>
 <span class="p">:</span><span class="n">typ</span>
</pre></div>
</div>
<p>We just asked <code class="docutils literal"><span class="pre">e</span></code> what names it has, and now we can ask what value
each name corresponds to. An <code class="docutils literal"><span class="pre">Expr</span></code> has three properties: <code class="docutils literal"><span class="pre">head</span></code>,
<code class="docutils literal"><span class="pre">typ</span></code> and <code class="docutils literal"><span class="pre">args</span></code>.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">head</span>
<span class="p">:</span><span class="k">lambda</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">typ</span>
<span class="n">Any</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="n">Any</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="p">{:</span><span class="n">x</span><span class="p">,:</span><span class="n">y</span><span class="p">}</span>
 <span class="p">{{:</span><span class="n">z</span><span class="p">},{{:</span><span class="n">x</span><span class="p">,</span><span class="n">Int64</span><span class="p">,</span><span class="mi">0</span><span class="p">},{:</span><span class="n">y</span><span class="p">,</span><span class="n">Int64</span><span class="p">,</span><span class="mi">0</span><span class="p">},{:</span><span class="n">z</span><span class="p">,</span><span class="n">Int64</span><span class="p">,</span><span class="mi">18</span><span class="p">}},{}}</span>
 <span class="p">:(</span><span class="n">begin</span>  <span class="c1"># none, line 2:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Int64</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">add_int</span><span class="p">))(</span><span class="n">x</span><span class="p">::</span><span class="n">Int64</span><span class="p">,</span><span class="n">y</span><span class="p">::</span><span class="n">Int64</span><span class="p">))::</span><span class="n">Int64</span> <span class="c1"># line 3:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Int64</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">mul_int</span><span class="p">))(</span><span class="mi">2</span><span class="p">,</span><span class="n">z</span><span class="p">::</span><span class="n">Int64</span><span class="p">))::</span><span class="n">Int64</span>
    <span class="n">end</span><span class="p">::</span><span class="n">Int64</span><span class="p">)</span>
</pre></div>
</div>
<p>We just saw some values printed out, but that doesn't tell us much about
what they mean or how they're used.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">head</span></code> tells us what kind of expression this is; normally, you'd
use separate types for this in Julia, but <code class="docutils literal"><span class="pre">Expr</span></code> is a type that
models the structure used in the parser. The parser is written in a
dialect of Scheme, which structures everything as nested lists.
<code class="docutils literal"><span class="pre">head</span></code> tells us how the rest of the <code class="docutils literal"><span class="pre">Expr</span></code> is organized and what
kind of expression it represents.</li>
<li><code class="docutils literal"><span class="pre">typ</span></code> is the inferred return type of the expression; when you
evaluate any expression, it results in some value. <code class="docutils literal"><span class="pre">typ</span></code> is the
type of the value that the expression will evaluate to. For nearly
all <code class="docutils literal"><span class="pre">Expr</span></code>s, this value will be <code class="docutils literal"><span class="pre">Any</span></code> (which is always correct,
since every possible type is a subtype of <code class="docutils literal"><span class="pre">Any</span></code>). Only the <code class="docutils literal"><span class="pre">body</span></code>
of type-inferred methods and most expressions inside them will have
their <code class="docutils literal"><span class="pre">typ</span></code> set to something more specific. (Because <code class="docutils literal"><span class="pre">type</span></code> is a
keyword, this field can't use that word as its name.)</li>
<li><code class="docutils literal"><span class="pre">args</span></code> is the most complicated part of <code class="docutils literal"><span class="pre">Expr</span></code>; its structure
varies based on the value of <code class="docutils literal"><span class="pre">head</span></code>. It's always an <code class="docutils literal"><span class="pre">Array{Any}</span></code>
(an untyped array), but beyond that the structure changes.</li>
</ul>
<p>In an <code class="docutils literal"><span class="pre">Expr</span></code> representing a method, there will be three elements in
<code class="docutils literal"><span class="pre">e.args</span></code>:</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># names of arguments as symbols</span>
<span class="mi">2</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="n">Any</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="p">:</span><span class="n">x</span>
 <span class="p">:</span><span class="n">y</span>
</pre></div>
</div>
<p>Symbols are a special type for representing the names of variables,
constants, functions, and modules. They are a different type from
strings because they specifically represent the name of a program
construct.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># three lists of variable metadata</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="n">Any</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="p">{:</span><span class="n">z</span><span class="p">}</span>
 <span class="p">{{:</span><span class="n">x</span><span class="p">,</span><span class="n">Int64</span><span class="p">,</span><span class="mi">0</span><span class="p">},{:</span><span class="n">y</span><span class="p">,</span><span class="n">Int64</span><span class="p">,</span><span class="mi">0</span><span class="p">},{:</span><span class="n">z</span><span class="p">,</span><span class="n">Int64</span><span class="p">,</span><span class="mi">18</span><span class="p">}}</span>
 <span class="p">{}</span>
</pre></div>
</div>
<p>The first list above contains the names of all local variables; we only
have one (<code class="docutils literal"><span class="pre">z</span></code>) here. The second list contains a tuple for each
variable in and argument to the method; each tuple has the variable
name, the variable's inferred type, and a number. The number conveys
information about how the variable is used, in a machine- (rather than
human-) friendly way. The last list is of captured variable names; it's
empty in this example.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># the body of the method</span>
<span class="p">:(</span><span class="n">begin</span>  <span class="c1"># none, line 2:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Int64</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">add_int</span><span class="p">))(</span><span class="n">x</span><span class="p">::</span><span class="n">Int64</span><span class="p">,</span><span class="n">y</span><span class="p">::</span><span class="n">Int64</span><span class="p">))::</span><span class="n">Int64</span> <span class="c1"># line 3:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Int64</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">mul_int</span><span class="p">))(</span><span class="mi">2</span><span class="p">,</span><span class="n">z</span><span class="p">::</span><span class="n">Int64</span><span class="p">))::</span><span class="n">Int64</span>
    <span class="n">end</span><span class="p">::</span><span class="n">Int64</span><span class="p">)</span>
</pre></div>
</div>
<p>The first two <code class="docutils literal"><span class="pre">args</span></code> elements are metadata about the third. While the
metadata is very interesting, it isn't necessary right now. The
important part is the body of the method, which is the third element.
This is another <code class="docutils literal"><span class="pre">Expr</span></code>.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">body</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="p">:(</span><span class="n">begin</span>  <span class="c1"># none, line 2:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Int64</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">add_int</span><span class="p">))(</span><span class="n">x</span><span class="p">::</span><span class="n">Int64</span><span class="p">,</span><span class="n">y</span><span class="p">::</span><span class="n">Int64</span><span class="p">))::</span><span class="n">Int64</span> <span class="c1"># line 3:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Int64</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">mul_int</span><span class="p">))(</span><span class="mi">2</span><span class="p">,</span><span class="n">z</span><span class="p">::</span><span class="n">Int64</span><span class="p">))::</span><span class="n">Int64</span>
    <span class="n">end</span><span class="p">::</span><span class="n">Int64</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">body</span><span class="o">.</span><span class="n">head</span>
<span class="p">:</span><span class="n">body</span>
</pre></div>
</div>
<p>This <code class="docutils literal"><span class="pre">Expr</span></code> has head <code class="docutils literal"><span class="pre">:body</span></code> because it's the body of the method.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">body</span><span class="o">.</span><span class="n">typ</span>
<span class="n">Int64</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">typ</span></code> is the inferred return type of the method.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">body</span><span class="o">.</span><span class="n">args</span>
<span class="mi">4</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="n">Any</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="p">:(</span> <span class="c1"># none, line 2:)</span>
 <span class="p">:(</span><span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Int64</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">add_int</span><span class="p">))(</span><span class="n">x</span><span class="p">::</span><span class="n">Int64</span><span class="p">,</span><span class="n">y</span><span class="p">::</span><span class="n">Int64</span><span class="p">))::</span><span class="n">Int64</span><span class="p">)</span>
 <span class="p">:(</span> <span class="c1"># line 3:)</span>
 <span class="p">:(</span><span class="k">return</span> <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Int64</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">mul_int</span><span class="p">))(</span><span class="mi">2</span><span class="p">,</span><span class="n">z</span><span class="p">::</span><span class="n">Int64</span><span class="p">))::</span><span class="n">Int64</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">args</span></code> holds a list of expressions: the list of expressions in the
method's body. There are a couple of annotations of line numbers (i.e.,
<code class="docutils literal"><span class="pre">:(</span> <span class="pre">#</span> <span class="pre">line</span> <span class="pre">3:)</span></code>), but most of the body is setting the value of <code class="docutils literal"><span class="pre">z</span></code>
(<code class="docutils literal"><span class="pre">z</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>) and returning <code class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">z</span></code>. Notice that these operations
have been replaced by <code class="docutils literal"><span class="pre">Int64</span></code>-specific intrinsic functions. The
<code class="docutils literal"><span class="pre">top(function-name)</span></code> indicates an intrinsic function; something that
is implemented in Julia's code generation, rather than in Julia.</p>
<p>We haven't seen what a loop looks like yet, so let's try that.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">function</span> <span class="n">lloop</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="mi">100</span>
           <span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span>
         <span class="n">end</span>
       <span class="n">end</span>
<span class="n">lloop</span> <span class="p">(</span><span class="n">generic</span> <span class="n">function</span> <span class="k">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">code_typed</span><span class="p">(</span><span class="n">lloop</span><span class="p">,</span> <span class="p">(</span><span class="n">Int</span><span class="p">,))[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="p">:(</span><span class="n">begin</span>  <span class="c1"># none, line 2:</span>
        <span class="c1">#s120 = $(Expr(:new, UnitRange{Int64}, 1, :(((top(getfield))(Intrinsics,</span>
         <span class="p">:</span><span class="n">select_value</span><span class="p">))((</span><span class="n">top</span><span class="p">(</span><span class="n">sle_int</span><span class="p">))(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)::</span><span class="n">Bool</span><span class="p">,</span><span class="mi">100</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Int64</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span>
         <span class="n">sub_int</span><span class="p">))(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))::</span><span class="n">Int64</span><span class="p">)::</span><span class="n">Int64</span><span class="p">)))::</span><span class="n">UnitRange</span><span class="p">{</span><span class="n">Int64</span><span class="p">}</span>
        <span class="c1">#s119 = (top(getfield))(#s120::UnitRange{Int64},:start)::Int64        unless</span>
         <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Bool</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">not_int</span><span class="p">))(</span><span class="c1">#s119::Int64 === (top(box))(Int64,(top(</span>
         <span class="n">add_int</span><span class="p">))((</span><span class="n">top</span><span class="p">(</span><span class="n">getfield</span><span class="p">))</span>
         <span class="p">(</span><span class="c1">#s120::UnitRange{Int64},:stop)::Int64,1))::Int64::Bool))::Bool goto 1</span>
        <span class="mi">2</span><span class="p">:</span>
        <span class="n">_var0</span> <span class="o">=</span> <span class="c1">#s119::Int64</span>
        <span class="n">_var1</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Int64</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">add_int</span><span class="p">))(</span><span class="c1">#s119::Int64,1))::Int64</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_var0</span><span class="p">::</span><span class="n">Int64</span>
        <span class="c1">#s119 = _var1::Int64 # line 3:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Int64</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">mul_int</span><span class="p">))(</span><span class="n">x</span><span class="p">::</span><span class="n">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">))::</span><span class="n">Int64</span>
        <span class="mi">3</span><span class="p">:</span>
        <span class="n">unless</span> <span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Bool</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">not_int</span><span class="p">))((</span><span class="n">top</span><span class="p">(</span><span class="n">box</span><span class="p">))(</span><span class="n">Bool</span><span class="p">,(</span><span class="n">top</span><span class="p">(</span><span class="n">not_int</span><span class="p">))</span>
         <span class="p">(</span><span class="c1">#s119::Int64 === (top(box))(Int64,(top(add_int))((top(getfield))(</span>
         <span class="c1">#s120::UnitRange{Int64},:stop)::Int64,1))::Int64::Bool))::Bool))::Bool</span>
         <span class="n">goto</span> <span class="mi">2</span>
        <span class="mi">1</span><span class="p">:</span>         <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">end</span><span class="p">::</span><span class="n">Nothing</span><span class="p">)</span>
</pre></div>
</div>
<p>You'll notice there's no for or while loop in the body. As the compiler
transforms the code from what we wrote to the binary instructions the
CPU understands, features that are useful to humans but that are not
understood by the CPU (like loops) are removed. The loop has been
rewritten as <code class="docutils literal"><span class="pre">label</span></code> and <code class="docutils literal"><span class="pre">goto</span></code> expressions. The <code class="docutils literal"><span class="pre">goto</span></code> has a
number in it; each <code class="docutils literal"><span class="pre">label</span></code> also has a number. The <code class="docutils literal"><span class="pre">goto</span></code> jumps to
the the <code class="docutils literal"><span class="pre">label</span></code> with the same number.</p>
<p class="rubric" id="detecting-and-extracting-loops">Detecting and Extracting Loops</p>
<p>We're going to find loops by looking for <code class="docutils literal"><span class="pre">goto</span></code> expressions that jump
backwards.</p>
<p>We'll need to find the labels and gotos, and figure out which ones
match. I'm going to give you the full implementation first. After the
wall of code, we'll take it apart and examine the pieces.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span># This is a function for trying to detect loops in the body of a Method
# Returns lines that are inside one or more loops
function loopcontents(e::Expr)
  b = body(e)
  loops = Int[]
  nesting = 0
  lines = {}
  for i in 1:length(b)
    if typeof(b[i]) == LabelNode
      l = b[i].label
      jumpback = findnext(x-&gt; (typeof(x) == GotoNode &amp;&amp; x.label == l)
                              || (Base.is_expr(x,:gotoifnot) &amp;&amp; x.args[end] == l),
                          b, i)
      if jumpback != 0
        push!(loops,jumpback)
        nesting += 1
      end
    end
    if nesting &gt; 0
      push!(lines,(i,b[i]))
    end

    if typeof(b[i]) == GotoNode &amp;&amp; in(i,loops)
      splice!(loops,findfirst(loops,i))
      nesting -= 1
    end
  end
  lines
end
</pre></div>
</div>
<p>And now to explain in pieces:</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">body</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>We start by getting all the expressions in the body of method, as an
<code class="docutils literal"><span class="pre">Array</span></code>. <code class="docutils literal"><span class="pre">body</span></code> is a function that I've already implemented:</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Return the body of a Method.</span>
<span class="c1"># Takes an Expr representing a Method,</span>
<span class="c1"># returns Vector{Expr}.</span>
<span class="n">function</span> <span class="n">body</span><span class="p">(</span><span class="n">e</span><span class="p">::</span><span class="n">Expr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">args</span>
<span class="n">end</span>
</pre></div>
</div>
<p>And then:</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">loops</span> <span class="o">=</span> <span class="n">Int</span><span class="p">[]</span>
<span class="n">nesting</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lines</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">loops</span></code> is an <code class="docutils literal"><span class="pre">Array</span></code> of label line numbers where gotos that are
loops occur. <code class="docutils literal"><span class="pre">nesting</span></code> indicates the number of loops we are currently
inside. <code class="docutils literal"><span class="pre">lines</span></code> is an <code class="docutils literal"><span class="pre">Array</span></code> of (index, <code class="docutils literal"><span class="pre">Expr</span></code>) tuples.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>for i in 1:length(b)
  if typeof(b[i]) == LabelNode
    l = b[i].label
    jumpback = findnext(
      x-&gt; (typeof(x) == GotoNode &amp;&amp; x.label == l)
          || (Base.is_expr(x,:gotoifnot) &amp;&amp; x.args[end] == l),
      b, i)
    if jumpback != 0
      push!(loops,jumpback)
      nesting += 1
    end
  end
</pre></div>
</div>
<p>We look at each expression in the body of <code class="docutils literal"><span class="pre">e</span></code>. If it is a label, we
check to see if there is a goto that jumps to this label (and occurs
after the current index). If the result of <code class="docutils literal"><span class="pre">findnext</span></code> is greater than
zero, then such a goto node exists, so we'll add that to <code class="docutils literal"><span class="pre">loops</span></code> (the
<code class="docutils literal"><span class="pre">Array</span></code> of loops we are currently in) and increment our <code class="docutils literal"><span class="pre">nesting</span></code>
level.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>if nesting &gt; 0
  push!(lines,(i,b[i]))
end
</pre></div>
</div>
<p>If we're currently inside a loop, we push the current line to our array
of lines to return.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>    if typeof(b[i]) == GotoNode &amp;&amp; in(i,loops)
      splice!(loops,findfirst(loops,i))
      nesting -= 1
    end
  end
  lines
end
</pre></div>
</div>
<p>If we're at a <code class="docutils literal"><span class="pre">GotoNode</span></code>, then we check to see if it's the end of a
loop. If so, we remove the entry from <code class="docutils literal"><span class="pre">loops</span></code> and reduce our nesting
level.</p>
<p>The result of this function is the <code class="docutils literal"><span class="pre">lines</span></code> array, an array of (index,
value) tuples. This means that each value in the array has an index into
the method-body-<code class="docutils literal"><span class="pre">Expr</span></code>'s body and the value at that index. Each
element of <code class="docutils literal"><span class="pre">lines</span></code> is an expression that occurred inside a loop.</p>
<p class="rubric" id="finding-and-typing-variables">Finding and Typing Variables</p>
<p>We just finished the function <code class="docutils literal"><span class="pre">loopcontents</span></code> which returns the
<code class="docutils literal"><span class="pre">Expr</span></code>s that are inside loops. Our next function will be
<code class="docutils literal"><span class="pre">loosetypes</span></code>, which takes a list of <code class="docutils literal"><span class="pre">Expr</span></code>s and returns a list of
variables that are loosely typed. Later, we'll pass the output of
<code class="docutils literal"><span class="pre">loopcontents</span></code> into <code class="docutils literal"><span class="pre">loosetypes</span></code>.</p>
<p>In each expression that occurred inside a loop, <code class="docutils literal"><span class="pre">loosetypes</span></code> searches
for occurrences of symbols and their associated types. Variable usages
show up as <code class="docutils literal"><span class="pre">SymbolNode</span></code>s in the AST; <code class="docutils literal"><span class="pre">SymbolNode</span></code>s hold the name
and inferred type of the variable.</p>
<p>We can't just check each expression that <code class="docutils literal"><span class="pre">loopcontents</span></code> collected to
see if it's a <code class="docutils literal"><span class="pre">SymbolNode</span></code>. The problem is that each <code class="docutils literal"><span class="pre">Expr</span></code> may
contain one or more <code class="docutils literal"><span class="pre">Expr</span></code>; each <code class="docutils literal"><span class="pre">Expr</span></code> may contain one or more
<code class="docutils literal"><span class="pre">SymbolNode</span></code>s. This means we need to pull out any nested
<code class="docutils literal"><span class="pre">Expr</span></code>s, so that we can look in each of them for <code class="docutils literal"><span class="pre">SymbolNode</span></code>s.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span># given `lr`, a Vector of expressions (Expr + literals, etc)
# try to find all occurrences of a variables in `lr`
# and determine their types
function loosetypes(lr::Vector)
  symbols = SymbolNode[]
  for (i,e) in lr
    if typeof(e) == Expr
      es = copy(e.args)
      while !isempty(es)
        e1 = pop!(es)
        if typeof(e1) == Expr
          append!(es,e1.args)
        elseif typeof(e1) == SymbolNode
          push!(symbols,e1)
        end
      end
    end
  end
  loose_types = SymbolNode[]
  for symnode in symbols
    if !isleaftype(symnode.typ) &amp;&amp; typeof(symnode.typ) == UnionType
      push!(loose_types, symnode)
    end
  end
  return loose_types
end
</pre></div>
</div>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>symbols = SymbolNode[]
for (i,e) in lr
  if typeof(e) == Expr
    es = copy(e.args)
    while !isempty(es)
      e1 = pop!(es)
      if typeof(e1) == Expr
        append!(es,e1.args)
      elseif typeof(e1) == SymbolNode
        push!(symbols,e1)
      end
    end
  end
end
</pre></div>
</div>
<p>The while loop goes through the guts of all the <code class="docutils literal"><span class="pre">Expr</span></code>s,
recursively. Every time the loop finds a <code class="docutils literal"><span class="pre">SymbolNode</span></code>, it adds it to
the vector <code class="docutils literal"><span class="pre">symbols</span></code>.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>  loose_types = SymbolNode[]
  for symnode in symbols
    if !isleaftype(symnode.typ) &amp;&amp; typeof(symnode.typ) == UnionType
      push!(loose_types, symnode)
    end
  end
  return loose_types
end
</pre></div>
</div>
<p>Now we have a list of variables and their types, so it's easy to check
if a type is loose. <code class="docutils literal"><span class="pre">loosetypes</span></code> does that by looking for a specific
kind of non-concrete type, a <code class="docutils literal"><span class="pre">UnionType</span></code>. We get a lot more &quot;failing&quot;
results when we consider all non-concrete types to be &quot;failing&quot;. This is
because we're evaluating each method with its annotated argument types,
which are likely to be abstract.</p>
<p class="rubric" id="making-this-usable">Making This Usable</p>
<p>Now that we can do the check on an expression, we should make it easier
to call on a user's code. We'll create two ways to call
<code class="docutils literal"><span class="pre">checklooptypes</span></code>:</p>
<ol class="arabic simple">
<li>On a whole function; this will check each method of the given
function.</li>
<li>On an expression; this will work if the user extracts the results of
<code class="docutils literal"><span class="pre">code_typed</span></code> themselves.</li>
</ol>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>## for a given Function, run checklooptypes on each Method
function checklooptypes(f::Callable;kwargs...)
  lrs = LoopResult[]
  for e in code_typed(f)
    lr = checklooptypes(e)
    if length(lr.lines) &gt; 0 push!(lrs,lr) end
  end
  LoopResults(f.env.name,lrs)
end

# for an Expr representing a Method,
# check that the type of each variable used in a loop
# has a concrete type
checklooptypes(e::Expr;kwargs...) =
 LoopResult(MethodSignature(e),loosetypes(loopcontents(e)))
</pre></div>
</div>
<p>We can see both options work about the same for a function with one
method:</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">using</span> <span class="n">TypeCheck</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">function</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Int</span><span class="p">)</span>
         <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">x</span>
           <span class="n">s</span> <span class="o">+=</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span>
         <span class="n">end</span>
         <span class="k">return</span> <span class="n">s</span>
       <span class="n">end</span>
<span class="n">foo</span> <span class="p">(</span><span class="n">generic</span> <span class="n">function</span> <span class="k">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">checklooptypes</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="n">foo</span><span class="p">(</span><span class="n">Int64</span><span class="p">)::</span><span class="n">Union</span><span class="p">(</span><span class="n">Int64</span><span class="p">,</span><span class="n">Float64</span><span class="p">)</span>
    <span class="n">s</span><span class="p">::</span><span class="n">Union</span><span class="p">(</span><span class="n">Int64</span><span class="p">,</span><span class="n">Float64</span><span class="p">)</span>
    <span class="n">s</span><span class="p">::</span><span class="n">Union</span><span class="p">(</span><span class="n">Int64</span><span class="p">,</span><span class="n">Float64</span><span class="p">)</span>


<span class="n">julia</span><span class="o">&gt;</span> <span class="n">checklooptypes</span><span class="p">(</span><span class="n">code_typed</span><span class="p">(</span><span class="n">foo</span><span class="p">,(</span><span class="n">Int</span><span class="p">,))[</span><span class="mi">1</span><span class="p">])</span>
<span class="p">(</span><span class="n">Int64</span><span class="p">)::</span><span class="n">Union</span><span class="p">(</span><span class="n">Int64</span><span class="p">,</span><span class="n">Float64</span><span class="p">)</span>
    <span class="n">s</span><span class="p">::</span><span class="n">Union</span><span class="p">(</span><span class="n">Int64</span><span class="p">,</span><span class="n">Float64</span><span class="p">)</span>
    <span class="n">s</span><span class="p">::</span><span class="n">Union</span><span class="p">(</span><span class="n">Int64</span><span class="p">,</span><span class="n">Float64</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric" id="pretty-printing">Pretty Printing</p>
<p>I've skipped an implementation detail here: how did we get the results
to print out to the REPL?</p>
<p>First, I made some new types. <code class="docutils literal"><span class="pre">LoopResults</span></code> is the result of checking
a whole function; it has the function name and the results for each
method. <code class="docutils literal"><span class="pre">LoopResult</span></code> is the result of checking one method; it has the
argument types and the loosely typed variables.</p>
<p>The <code class="docutils literal"><span class="pre">checklooptypes</span></code> function returns a <code class="docutils literal"><span class="pre">LoopResults</span></code>. This type has
a function called <code class="docutils literal"><span class="pre">show</span></code> defined for it. The REPL calls <code class="docutils literal"><span class="pre">display</span></code> on
values it wants to display; <code class="docutils literal"><span class="pre">display</span></code> will then call our <code class="docutils literal"><span class="pre">show</span></code>
implementation.</p>
<p>This code is important for making this static analysis usable, but it is
not doing static analysis. You should use the preferred method for
pretty-printing types and output in your implementation language; this
is just how it's done in Julia.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">LoopResult</span>
  <span class="n">msig</span><span class="p">::</span><span class="n">MethodSignature</span>
  <span class="n">lines</span><span class="p">::</span><span class="n">Vector</span><span class="p">{</span><span class="n">SymbolNode</span><span class="p">}</span>
  <span class="n">LoopResult</span><span class="p">(</span><span class="n">ms</span><span class="p">::</span><span class="n">MethodSignature</span><span class="p">,</span><span class="n">ls</span><span class="p">::</span><span class="n">Vector</span><span class="p">{</span><span class="n">SymbolNode</span><span class="p">})</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span><span class="n">unique</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span>
<span class="n">end</span>

<span class="n">function</span> <span class="n">Base</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">io</span><span class="p">::</span><span class="n">IO</span><span class="p">,</span> <span class="n">x</span><span class="p">::</span><span class="n">LoopResult</span><span class="p">)</span>
  <span class="n">display</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">msig</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">snode</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">lines</span>
    <span class="n">println</span><span class="p">(</span><span class="n">io</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">string</span><span class="p">(</span><span class="n">snode</span><span class="o">.</span><span class="n">name</span><span class="p">),</span><span class="s2">&quot;::&quot;</span><span class="p">,</span><span class="n">string</span><span class="p">(</span><span class="n">snode</span><span class="o">.</span><span class="n">typ</span><span class="p">))</span>
  <span class="n">end</span>
<span class="n">end</span>

<span class="nb">type</span> <span class="n">LoopResults</span>
  <span class="n">name</span><span class="p">::</span><span class="n">Symbol</span>
  <span class="n">methods</span><span class="p">::</span><span class="n">Vector</span><span class="p">{</span><span class="n">LoopResult</span><span class="p">}</span>
<span class="n">end</span>

<span class="n">function</span> <span class="n">Base</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">io</span><span class="p">::</span><span class="n">IO</span><span class="p">,</span> <span class="n">x</span><span class="p">::</span><span class="n">LoopResults</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">lr</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">methods</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span><span class="n">string</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
    <span class="n">display</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span>
  <span class="n">end</span>
<span class="n">end</span>
</pre></div>
</div>
<p class="rubric" id="looking-for-unused-variables">Looking For Unused Variables</p>
<p>Sometimes, as you're typing in your program, you mistype a variable
name. The program can't tell that you meant for this to be the same
variable that you spelled correctly before; it sees a variable used only
one time, where you might see a variable name misspelled. Languages that
require variable declarations naturally catch these misspellings, but
many dynamic languages don’t require declarations and thus need an extra
layer of analysis to catch them.</p>
<p>We can find misspelled variable names (and other unused variables) by
looking for variables that are only used once—or only used one way.</p>
<p>Here is an example of a little bit of code with one misspelled name.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">foo</span><span class="p">(</span><span class="n">variable_name</span><span class="p">::</span><span class="n">Int</span><span class="p">)</span>
  <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">variable_name</span>
    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">variable_name</span>
  <span class="n">end</span>
  <span class="n">variable_nme</span> <span class="o">=</span> <span class="nb">sum</span>
  <span class="k">return</span> <span class="n">variable_name</span>
<span class="n">end</span>
</pre></div>
</div>
<p>This kind of mistake can cause problems in your code that are only
discovered when it's run. Let's assume you misspell each variable name
only once. We can separate variable usages into writes and reads. If the
misspelling is a write (i.e., <code class="docutils literal"><span class="pre">worng</span> <span class="pre">=</span> <span class="pre">5</span></code>), then no error will be
thrown; you'll just be silently putting the value in the wrong
variable—and it could be frustrating to find the bug. If the misspelling
is a read (i.e., <code class="docutils literal"><span class="pre">right</span> <span class="pre">=</span> <span class="pre">worng</span> <span class="pre">+</span> <span class="pre">2</span></code>), then you'll get a runtime error
when the code is run; we'd like to have a static warning for this, so
that you can find this error sooner, but you will still have to wait
until you run the code to see the problem.</p>
<p>As code becomes longer and more complicated, it becomes harder to spot
the mistake—unless you have the help of static analysis.</p>
<p class="rubric" id="left-hand-side-and-right-hand-side">Left-Hand Side and Right-Hand Side</p>
<p>Another way to talk about &quot;read&quot; and &quot;write&quot; usages is to call them
&quot;right-hand side&quot; (RHS) and &quot;left-hand side&quot; (LHS) usages. This refers
to where the variable is relative to the <code class="docutils literal"><span class="pre">=</span></code> sign.</p>
<p>Here are some usages of <code class="docutils literal"><span class="pre">x</span></code>:</p>
<ul class="simple">
<li>Left-hand side:<ul>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">2</span></code></li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">22</span></code></li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">2</span></code></li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">2</span></code> (which de-sugars to <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">2</span></code>)</li>
</ul>
</li>
<li>Right-hand side:<ul>
<li><code class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">22</span></code></li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">2</span></code></li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">2</span></code> (which de-sugars to <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">2</span></code>)</li>
<li><code class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">x</span></code></li>
<li><code class="docutils literal"><span class="pre">x</span></code></li>
</ul>
</li>
</ul>
<p>Notice that expressions like <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">2</span></code> and <code class="docutils literal"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">2</span></code> appear in
both sections, since <code class="docutils literal"><span class="pre">x</span></code> appears on both sides of the <code class="docutils literal"><span class="pre">=</span></code> sign.</p>
<p class="rubric" id="looking-for-single-use-variables">Looking for Single-Use Variables</p>
<p>There are two cases we need to look for:</p>
<ol class="arabic simple">
<li>Variables used once.</li>
<li>Variables used only on the LHS or only on the RHS.</li>
</ol>
<p>We'll look for all variable usages, but we'll look for LHS and RHS
usages separately, to cover both cases.</p>
<p class="rubric" id="finding-lhs-usages">Finding LHS Usages</p>
<p>To be on the LHS, a variable needs to have an <code class="docutils literal"><span class="pre">=</span></code> sign to be to the
left of. This means we can look for <code class="docutils literal"><span class="pre">=</span></code> signs in the AST, and then
look to the left of them to find the relevant variable.</p>
<p>In the AST, an <code class="docutils literal"><span class="pre">=</span></code> is an <code class="docutils literal"><span class="pre">Expr</span></code> with the head <code class="docutils literal"><span class="pre">:(=)</span></code>. (The
parentheses are there to make it clear that this is the symbol for <code class="docutils literal"><span class="pre">=</span></code>
and not another operator, <code class="docutils literal"><span class="pre">:=</span></code>.) The first value in <code class="docutils literal"><span class="pre">args</span></code> will be
the variable name on its LHS. Because we're looking at an AST that the
compiler has already cleaned up, there will (nearly) always be just a
single symbol to the left of our <code class="docutils literal"><span class="pre">=</span></code> sign.</p>
<p>Let's see what that means in code:</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="p">:(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">:(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">:(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">head</span>
<span class="p">:(</span><span class="o">=</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">:(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>
<span class="mi">2</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="n">Any</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
  <span class="p">:</span><span class="n">x</span>
 <span class="mi">5</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">:(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">:</span><span class="n">x</span>
</pre></div>
</div>
<p>Below is the full implementation, followed by an explanation.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span># Return a list of all variables used on the left-hand-side of assignment (=)
#
# Arguments:
#   e: an Expr representing a Method, as from code_typed
#
# Returns:
#   a Set{Symbol}, where each element appears on the LHS of an assignment in e.
#
function find_lhs_variables(e::Expr)
  output = Set{Symbol}()
  for ex in body(e)
    if Base.is_expr(ex,:(=))
      push!(output,ex.args[1])
    end
  end
  return output
end
</pre></div>
</div>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">output</span> <span class="o">=</span> <span class="n">Set</span><span class="p">{</span><span class="n">Symbol</span><span class="p">}()</span>
</pre></div>
</div>
<p>We have a set of Symbols; those are variables names we've found on the
LHS.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>for ex in body(e)
  if Base.is_expr(ex,:(=))
    push!(output,ex.args[1])
  end
end
</pre></div>
</div>
<p>We aren't digging deeper into the expressions, because the
<code class="docutils literal"><span class="pre">code_typed</span></code> AST is pretty flat; loops and ifs have been converted to
flat statements with gotos for control flow. There won't be any
assignments hiding inside function calls' arguments. This code will fail
if anything more than a symbol is on the left of the equal sign. This
misses two specific edge cases: array accesses (like <code class="docutils literal"><span class="pre">a[5]</span></code>, which
will be represented as a <code class="docutils literal"><span class="pre">:ref</span></code> expression) and properties (like
<code class="docutils literal"><span class="pre">a.head</span></code>, which will be represented as a <code class="docutils literal"><span class="pre">:.</span></code> expression). These
will still always have the relevant symbol as the first value in their
<code class="docutils literal"><span class="pre">args</span></code>, it might just be buried a bit (as in
<code class="docutils literal"><span class="pre">a.property.name.head.other_property</span></code>). This code doesn’t handle those
cases, but a couple lines of code inside the <code class="docutils literal"><span class="pre">if</span></code> statement could fix
that.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>push!(output,ex.args[1])
</pre></div>
</div>
<p>When we find a LHS variable usage, we <code class="docutils literal"><span class="pre">push!</span></code> the variable name into
the <code class="docutils literal"><span class="pre">Set</span></code>. The <code class="docutils literal"><span class="pre">Set</span></code> will make sure that we only have one copy of
each name.</p>
<p class="rubric" id="finding-rhs-usages">Finding RHS usages</p>
<p>To find all the other variable usages, we also need to look at each
<code class="docutils literal"><span class="pre">Expr</span></code>. This is a bit more involved, because we care about basically
all the <code class="docutils literal"><span class="pre">Expr</span></code>s, not just the <code class="docutils literal"><span class="pre">:(=)</span></code> ones and because we have to
dig into nested <code class="docutils literal"><span class="pre">Expr</span></code>s (to handle nested function calls).</p>
<p>Here is the full implementation, with explanation following.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span># Given an Expression, finds variables used in it (on right-hand-side)
#
# Arguments: e: an Expr
#
# Returns: a Set{Symbol}, where each e is used in a rhs expression in e
#
function find_rhs_variables(e::Expr)
  output = Set{Symbol}()

  if e.head == :lambda
    for ex in body(e)
      union!(output,find_rhs_variables(ex))
    end
  elseif e.head == :(=)
    for ex in e.args[2:end]  # skip lhs
      union!(output,find_rhs_variables(ex))
    end
  elseif e.head == :return
    output = find_rhs_variables(e.args[1])
  elseif e.head == :call
    start = 2  # skip function name
    e.args[1] == TopNode(:box) &amp;&amp; (start = 3)  # skip type name
    for ex in e.args[start:end]
      union!(output,find_rhs_variables(ex))
    end
  elseif e.head == :if
   for ex in e.args # want to check condition, too
     union!(output,find_rhs_variables(ex))
   end
  elseif e.head == :(::)
    output = find_rhs_variables(e.args[1])
  end

  return output
end
</pre></div>
</div>
<p>The main structure of this function is a large if-else statement, where
each case handles a different head-symbol.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">output</span> <span class="o">=</span> <span class="n">Set</span><span class="p">{</span><span class="n">Symbol</span><span class="p">}()</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">output</span></code> is the set of variable names, which we will return at the end
of the function. Since we only care about the fact that each of these
variables has be read at least once, using a <code class="docutils literal"><span class="pre">Set</span></code> frees us from
worrying about the uniqueness of each name.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>if e.head == :lambda
  for ex in body(e)
    union!(output,find_rhs_variables(ex))
  end
</pre></div>
</div>
<p>This is the first condition in the if-else statement. A <code class="docutils literal"><span class="pre">:lambda</span></code>
represents the body of a function. We recurse on the body of the
definition, which should get all the RHS variable usages in the
definition.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>elseif e.head == :(=)
  for ex in e.args[2:end]  # skip lhs
    union!(output,find_rhs_variables(ex))
  end
</pre></div>
</div>
<p>If the head is <code class="docutils literal"><span class="pre">:(=)</span></code>, then the expression is an assignment. We skip
the first element of <code class="docutils literal"><span class="pre">args</span></code> because that's the variable being assigned
to. For each of the remaining expressions, we recursively find the RHS
variables and add them to our set.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">elseif</span> <span class="n">e</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="p">:</span><span class="k">return</span>
  <span class="n">output</span> <span class="o">=</span> <span class="n">find_rhs_variables</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>If this is a return statement, then the first element of <code class="docutils literal"><span class="pre">args</span></code> is the
expression whose value is returned; we'll add any variables in there
into our set.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>elseif e.head == :call
  # skip function name
  for ex in e.args[2:end]
    union!(output,find_rhs_variables(ex))
  end
</pre></div>
</div>
<p>For function calls, we want to get all variables used in all the
arguments to the call. We skip the function name, which is the first
element of <code class="docutils literal"><span class="pre">args</span></code>.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span>elseif e.head == :if
 for ex in e.args # want to check condition, too
   union!(output,find_rhs_variables(ex))
 end
</pre></div>
</div>
<p>An <code class="docutils literal"><span class="pre">Expr</span></code> representing an if statement has the <code class="docutils literal"><span class="pre">head</span></code> value <code class="docutils literal"><span class="pre">:if</span></code>.
We want to get variable usages from all the expressions in the body of
the if statement, so we recurse on each element of <code class="docutils literal"><span class="pre">args</span></code>.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">elseif</span> <span class="n">e</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="p">:(::)</span>
  <span class="n">output</span> <span class="o">=</span> <span class="n">find_rhs_variables</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">end</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">:(::)</span></code> operator is used to add type annotations. The first
argument is the expression or variable being annotated; we check for
variable usages in the annotated expression.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">output</span>
</pre></div>
</div>
<p>At the end of the function, we return the set of RHS variable usages.</p>
<p>There's a little more code that simplifies the method above. Because the
version above only handles <code class="docutils literal"><span class="pre">Expr</span></code>s, but some of the values that get
passed recursively may not be <code class="docutils literal"><span class="pre">Expr</span></code>s, we need a few more methods to
handle the other possible types appropriately.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Recursive Base Cases, to simplify control flow in the Expr version</span>
<span class="n">find_rhs_variables</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">Set</span><span class="p">{</span><span class="n">Symbol</span><span class="p">}()</span>  <span class="c1"># unhandled, should be immediate val e.g. Int</span>
<span class="n">find_rhs_variables</span><span class="p">(</span><span class="n">s</span><span class="p">::</span><span class="n">Symbol</span><span class="p">)</span> <span class="o">=</span> <span class="n">Set</span><span class="p">{</span><span class="n">Symbol</span><span class="p">}([</span><span class="n">s</span><span class="p">])</span>
<span class="n">find_rhs_variables</span><span class="p">(</span><span class="n">s</span><span class="p">::</span><span class="n">SymbolNode</span><span class="p">)</span> <span class="o">=</span> <span class="n">Set</span><span class="p">{</span><span class="n">Symbol</span><span class="p">}([</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric" id="putting-it-together">Putting It Together</p>
<p>Now that we have the two functions defined above, we can use them
together to find variables that are either only read from or only
written to. The function that finds them will be called
<code class="docutils literal"><span class="pre">unused_locals</span></code>.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">unused_locals</span><span class="p">(</span><span class="n">e</span><span class="p">::</span><span class="n">Expr</span><span class="p">)</span>
  <span class="n">lhs</span> <span class="o">=</span> <span class="n">find_lhs_variables</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
  <span class="n">rhs</span> <span class="o">=</span> <span class="n">find_rhs_variables</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
  <span class="n">setdiff</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span><span class="n">rhs</span><span class="p">)</span>
<span class="n">end</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">unused_locals</span></code> will return a set of variable names. It's easy to
write a function that determines whether the output of <code class="docutils literal"><span class="pre">unused_locals</span></code>
counts as a &quot;pass&quot; or not. If the set is empty, the method passes. If
all the methods of a function pass, then the function passes. The
function <code class="docutils literal"><span class="pre">check_locals</span></code> below implements this logic.</p>
<div class="code julia highlight-default"><div class="highlight"><pre><span></span><span class="n">check_locals</span><span class="p">(</span><span class="n">f</span><span class="p">::</span><span class="n">Callable</span><span class="p">)</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">check_locals</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">code_typed</span><span class="p">(</span><span class="n">f</span><span class="p">)])</span>
<span class="n">check_locals</span><span class="p">(</span><span class="n">e</span><span class="p">::</span><span class="n">Expr</span><span class="p">)</span> <span class="o">=</span> <span class="n">isempty</span><span class="p">(</span><span class="n">unused_locals</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric" id="conclusion">Conclusion</p>
<p>We’ve done two static analyses of Julia code—one based on types and one
based on variable usages.</p>
<p>Statically-typed languages already do the kind of work our type-based
analysis did; additional type-based static analysis is mostly useful in
dynamically typed languages. There have been (mostly research) projects
to build static type inference systems for languages including Python,
Ruby, and Lisp. These systems are usually built around optional type
annotations; you can have static types when you want them, and fall back
to dynamic typing when you don’t. This is especially helpful for
integrating some static typing into existing code bases.</p>
<p>Non-typed-based checks, like our variable-usage one, are applicable to
both dynamically and statically typed languages. However, many
statically typed languages, like C++ and Java, require you to declare
variables, and already give basic warnings like the ones we created.
There are still custom checks that can be written; for example, checks
that are specific to your project’s style guide or extra safety
precautions based on security policies.</p>
<p>While Julia does have great tools for enabling static analysis, it’s not
alone. Lisp, of course, is famous for having the code be a data
structure of nested lists, so it tends to be easy to get at the AST.
Java also exposes its AST, although the AST is much more complicated
than Lisp’s. Some languages or language tool-chains are not designed to
allow mere users to poke around at internal representations. For
open-source tool chains (especially well-commented ones), one option is
to add hooks to the enviroment that let you access the AST.</p>
<p>In cases where that won’t work, the final fallback is writing a parser
yourself; this is to be avoided when possible. It’s a lot of work to
cover the full grammar of most programming languages, and you’ll have to
update it yourself as new features are added to the language (rather
than getting the updates automatically from upstream). Depending on the
checks you want to do, you may be able to get away with parsing only
some lines or a subset of language features, which would greatly
decrease the cost of writing your own parser.</p>
<p>Hopefully, your new understanding of how static analysis tools are
written will help you understand the tools you use on your code, and
maybe inspire you to write one of your own.</p>
</div></div></div></div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Learn-Computer-and-Math-again</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="blockcode-a-visual-programming-toolkit.html">500 Lines or Less | Blockcode: A visual programming toolkit</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, timger.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/chapters/static-analysis.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>