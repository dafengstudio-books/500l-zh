
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>500 Lines or Less | A Web Crawler With asyncio Coroutines &#8212; Learn-Computer-and-Math-again 0.0.1 文档</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lines-or-less-a-web-crawler-with-asyncio-coroutines">
<h1>500 Lines or Less | A Web Crawler With asyncio Coroutines<a class="headerlink" href="#lines-or-less-a-web-crawler-with-asyncio-coroutines" title="永久链接至标题">¶</a></h1>
<div class="container"><div class="row"><div class="hero-unit"><p><a href="#id1"><span class="problematic" id="id2">``</span></a>_
.. rubric:: A Web Crawler With asyncio Coroutines</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">a-web-crawler-with-asyncio-coroutines</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p class="author rubric" id="a-jesse-jiryu-davis-and-guido-van-rossum">A. Jesse Jiryu Davis and Guido van Rossum</p>
</div></div><div class="row"><div id="content" class="span10 offset1"><p><em>A. Jesse Jiryu Davis is a staff engineer at MongoDB in New York. He
wrote Motor, the async MongoDB Python driver, and he is the lead
developer of the MongoDB C Driver and a member of the PyMongo team. He
contributes to asyncio and Tornado. He writes at http://emptysqua.re.</em></p>
<p><em>Guido van Rossum is the creator of Python, one of the major programming
languages on and off the web. The Python community refers to him as the
BDFL (Benevolent Dictator For Life), a title straight from a Monty
Python skit. Guido's home on the web is http://www.python.org/~guido/.</em></p>
<p class="rubric" id="introduction">Introduction</p>
<p>Classical computer science emphasizes efficient algorithms that complete
computations as quickly as possible. But many networked programs spend
their time not computing, but holding open many connections that are
slow, or have infrequent events. These programs present a very different
challenge: to wait for a huge number of network events efficiently. A
contemporary approach to this problem is asynchronous I/O, or &quot;async&quot;.</p>
<p>This chapter presents a simple web crawler. The crawler is an archetypal
async application because it waits for many responses, but does little
computation. The more pages it can fetch at once, the sooner it
completes. If it devotes a thread to each in-flight request, then as the
number of concurrent requests rises it will run out of memory or other
thread-related resource before it runs out of sockets. It avoids the
need for threads by using asynchronous I/O.</p>
<p>We present the example in three stages. First, we show an async event
loop and sketch a crawler that uses the event loop with callbacks: it is
very efficient, but extending it to more complex problems would lead to
unmanageable spaghetti code. Second, therefore, we show that Python
coroutines are both efficient and extensible. We implement simple
coroutines in Python using generator functions. In the third stage, we
use the full-featured coroutines from Python's standard &quot;asyncio&quot;
library<a class="reference external" href="#fn1">:sup:`1`</a>, and coordinate them using an async queue.</p>
<p class="rubric" id="the-task">The Task</p>
<p>A web crawler finds and downloads all pages on a website, perhaps to
archive or index them. Beginning with a root URL, it fetches each page,
parses it for links to unseen pages, and adds these to a queue. It stops
when it fetches a page with no unseen links and the queue is empty.</p>
<p>We can hasten this process by downloading many pages concurrently. As
the crawler finds new links, it launches simultaneous fetch operations
for the new pages on separate sockets. It parses responses as they
arrive, adding new links to the queue. There may come some point of
diminishing returns where too much concurrency degrades performance, so
we cap the number of concurrent requests, and leave the remaining links
in the queue until some in-flight requests complete.</p>
<p class="rubric" id="the-traditional-approach">The Traditional Approach</p>
<p>How do we make the crawler concurrent? Traditionally we would create a
thread pool. Each thread would be in charge of downloading one page at a
time over a socket. For example, to download a page from <code class="docutils literal"><span class="pre">xkcd.com</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;xkcd.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="n">request</span> <span class="o">=</span> <span class="s1">&#39;GET </span><span class="si">{}</span><span class="s1"> HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: xkcd.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">b</span><span class="s1">&#39;&#39;</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>

    <span class="c1"># Page is now downloaded.</span>
    <span class="n">links</span> <span class="o">=</span> <span class="n">parse_links</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
    <span class="n">q</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, socket operations are <em>blocking</em>: when the thread calls a
method like <code class="docutils literal"><span class="pre">connect</span></code> or <code class="docutils literal"><span class="pre">recv</span></code>, it pauses until the operation
completes.<a class="reference external" href="#fn2">:sup:`2`</a> Consequently to download many pages at once, we
need many threads. A sophisticated application amortizes the cost of
thread-creation by keeping idle threads in a thread pool, then checking
them out to reuse them for subsequent tasks; it does the same with
sockets in a connection pool.</p>
<p>And yet, threads are expensive, and operating systems enforce a variety
of hard caps on the number of threads a process, user, or machine may
have. On Jesse's system, a Python thread costs around 50k of memory, and
starting tens of thousands of threads causes failures. If we scale up to
tens of thousands of simultaneous operations on concurrent sockets, we
run out of threads before we run out of sockets. Per-thread overhead or
system limits on threads are the bottleneck.</p>
<p>In his influential article &quot;The C10K problem&quot;<a class="reference external" href="#fn3">:sup:`3`</a>, Dan Kegel
outlines the limitations of multithreading for I/O concurrency. He
begins,</p>
<blockquote>
<div>It's time for web servers to handle ten thousand clients
simultaneously, don't you think? After all, the web is a big place
now.</div></blockquote>
<p>Kegel coined the term &quot;C10K&quot; in 1999. Ten thousand connections sounds
dainty now, but the problem has changed only in size, not in kind. Back
then, using a thread per connection for C10K was impractical. Now the
cap is orders of magnitude higher. Indeed, our toy web crawler would
work just fine with threads. Yet for very large scale applications, with
hundreds of thousands of connections, the cap remains: there is a limit
beyond which most systems can still create sockets, but have run out of
threads. How can we overcome this?</p>
<p class="rubric" id="async">Async</p>
<p>Asynchronous I/O frameworks do concurrent operations on a single thread
using <em>non-blocking</em> sockets. In our async crawler, we set the socket
non-blocking before we begin to connect to the server:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;xkcd.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Irritatingly, a non-blocking socket throws an exception from
<code class="docutils literal"><span class="pre">connect</span></code>, even when it is working normally. This exception replicates
the irritating behavior of the underlying C function, which sets
<code class="docutils literal"><span class="pre">errno</span></code> to <code class="docutils literal"><span class="pre">EINPROGRESS</span></code> to tell you it has begun.</p>
<p>Now our crawler needs a way to know when the connection is established,
so it can send the HTTP request. We could simply keep trying in a tight
loop:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">request</span> <span class="o">=</span> <span class="s1">&#39;GET </span><span class="si">{}</span><span class="s1"> HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: xkcd.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="n">encoded</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>
        <span class="k">break</span>  <span class="c1"># Done.</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sent&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This method not only wastes electricity, but it cannot efficiently await
events on <em>multiple</em> sockets. In ancient times, BSD Unix's solution to
this problem was <code class="docutils literal"><span class="pre">select</span></code>, a C function that waits for an event to
occur on a non-blocking socket or a small array of them. Nowadays the
demand for Internet applications with huge numbers of connections has
led to replacements like <code class="docutils literal"><span class="pre">poll</span></code>, then <code class="docutils literal"><span class="pre">kqueue</span></code> on BSD and <code class="docutils literal"><span class="pre">epoll</span></code>
on Linux. These APIs are similar to <code class="docutils literal"><span class="pre">select</span></code>, but perform well with
very large numbers of connections.</p>
<p>Python 3.4's <code class="docutils literal"><span class="pre">DefaultSelector</span></code> uses the best <code class="docutils literal"><span class="pre">select</span></code>-like function
available on your system. To register for notifications about network
I/O, we create a non-blocking socket and register it with the default
selector:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">selectors</span> <span class="k">import</span> <span class="n">DefaultSelector</span><span class="p">,</span> <span class="n">EVENT_WRITE</span>

<span class="n">selector</span> <span class="o">=</span> <span class="n">DefaultSelector</span><span class="p">()</span>

<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;xkcd.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">connected</span><span class="p">():</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;connected!&#39;</span><span class="p">)</span>

<span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_WRITE</span><span class="p">,</span> <span class="n">connected</span><span class="p">)</span>
</pre></div>
</div>
<p>We disregard the spurious error and call <code class="docutils literal"><span class="pre">selector.register</span></code>, passing
in the socket's file descriptor and a constant that expresses what event
we are waiting for. To be notified when the connection is established,
we pass <code class="docutils literal"><span class="pre">EVENT_WRITE</span></code>: that is, we want to know when the socket is
&quot;writable&quot;. We also pass a Python function, <code class="docutils literal"><span class="pre">connected</span></code>, to run when
that event occurs. Such a function is known as a <em>callback</em>.</p>
<p>We process I/O notifications as the selector receives them, in a loop:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">event_key</span><span class="o">.</span><span class="n">data</span>
            <span class="n">callback</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">connected</span></code> callback is stored as <code class="docutils literal"><span class="pre">event_key.data</span></code>, which we
retrieve and execute once the non-blocking socket is connected.</p>
<p>Unlike in our fast-spinning loop above, the call to <code class="docutils literal"><span class="pre">select</span></code> here
pauses, awaiting the next I/O events. Then the loop runs callbacks that
are waiting for these events. Operations that have not completed remain
pending until some future tick of the event loop.</p>
<p>What have we demonstrated already? We showed how to begin an operation
and execute a callback when the operation is ready. An async <em>framework</em>
builds on the two features we have shown—non-blocking sockets and the
event loop—to run concurrent operations on a single thread.</p>
<p>We have achieved &quot;concurrency&quot; here, but not what is traditionally
called &quot;parallelism&quot;. That is, we built a tiny system that does
overlapping I/O. It is capable of beginning new operations while others
are in flight. It does not actually utilize multiple cores to execute
computation in parallel. But then, this system is designed for I/O-bound
problems, not CPU-bound ones.<a class="reference external" href="#fn4">:sup:`4`</a></p>
<p>So our event loop is efficient at concurrent I/O because it does not
devote thread resources to each connection. But before we proceed, it is
important to correct a common misapprehension that async is <em>faster</em>
than multithreading. Often it is not—indeed, in Python, an event loop
like ours is moderately slower than multithreading at serving a small
number of very active connections. In a runtime without a global
interpreter lock, threads would perform even better on such a workload.
What asynchronous I/O is right for, is applications with many slow or
sleepy connections with infrequent events.<a class="reference external" href="#fn5">:sup:`5`</a></p>
<p class="rubric" id="programming-with-callbacks">Programming With Callbacks</p>
<p>With the runty async framework we have built so far, how can we build a
web crawler? Even a simple URL-fetcher is painful to write.</p>
<p>We begin with global sets of the URLs we have yet to fetch, and the URLs
we have seen:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">urls_todo</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;/&#39;</span><span class="p">])</span>
<span class="n">seen_urls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;/&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">seen_urls</span></code> set includes <code class="docutils literal"><span class="pre">urls_todo</span></code> plus completed URLs. The
two sets are initialized with the root URL &quot;/&quot;.</p>
<p>Fetching a page will require a series of callbacks. The <code class="docutils literal"><span class="pre">connected</span></code>
callback fires when a socket is connected, and sends a GET request to
the server. But then it must await a response, so it registers another
callback. If, when that callback fires, it cannot read the full response
yet, it registers again, and so on.</p>
<p>Let us collect these callbacks into a <code class="docutils literal"><span class="pre">Fetcher</span></code> object. It needs a
URL, a socket object, and a place to accumulate the response bytes:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Fetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="n">b</span><span class="s1">&#39;&#39;</span>  <span class="c1"># Empty array of bytes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<p>We begin by calling <code class="docutils literal"><span class="pre">Fetcher.fetch</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Method on Fetcher class.</span>
<span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;xkcd.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Register next callback.</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                      <span class="n">EVENT_WRITE</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">fetch</span></code> method begins connecting a socket. But notice the method
returns before the connection is established. It must return control to
the event loop to wait for the connection. To understand why, imagine
our whole application was structured so:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Begin fetching http://xkcd.com/353/</span>
<span class="n">fetcher</span> <span class="o">=</span> <span class="n">Fetcher</span><span class="p">(</span><span class="s1">&#39;/353/&#39;</span><span class="p">)</span>
<span class="n">fetcher</span><span class="o">.</span><span class="n">fetch</span><span class="p">()</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="n">callback</span> <span class="o">=</span> <span class="n">event_key</span><span class="o">.</span><span class="n">data</span>
        <span class="n">callback</span><span class="p">(</span><span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span><span class="p">)</span>
</pre></div>
</div>
<p>All event notifications are processed in the event loop when it calls
<code class="docutils literal"><span class="pre">select</span></code>. Hence <code class="docutils literal"><span class="pre">fetch</span></code> must hand control to the event loop, so that
the program knows when the socket has connected. Only then does the loop
run the <code class="docutils literal"><span class="pre">connected</span></code> callback, which was registered at the end of
<code class="docutils literal"><span class="pre">fetch</span></code> above.</p>
<p>Here is the implementation of <code class="docutils literal"><span class="pre">connected</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Method on Fetcher class.</span>
<span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;connected!&#39;</span><span class="p">)</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>
    <span class="n">request</span> <span class="o">=</span> <span class="s1">&#39;GET </span><span class="si">{}</span><span class="s1"> HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: xkcd.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

    <span class="c1"># Register the next callback.</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span>
                      <span class="n">EVENT_READ</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">read_response</span><span class="p">)</span>
</pre></div>
</div>
<p>The method sends a GET request. A real application would check the
return value of <code class="docutils literal"><span class="pre">send</span></code> in case the whole message cannot be sent at
once. But our request is small and our application unsophisticated. It
blithely calls <code class="docutils literal"><span class="pre">send</span></code>, then waits for a response. Of course, it must
register yet another callback and relinquish control to the event loop.
The next and final callback, <code class="docutils literal"><span class="pre">read_response</span></code>, processes the server's
reply:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Method on Fetcher class.</span>
<span class="k">def</span> <span class="nf">read_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">stopped</span>

    <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>  <span class="c1"># 4k chunk size.</span>
    <span class="k">if</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>  <span class="c1"># Done reading.</span>
        <span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_links</span><span class="p">()</span>

        <span class="c1"># Python set-logic:</span>
        <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">seen_urls</span><span class="p">):</span>
            <span class="n">urls_todo</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
            <span class="n">Fetcher</span><span class="p">(</span><span class="n">link</span><span class="p">)</span><span class="o">.</span><span class="n">fetch</span><span class="p">()</span>  <span class="c1"># &lt;- New Fetcher.</span>

        <span class="n">seen_urls</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
        <span class="n">urls_todo</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">urls_todo</span><span class="p">:</span>
            <span class="n">stopped</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>The callback is executed each time the selector sees that the socket is
&quot;readable&quot;, which could mean two things: the socket has data or it is
closed.</p>
<p>The callback asks for up to four kilobytes of data from the socket. If
less is ready, <code class="docutils literal"><span class="pre">chunk</span></code> contains whatever data is available. If there
is more, <code class="docutils literal"><span class="pre">chunk</span></code> is four kilobytes long and the socket remains
readable, so the event loop runs this callback again on the next tick.
When the response is complete, the server has closed the socket and
<code class="docutils literal"><span class="pre">chunk</span></code> is empty.</p>
<p>The <code class="docutils literal"><span class="pre">parse_links</span></code> method, not shown, returns a set of URLs. We start a
new fetcher for each new URL, with no concurrency cap. Note a nice
feature of async programming with callbacks: we need no mutex around
changes to shared data, such as when we add links to <code class="docutils literal"><span class="pre">seen_urls</span></code>.
There is no preemptive multitasking, so we cannot be interrupted at
arbitrary points in our code.</p>
<p>We add a global <code class="docutils literal"><span class="pre">stopped</span></code> variable and use it to control the loop:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">stopped</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stopped</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">event_key</span><span class="o">.</span><span class="n">data</span>
            <span class="n">callback</span><span class="p">()</span>
</pre></div>
</div>
<p>Once all pages are downloaded the fetcher stops the global event loop
and the program exits.</p>
<p>This example makes async's problem plain: spaghetti code. We need some
way to express a series of computations and I/O operations, and schedule
multiple such series of operations to run concurrently. But without
threads, a series of operations cannot be collected into a single
function: whenever a function begins an I/O operation, it explicitly
saves whatever state will be needed in the future, then returns. You are
responsible for thinking about and writing this state-saving code.</p>
<p>Let us explain what we mean by that. Consider how simply we fetched a
URL on a thread with a conventional blocking socket:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Blocking version.</span>
<span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;xkcd.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="n">request</span> <span class="o">=</span> <span class="s1">&#39;GET </span><span class="si">{}</span><span class="s1"> HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: xkcd.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">b</span><span class="s1">&#39;&#39;</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>

    <span class="c1"># Page is now downloaded.</span>
    <span class="n">links</span> <span class="o">=</span> <span class="n">parse_links</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
    <span class="n">q</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
</pre></div>
</div>
<p>What state does this function remember between one socket operation and
the next? It has the socket, a URL, and the accumulating <code class="docutils literal"><span class="pre">response</span></code>. A
function that runs on a thread uses basic features of the programming
language to store this temporary state in local variables, on its stack.
The function also has a &quot;continuation&quot;—that is, the code it plans to
execute after I/O completes. The runtime remembers the continuation by
storing the thread's instruction pointer. You need not think about
restoring these local variables and the continuation after I/O. It is
built in to the language.</p>
<p>But with a callback-based async framework, these language features are
no help. While waiting for I/O, a function must save its state
explicitly, because the function returns and loses its stack frame
before I/O completes. In lieu of local variables, our callback-based
example stores <code class="docutils literal"><span class="pre">sock</span></code> and <code class="docutils literal"><span class="pre">response</span></code> as attributes of <code class="docutils literal"><span class="pre">self</span></code>, the
Fetcher instance. In lieu of the instruction pointer, it stores its
continuation by registering the callbacks <code class="docutils literal"><span class="pre">connected</span></code> and
<code class="docutils literal"><span class="pre">read_response</span></code>. As the application's features grow, so does the
complexity of the state we manually save across callbacks. Such onerous
bookkeeping makes the coder prone to migraines.</p>
<p>Even worse, what happens if a callback throws an exception, before it
schedules the next callback in the chain? Say we did a poor job on the
<code class="docutils literal"><span class="pre">parse_links</span></code> method and it throws an exception parsing some HTML:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;loop-with-callbacks.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">111</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">loop</span><span class="p">()</span>
  <span class="n">File</span> <span class="s2">&quot;loop-with-callbacks.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">106</span><span class="p">,</span> <span class="ow">in</span> <span class="n">loop</span>
    <span class="n">callback</span><span class="p">(</span><span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">&quot;loop-with-callbacks.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">51</span><span class="p">,</span> <span class="ow">in</span> <span class="n">read_response</span>
    <span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_links</span><span class="p">()</span>
  <span class="n">File</span> <span class="s2">&quot;loop-with-callbacks.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">67</span><span class="p">,</span> <span class="ow">in</span> <span class="n">parse_links</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;parse error&#39;</span><span class="p">)</span>
<span class="ne">Exception</span><span class="p">:</span> <span class="n">parse</span> <span class="n">error</span>
</pre></div>
</div>
<p>The stack trace shows only that the event loop was running a callback.
We do not remember what led to the error. The chain is broken on both
ends: we forgot where we were going and whence we came. This loss of
context is called &quot;stack ripping&quot;, and in many cases it confounds the
investigator. Stack ripping also prevents us from installing an
exception handler for a chain of callbacks, the way a &quot;try / except&quot;
block wraps a function call and its tree of descendents.<a class="reference external" href="#fn6">:sup:`6`</a></p>
<p>So, even apart from the long debate about the relative efficiencies of
multithreading and async, there is this other debate regarding which is
more error-prone: threads are susceptible to data races if you make a
mistake synchronizing them, but callbacks are stubborn to debug due to
stack ripping.</p>
<p class="rubric" id="coroutines">Coroutines</p>
<p>We entice you with a promise. It is possible to write asynchronous code
that combines the efficiency of callbacks with the classic good looks of
multithreaded programming. This combination is achieved with a pattern
called &quot;coroutines&quot;. Using Python 3.4's standard asyncio library, and a
package called &quot;aiohttp&quot;, fetching a URL in a coroutine is very
direct<a class="reference external" href="#fn7">:sup:`7`</a>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">body</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>It is also scalable. Compared to the 50k of memory per thread and the
operating system's hard limits on threads, a Python coroutine takes
barely 3k of memory on Jesse's system. Python can easily start hundreds
of thousands of coroutines.</p>
<p>The concept of a coroutine, dating to the elder days of computer
science, is simple: it is a subroutine that can be paused and resumed.
Whereas threads are preemptively multitasked by the operating system,
coroutines multitask cooperatively: they choose when to pause, and which
coroutine to run next.</p>
<p>There are many implementations of coroutines; even in Python there are
several. The coroutines in the standard &quot;asyncio&quot; library in Python 3.4
are built upon generators, a Future class, and the &quot;yield from&quot;
statement. Starting in Python 3.5, coroutines are a native feature of
the language itself<a class="reference external" href="#fn8">:sup:`8`</a>; however, understanding coroutines as
they were first implemented in Python 3.4, using pre-existing language
facilities, is the foundation to tackle Python 3.5's native coroutines.</p>
<p>To explain Python 3.4's generator-based coroutines, we will engage in an
exposition of generators and how they are used as coroutines in asyncio,
and trust you will enjoy reading it as much as we enjoyed writing it.
Once we have explained generator-based coroutines, we shall use them in
our async web crawler.</p>
<p class="rubric" id="how-python-generators-work">How Python Generators Work</p>
<p>Before you grasp Python generators, you have to understand how regular
Python functions work. Normally, when a Python function calls a
subroutine, the subroutine retains control until it returns, or throws
an exception. Then control returns to the caller:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">bar</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">pass</span>
</pre></div>
</div>
<p>The standard Python interpreter is written in C. The C function that
executes a Python function is called, mellifluously,
<code class="docutils literal"><span class="pre">PyEval_EvalFrameEx</span></code>. It takes a Python stack frame object and
evaluates Python bytecode in the context of the frame. Here is the
bytecode for <code class="docutils literal"><span class="pre">foo</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">  2           0 LOAD_GLOBAL              0 (bar)</span>
<span class="go">              3 CALL_FUNCTION            0 (0 positional, 0 keyword pair)</span>
<span class="go">              6 POP_TOP</span>
<span class="go">              7 LOAD_CONST               0 (None)</span>
<span class="go">             10 RETURN_VALUE</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">foo</span></code> function loads <code class="docutils literal"><span class="pre">bar</span></code> onto its stack and calls it, then
pops its return value from the stack, loads <code class="docutils literal"><span class="pre">None</span></code> onto the stack, and
returns <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>When <code class="docutils literal"><span class="pre">PyEval_EvalFrameEx</span></code> encounters the <code class="docutils literal"><span class="pre">CALL_FUNCTION</span></code> bytecode,
it creates a new Python stack frame and recurses: that is, it calls
<code class="docutils literal"><span class="pre">PyEval_EvalFrameEx</span></code> recursively with the new frame, which is used to
execute <code class="docutils literal"><span class="pre">bar</span></code>.</p>
<p>It is crucial to understand that Python stack frames are allocated in
heap memory! The Python interpreter is a normal C program, so its stack
frames are normal stack frames. But the <em>Python</em> stack frames it
manipulates are on the heap. Among other surprises, this means a Python
stack frame can outlive its function call. To see this interactively,
save the current frame from within <code class="docutils literal"><span class="pre">bar</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frame</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">bar</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">global</span> <span class="n">frame</span>
<span class="gp">... </span>    <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The frame was executing the code for &#39;bar&#39;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
<span class="go">&#39;bar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Its back pointer refers to the frame for &#39;foo&#39;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller_frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_back</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller_frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
<span class="go">&#39;foo&#39;</span>
</pre></div>
</div>
<div class="center figure"><p><img alt="Figure 5.1 - Function Calls" src="chapters/crawler-images/function-calls.png" /></p>
</div><p>Figure 5.1 - Function Calls</p>
<p>The stage is now set for Python generators, which use the same building
blocks—code objects and stack frames—to marvelous effect.</p>
<p>This is a generator function:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result of yield: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">result2</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">2</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result of 2nd yield: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result2</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s1">&#39;done&#39;</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>When Python compiles <code class="docutils literal"><span class="pre">gen_fn</span></code> to bytecode, it sees the <code class="docutils literal"><span class="pre">yield</span></code>
statement and knows that <code class="docutils literal"><span class="pre">gen_fn</span></code> is a generator function, not a
regular one. It sets a flag to remember this fact:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The generator flag is bit position 5.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator_bit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">gen_fn</span><span class="o">.</span><span class="n">__code__</span><span class="o">.</span><span class="n">co_flags</span> <span class="o">&amp;</span> <span class="n">generator_bit</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When you call a generator function, Python sees the generator flag, and
it does not actually run the function. Instead, it creates a generator:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">gen_fn</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">&lt;class &#39;generator&#39;&gt;</span>
</pre></div>
</div>
<p>A Python generator encapsulates a stack frame plus a reference to some
code, the body of <code class="docutils literal"><span class="pre">gen_fn</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">gi_code</span><span class="o">.</span><span class="n">co_name</span>
<span class="go">&#39;gen_fn&#39;</span>
</pre></div>
</div>
<p>All generators from calls to <code class="docutils literal"><span class="pre">gen_fn</span></code> point to this same code. But
each has its own stack frame. This stack frame is not on any actual
stack, it sits in heap memory waiting to be used:</p>
<div class="center figure"><p><img alt="Figure 5.2 - Generators" src="chapters/crawler-images/generator.png" /></p>
</div><p>Figure 5.2 - Generators</p>
<p>The frame has a &quot;last instruction&quot; pointer, the instruction it executed
most recently. In the beginning, the last instruction pointer is -1,
meaning the generator has not begun:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>When we call <code class="docutils literal"><span class="pre">send</span></code>, the generator reaches its first <code class="docutils literal"><span class="pre">yield</span></code>, and
pauses. The return value of <code class="docutils literal"><span class="pre">send</span></code> is 1, since that is what <code class="docutils literal"><span class="pre">gen</span></code>
passes to the <code class="docutils literal"><span class="pre">yield</span></code> expression:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The generator's instruction pointer is now 3 bytecodes from the start,
part way through the 56 bytes of compiled Python:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">gi_code</span><span class="o">.</span><span class="n">co_code</span><span class="p">)</span>
<span class="go">56</span>
</pre></div>
</div>
<p>The generator can be resumed at any time, from any function, because its
stack frame is not actually on the stack: it is on the heap. Its
position in the call hierarchy is not fixed, and it need not obey the
first-in, last-out order of execution that regular functions do. It is
liberated, floating free like a cloud.</p>
<p>We can send the value &quot;hello&quot; into the generator and it becomes the
result of the <code class="docutils literal"><span class="pre">yield</span></code> expression, and the generator continues until it
yields 2:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">result of yield: hello</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Its stack frame now contains the local variable <code class="docutils literal"><span class="pre">result</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_locals</span>
<span class="go">{&#39;result&#39;: &#39;hello&#39;}</span>
</pre></div>
</div>
<p>Other generators created from <code class="docutils literal"><span class="pre">gen_fn</span></code> will have their own stack
frames and local variables.</p>
<p>When we call <code class="docutils literal"><span class="pre">send</span></code> again, the generator continues from its second
<code class="docutils literal"><span class="pre">yield</span></code>, and finishes by raising the special <code class="docutils literal"><span class="pre">StopIteration</span></code>
exception:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;goodbye&#39;</span><span class="p">)</span>
<span class="go">result of 2nd yield: goodbye</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;input&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>: <span class="n">done</span>
</pre></div>
</div>
<p>The exception has a value, which is the return value of the generator:
the string <code class="docutils literal"><span class="pre">&quot;done&quot;</span></code>.</p>
<p class="rubric" id="building-coroutines-with-generators">Building Coroutines With Generators</p>
<p>So a generator can pause, and it can be resumed with a value, and it has
a return value. Sounds like a good primitive upon which to build an
async programming model, without spaghetti callbacks! We want to build a
&quot;coroutine&quot;: a routine that is cooperatively scheduled with other
routines in the program. Our coroutines will be a simplified version of
those in Python's standard &quot;asyncio&quot; library. As in asyncio, we will use
generators, futures, and the &quot;yield from&quot; statement.</p>
<p>First we need a way to represent some future result that a coroutine is
waiting for. A stripped-down version:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Future</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>A future is initially &quot;pending&quot;. It is &quot;resolved&quot; by a call to
<code class="docutils literal"><span class="pre">set_result</span></code>.<a class="reference external" href="#fn9">:sup:`9`</a></p>
<p>Let us adapt our fetcher to use futures and coroutines. We wrote
<code class="docutils literal"><span class="pre">fetch</span></code> with a callback:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Fetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;xkcd.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                          <span class="n">EVENT_WRITE</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;connected!&#39;</span><span class="p">)</span>
        <span class="c1"># And so on....</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">fetch</span></code> method begins connecting a socket, then registers the
callback, <code class="docutils literal"><span class="pre">connected</span></code>, to be executed when the socket is ready. Now we
can combine these two steps into one coroutine:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;xkcd.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_connected</span><span class="p">():</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                      <span class="n">EVENT_WRITE</span><span class="p">,</span>
                      <span class="n">on_connected</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">f</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;connected!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now <code class="docutils literal"><span class="pre">fetch</span></code> is a generator function, rather than a regular one,
because it contains a <code class="docutils literal"><span class="pre">yield</span></code> statement. We create a pending future,
then yield it to pause <code class="docutils literal"><span class="pre">fetch</span></code> until the socket is ready. The inner
function <code class="docutils literal"><span class="pre">on_connected</span></code> resolves the future.</p>
<p>But when the future resolves, what resumes the generator? We need a
coroutine <em>driver</em>. Let us call it &quot;task&quot;:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Task</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coro</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">next_future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

<span class="c1"># Begin fetching http://xkcd.com/353/</span>
<span class="n">fetcher</span> <span class="o">=</span> <span class="n">Fetcher</span><span class="p">(</span><span class="s1">&#39;/353/&#39;</span><span class="p">)</span>
<span class="n">Task</span><span class="p">(</span><span class="n">fetcher</span><span class="o">.</span><span class="n">fetch</span><span class="p">())</span>

<span class="n">loop</span><span class="p">()</span>
</pre></div>
</div>
<p>The task starts the <code class="docutils literal"><span class="pre">fetch</span></code> generator by sending <code class="docutils literal"><span class="pre">None</span></code> into it.
Then <code class="docutils literal"><span class="pre">fetch</span></code> runs until it yields a future, which the task captures as
<code class="docutils literal"><span class="pre">next_future</span></code>. When the socket is connected, the event loop runs the
callback <code class="docutils literal"><span class="pre">on_connected</span></code>, which resolves the future, which calls
<code class="docutils literal"><span class="pre">step</span></code>, which resumes <code class="docutils literal"><span class="pre">fetch</span></code>.</p>
<p class="rubric" id="factoring-coroutines-with-yield-from">Factoring Coroutines With <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code></p>
<p>Once the socket is connected, we send the HTTP GET request and read the
server response. These steps need no longer be scattered among
callbacks; we gather them into the same generator function:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># ... connection logic from above, then:</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">on_readable</span><span class="p">():</span>
            <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">))</span>

        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                          <span class="n">EVENT_READ</span><span class="p">,</span>
                          <span class="n">on_readable</span><span class="p">)</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">f</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">chunk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Done reading.</span>
            <span class="k">break</span>
</pre></div>
</div>
<p>This code, which reads a whole message from a socket, seems generally
useful. How can we factor it from <code class="docutils literal"><span class="pre">fetch</span></code> into a subroutine? Now
Python 3's celebrated <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> takes the stage. It lets one
generator <em>delegate</em> to another.</p>
<p>To see how, let us return to our simple generator example:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result of yield: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">result2</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">2</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result of 2nd yield: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result2</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s1">&#39;done&#39;</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>To call this generator from another generator, delegate to it with
<code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generator function:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">caller_fn</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">gen</span> <span class="o">=</span> <span class="n">gen_fn</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">rv</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">gen</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;return value of yield-from: </span><span class="si">{}</span><span class="s1">&#39;</span>
<span class="gp">... </span>          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rv</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Make a generator from the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># generator function.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller</span> <span class="o">=</span> <span class="n">caller_fn</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">caller</span></code> generator acts as if it were <code class="docutils literal"><span class="pre">gen</span></code>, the generator it is
delegating to:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">result of yield: hello</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>  <span class="c1"># Hasn&#39;t advanced.</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;goodbye&#39;</span><span class="p">)</span>
<span class="go">result of 2nd yield: goodbye</span>
<span class="go">return value of yield-from: done</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;input&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>While <code class="docutils literal"><span class="pre">caller</span></code> yields from <code class="docutils literal"><span class="pre">gen</span></code>, <code class="docutils literal"><span class="pre">caller</span></code> does not advance.
Notice that its instruction pointer remains at 15, the site of its
<code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> statement, even while the inner generator <code class="docutils literal"><span class="pre">gen</span></code>
advances from one <code class="docutils literal"><span class="pre">yield</span></code> statement to the next.<a class="reference external" href="#fn10">:sup:`10`</a> From
our perspective outside <code class="docutils literal"><span class="pre">caller</span></code>, we cannot tell if the values it
yields are from <code class="docutils literal"><span class="pre">caller</span></code> or from the generator it delegates to. And
from inside <code class="docutils literal"><span class="pre">gen</span></code>, we cannot tell if values are sent in from
<code class="docutils literal"><span class="pre">caller</span></code> or from outside it. The <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> statement is a
frictionless channel, through which values flow in and out of <code class="docutils literal"><span class="pre">gen</span></code>
until <code class="docutils literal"><span class="pre">gen</span></code> completes.</p>
<p>A coroutine can delegate work to a sub-coroutine with <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> and
receive the result of the work. Notice, above, that <code class="docutils literal"><span class="pre">caller</span></code> printed
&quot;return value of yield-from: done&quot;. When <code class="docutils literal"><span class="pre">gen</span></code> completed, its return
value became the value of the <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> statement in <code class="docutils literal"><span class="pre">caller</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">rv</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">gen</span>
</pre></div>
</div>
<p>Earlier, when we criticized callback-based async programming, our most
strident complaint was about &quot;stack ripping&quot;: when a callback throws an
exception, the stack trace is typically useless. It only shows that the
event loop was running the callback, not <em>why</em>. How do coroutines fare?</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;my error&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller</span> <span class="o">=</span> <span class="n">caller_fn</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;input&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;input&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">caller_fn</span>
  File <span class="nb">&quot;&lt;input&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">gen_fn</span>
<span class="gr">Exception</span>: <span class="n">my error</span>
</pre></div>
</div>
<p>This is much more useful! The stack trace shows <code class="docutils literal"><span class="pre">caller_fn</span></code> was
delegating to <code class="docutils literal"><span class="pre">gen_fn</span></code> when it threw the error. Even more comforting,
we can wrap the call to a sub-coroutine in an exception handler, the
same is with normal subroutines:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">yield</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;uh oh&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">caller_fn</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">yield from</span> <span class="n">gen_fn</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;caught </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller</span> <span class="o">=</span> <span class="n">caller_fn</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">caught uh oh</span>
</pre></div>
</div>
<p>So we factor logic with sub-coroutines just like with regular
subroutines. Let us factor some useful sub-coroutines from our fetcher.
We write a <code class="docutils literal"><span class="pre">read</span></code> coroutine to receive one chunk:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">sock</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_readable</span><span class="p">():</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">))</span>

    <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_READ</span><span class="p">,</span> <span class="n">on_readable</span><span class="p">)</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">f</span>  <span class="c1"># Read one chunk.</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">chunk</span>
</pre></div>
</div>
<p>We build on <code class="docutils literal"><span class="pre">read</span></code> with a <code class="docutils literal"><span class="pre">read_all</span></code> coroutine that receives a whole
message:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">read_all</span><span class="p">(</span><span class="n">sock</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Read whole response.</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">response</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</pre></div>
</div>
<p>If you squint the right way, the <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> statements disappear and
these look like conventional functions doing blocking I/O. But in fact,
<code class="docutils literal"><span class="pre">read</span></code> and <code class="docutils literal"><span class="pre">read_all</span></code> are coroutines. Yielding from <code class="docutils literal"><span class="pre">read</span></code> pauses
<code class="docutils literal"><span class="pre">read_all</span></code> until the I/O completes. While <code class="docutils literal"><span class="pre">read_all</span></code> is paused,
asyncio's event loop does other work and awaits other I/O events;
<code class="docutils literal"><span class="pre">read_all</span></code> is resumed with the result of <code class="docutils literal"><span class="pre">read</span></code> on the next loop
tick once its event is ready.</p>
<p>At the stack's root, <code class="docutils literal"><span class="pre">fetch</span></code> calls <code class="docutils literal"><span class="pre">read_all</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Fetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="c1"># ... connection logic from above, then:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">read_all</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
</pre></div>
</div>
<p>Miraculously, the Task class needs no modification. It drives the outer
<code class="docutils literal"><span class="pre">fetch</span></code> coroutine just the same as before:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">Task</span><span class="p">(</span><span class="n">fetcher</span><span class="o">.</span><span class="n">fetch</span><span class="p">())</span>
<span class="n">loop</span><span class="p">()</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">read</span></code> yields a future, the task receives it through the channel
of <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> statements, precisely as if the future were yielded
directly from <code class="docutils literal"><span class="pre">fetch</span></code>. When the loop resolves a future, the task sends
its result into <code class="docutils literal"><span class="pre">fetch</span></code>, and the value is received by <code class="docutils literal"><span class="pre">read</span></code>,
exactly as if the task were driving <code class="docutils literal"><span class="pre">read</span></code> directly:</p>
<div class="center figure"><p><img alt="Figure 5.3 - Yield From" src="chapters/crawler-images/yield-from.png" /></p>
</div><p>Figure 5.3 - Yield From</p>
<p>To perfect our coroutine implementation, we polish out one mar: our code
uses <code class="docutils literal"><span class="pre">yield</span></code> when it waits for a future, but <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> when it
delegates to a sub-coroutine. It would be more refined if we used
<code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> whenever a coroutine pauses. Then a coroutine need not
concern itself with what type of thing it awaits.</p>
<p>We take advantage of the deep correspondence in Python between
generators and iterators. Advancing a generator is, to the caller, the
same as advancing an iterator. So we make our Future class iterable by
implementing a special method:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Method on Future class.</span>
<span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Tell Task to resume me here.</span>
    <span class="k">yield</span> <span class="bp">self</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span>
</pre></div>
</div>
<p>The future's <code class="docutils literal"><span class="pre">__iter__</span></code> method is a coroutine that yields the future
itself. Now when we replace code like this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># f is a Future.</span>
<span class="k">yield</span> <span class="n">f</span>
</pre></div>
</div>
<p>...with this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># f is a Future.</span>
<span class="k">yield from</span> <span class="n">f</span>
</pre></div>
</div>
<p>...the outcome is the same! The driving Task receives the future from
its call to <code class="docutils literal"><span class="pre">send</span></code>, and when the future is resolved it sends the new
result back into the coroutine.</p>
<p>What is the advantage of using <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> everywhere? Why is that
better than waiting for futures with <code class="docutils literal"><span class="pre">yield</span></code> and delegating to
sub-coroutines with <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code>? It is better because now, a method
can freely change its implementation without affecting the caller: it
might be a normal method that returns a future that will <em>resolve</em> to a
value, or it might be a coroutine that contains <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code>
statements and <em>returns</em> a value. In either case, the caller need only
<code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> the method in order to wait for the result.</p>
<p>Gentle reader, we have reached the end of our enjoyable exposition of
coroutines in asyncio. We peered into the machinery of generators, and
sketched an implementation of futures and tasks. We outlined how asyncio
attains the best of both worlds: concurrent I/O that is more efficient
than threads and more legible than callbacks. Of course, the real
asyncio is much more sophisticated than our sketch. The real framework
addresses zero-copy I/O, fair scheduling, exception handling, and an
abundance of other features.</p>
<p>To an asyncio user, coding with coroutines is much simpler than you saw
here. In the code above we implemented coroutines from first principles,
so you saw callbacks, tasks, and futures. You even saw non-blocking
sockets and the call to <code class="docutils literal"><span class="pre">select</span></code>. But when it comes time to build an
application with asyncio, none of this appears in your code. As we
promised, you can now sleekly fetch a URL:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">body</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>Satisfied with this exposition, we return to our original assignment: to
write an async web crawler, using asyncio.</p>
<p class="rubric" id="coordinating-coroutines">Coordinating Coroutines</p>
<p>We began by describing how we want our crawler to work. Now it is time
to implement it with asyncio coroutines.</p>
<p>Our crawler will fetch the first page, parse its links, and add them to
a queue. After this it fans out across the website, fetching pages
concurrently. But to limit load on the client and server, we want some
maximum number of workers to run, and no more. Whenever a worker
finishes fetching a page, it should immediately pull the next link from
the queue. We will pass through periods when there is not enough work to
go around, so some workers must pause. But when a worker hits a page
rich with new links, then the queue suddenly grows and any paused
workers should wake and get cracking. Finally, our program must quit
once its work is done.</p>
<p>Imagine if the workers were threads. How would we express the crawler's
algorithm? We could use a synchronized queue<a class="reference external" href="#fn11">:sup:`11`</a> from the
Python standard library. Each time an item is put in the queue, the
queue increments its count of &quot;tasks&quot;. Worker threads call <code class="docutils literal"><span class="pre">task_done</span></code>
after completing work on an item. The main thread blocks on
<code class="docutils literal"><span class="pre">Queue.join</span></code> until each item put in the queue is matched by a
<code class="docutils literal"><span class="pre">task_done</span></code> call, then it exits.</p>
<p>Coroutines use the exact same pattern with an asyncio queue! First we
import it<a class="reference external" href="#fn12">:sup:`12`</a>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">asyncio</span> <span class="k">import</span> <span class="n">JoinableQueue</span> <span class="k">as</span> <span class="n">Queue</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># In Python 3.5, asyncio.JoinableQueue is</span>
    <span class="c1"># merged into Queue.</span>
    <span class="kn">from</span> <span class="nn">asyncio</span> <span class="k">import</span> <span class="n">Queue</span>
</pre></div>
</div>
<p>We collect the workers' shared state in a crawler class, and write the
main logic in its <code class="docutils literal"><span class="pre">crawl</span></code> method. We start <code class="docutils literal"><span class="pre">crawl</span></code> on a coroutine
and run asyncio's event loop until <code class="docutils literal"><span class="pre">crawl</span></code> finishes:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="n">crawler</span> <span class="o">=</span> <span class="n">crawling</span><span class="o">.</span><span class="n">Crawler</span><span class="p">(</span><span class="s1">&#39;http://xkcd.com&#39;</span><span class="p">,</span>
                           <span class="n">max_redirect</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">crawler</span><span class="o">.</span><span class="n">crawl</span><span class="p">())</span>
</pre></div>
</div>
<p>The crawler begins with a root URL and <code class="docutils literal"><span class="pre">max_redirect</span></code>, the number of
redirects it is willing to follow to fetch any one URL. It puts the pair
<code class="docutils literal"><span class="pre">(URL,</span> <span class="pre">max_redirect)</span></code> in the queue. (For the reason why, stay tuned.)</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Crawler</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_url</span><span class="p">,</span> <span class="n">max_redirect</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_tasks</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_redirect</span> <span class="o">=</span> <span class="n">max_redirect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seen_urls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># aiohttp&#39;s ClientSession does connection pooling and</span>
        <span class="c1"># HTTP keep-alives for us.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">(</span><span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span>

        <span class="c1"># Put (URL, max_redirect) in the queue.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">root_url</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_redirect</span><span class="p">))</span>
</pre></div>
</div>
<p>The number of unfinished tasks in the queue is now one. Back in our main
script, we launch the event loop and the <code class="docutils literal"><span class="pre">crawl</span></code> method:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">crawler</span><span class="o">.</span><span class="n">crawl</span><span class="p">())</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">crawl</span></code> coroutine kicks off the workers. It is like a main thread:
it blocks on <code class="docutils literal"><span class="pre">join</span></code> until all tasks are finished, while the workers
run in the background.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">crawl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Run the crawler until all work is done.&quot;&quot;&quot;</span>
    <span class="n">workers</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>
               <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_tasks</span><span class="p">)]</span>

    <span class="c1"># When all work is done, exit.</span>
    <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">:</span>
        <span class="n">w</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</pre></div>
</div>
<p>If the workers were threads we might not wish to start them all at once.
To avoid creating expensive threads until it is certain they are
necessary, a thread pool typically grows on demand. But coroutines are
cheap, so we simply start the maximum number allowed.</p>
<p>It is interesting to note how we shut down the crawler. When the
<code class="docutils literal"><span class="pre">join</span></code> future resolves, the worker tasks are alive but suspended: they
wait for more URLs but none come. So, the main coroutine cancels them
before exiting. Otherwise, as the Python interpreter shuts down and
calls all objects' destructors, living tasks cry out:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>ERROR:asyncio:Task was destroyed but it is pending!
</pre></div>
</div>
<p>And how does <code class="docutils literal"><span class="pre">cancel</span></code> work? Generators have a feature we have not yet
shown you. You can throw an exception into a generator from outside:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">gen_fn</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># Start the generator as usual.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;input&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;input&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">gen_fn</span>
<span class="gr">Exception</span>: <span class="n">error</span>
</pre></div>
</div>
<p>The generator is resumed by <code class="docutils literal"><span class="pre">throw</span></code>, but it is now raising an
exception. If no code in the generator's call stack catches it, the
exception bubbles back up to the top. So to cancel a task's coroutine:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Method of Task class.</span>
<span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="n">CancelledError</span><span class="p">)</span>
</pre></div>
</div>
<p>Wherever the generator is paused, at some <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> statement, it
resumes and throws an exception. We handle cancellation in the task's
<code class="docutils literal"><span class="pre">step</span></code> method:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Method of Task class.</span>
<span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">CancelledError</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cancelled</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">next_future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
</pre></div>
</div>
<p>Now the task knows it is cancelled, so when it is destroyed it does not
rage against the dying of the light.</p>
<p>Once <code class="docutils literal"><span class="pre">crawl</span></code> has canceled the workers, it exits. The event loop sees
that the coroutine is complete (we shall see how later), and it too
exits:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">crawler</span><span class="o">.</span><span class="n">crawl</span><span class="p">())</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">crawl</span></code> method comprises all that our main coroutine must do. It
is the worker coroutines that get URLs from the queue, fetch them, and
parse them for new links. Each worker runs the <code class="docutils literal"><span class="pre">work</span></code> coroutine
independently:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">url</span><span class="p">,</span> <span class="n">max_redirect</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="c1"># Download page and add new links to self.q.</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">max_redirect</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
</pre></div>
</div>
<p>Python sees that this code contains <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> statements, and
compiles it into a generator function. So in <code class="docutils literal"><span class="pre">crawl</span></code>, when the main
coroutine calls <code class="docutils literal"><span class="pre">self.work</span></code> ten times, it does not actually execute
this method: it only creates ten generator objects with references to
this code. It wraps each in a Task. The Task receives each future the
generator yields, and drives the generator by calling <code class="docutils literal"><span class="pre">send</span></code> with each
future's result when the future resolves. Because the generators have
their own stack frames, they run independently, with separate local
variables and instruction pointers.</p>
<p>The worker coordinates with its fellows via the queue. It waits for new
URLs with:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">url</span><span class="p">,</span> <span class="n">max_redirect</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>The queue's <code class="docutils literal"><span class="pre">get</span></code> method is itself a coroutine: it pauses until
someone puts an item in the queue, then resumes and returns the item.</p>
<p>Incidentally, this is where the worker will be paused at the end of the
crawl, when the main coroutine cancels it. From the coroutine's
perspective, its last trip around the loop ends when <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code>
raises a <code class="docutils literal"><span class="pre">CancelledError</span></code>.</p>
<p>When a worker fetches a page it parses the links and puts new ones in
the queue, then calls <code class="docutils literal"><span class="pre">task_done</span></code> to decrement the counter.
Eventually, a worker fetches a page whose URLs have all been fetched
already, and there is also no work left in the queue. Thus this worker's
call to <code class="docutils literal"><span class="pre">task_done</span></code> decrements the counter to zero. Then <code class="docutils literal"><span class="pre">crawl</span></code>,
which is waiting for the queue's <code class="docutils literal"><span class="pre">join</span></code> method, is unpaused and
finishes.</p>
<p>We promised to explain why the items in the queue are pairs, like:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># URL to fetch, and the number of redirects left.</span>
<span class="p">(</span><span class="s1">&#39;http://xkcd.com/353&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>New URLs have ten redirects remaining. Fetching this particular URL
results in a redirect to a new location with a trailing slash. We
decrement the number of redirects remaining, and put the next location
in the queue:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># URL with a trailing slash. Nine redirects left.</span>
<span class="p">(</span><span class="s1">&#39;http://xkcd.com/353/&#39;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">aiohttp</span></code> package we use would follow redirects by default and
give us the final response. We tell it not to, however, and handle
redirects in the crawler, so it can coalesce redirect paths that lead to
the same destination: if we have already seen this URL, it is in
<code class="docutils literal"><span class="pre">self.seen_urls</span></code> and we have already started on this path from a
different entry point:</p>
<div class="center figure"><p><img alt="Figure 5.4 - Redirects" src="chapters/crawler-images/redirects.png" /></p>
</div><p>Figure 5.4 - Redirects</p>
<p>The crawler fetches &quot;foo&quot; and sees it redirects to &quot;baz&quot;, so it adds
&quot;baz&quot; to the queue and to <code class="docutils literal"><span class="pre">seen_urls</span></code>. If the next page it fetches is
&quot;bar&quot;, which also redirects to &quot;baz&quot;, the fetcher does not enqueue &quot;baz&quot;
again. If the response is a page, rather than a redirect, <code class="docutils literal"><span class="pre">fetch</span></code>
parses it for links and puts new ones in the queue.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">max_redirect</span><span class="p">):</span>
    <span class="c1"># Handle redirects ourselves.</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="n">url</span><span class="p">,</span> <span class="n">allow_redirects</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_redirect</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">max_redirect</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">next_url</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">next_url</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen_urls</span><span class="p">:</span>
                    <span class="c1"># We have been down this path before.</span>
                    <span class="k">return</span>

                <span class="c1"># Remember we have seen this URL.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seen_urls</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">next_url</span><span class="p">)</span>

                <span class="c1"># Follow the redirect. One less redirect remains.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="n">next_url</span><span class="p">,</span> <span class="n">max_redirect</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
         <span class="k">else</span><span class="p">:</span>
             <span class="n">links</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_links</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
             <span class="c1"># Python set-logic:</span>
             <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seen_urls</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="n">link</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_redirect</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seen_urls</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># Return connection to pool.</span>
        <span class="k">yield from</span> <span class="n">response</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<p>If this were multithreaded code, it would be lousy with race conditions.
For example, the worker checks if a link is in <code class="docutils literal"><span class="pre">seen_urls</span></code>, and if not
the worker puts it in the queue and adds it to <code class="docutils literal"><span class="pre">seen_urls</span></code>. If it were
interrupted between the two operations, then another worker might parse
the same link from a different page, also observe that it is not in
<code class="docutils literal"><span class="pre">seen_urls</span></code>, and also add it to the queue. Now that same link is in
the queue twice, leading (at best) to duplicated work and wrong
statistics.</p>
<p>However, a coroutine is only vulnerable to interruption at
<code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> statements. This is a key difference that makes coroutine
code far less prone to races than multithreaded code: multithreaded code
must enter a critical section explicitly, by grabbing a lock, otherwise
it is interruptible. A Python coroutine is uninterruptible by default,
and only cedes control when it explicitly yields.</p>
<p>We no longer need a fetcher class like we had in the callback-based
program. That class was a workaround for a deficiency of callbacks: they
need some place to store state while waiting for I/O, since their local
variables are not preserved across calls. But the <code class="docutils literal"><span class="pre">fetch</span></code> coroutine
can store its state in local variables like a regular function does, so
there is no more need for a class.</p>
<p>When <code class="docutils literal"><span class="pre">fetch</span></code> finishes processing the server response it returns to the
caller, <code class="docutils literal"><span class="pre">work</span></code>. The <code class="docutils literal"><span class="pre">work</span></code> method calls <code class="docutils literal"><span class="pre">task_done</span></code> on the queue
and then gets the next URL from the queue to be fetched.</p>
<p>When <code class="docutils literal"><span class="pre">fetch</span></code> puts new links in the queue it increments the count of
unfinished tasks and keeps the main coroutine, which is waiting for
<code class="docutils literal"><span class="pre">q.join</span></code>, paused. If, however, there are no unseen links and this was
the last URL in the queue, then when <code class="docutils literal"><span class="pre">work</span></code> calls <code class="docutils literal"><span class="pre">task_done</span></code> the
count of unfinished tasks falls to zero. That event unpauses <code class="docutils literal"><span class="pre">join</span></code>
and the main coroutine completes.</p>
<p>The queue code that coordinates the workers and the main coroutine is
like this<a class="reference external" href="#fn13">:sup:`13`</a>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_join_future</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unfinished_tasks</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># ... other initialization ...</span>

    <span class="k">def</span> <span class="nf">put_nowait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unfinished_tasks</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># ... store the item ...</span>

    <span class="k">def</span> <span class="nf">task_done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unfinished_tasks</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unfinished_tasks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_join_future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unfinished_tasks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_future</span>
</pre></div>
</div>
<p>The main coroutine, <code class="docutils literal"><span class="pre">crawl</span></code>, yields from <code class="docutils literal"><span class="pre">join</span></code>. So when the last
worker decrements the count of unfinished tasks to zero, it signals
<code class="docutils literal"><span class="pre">crawl</span></code> to resume, and finish.</p>
<p>The ride is almost over. Our program began with the call to <code class="docutils literal"><span class="pre">crawl</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crawler</span><span class="o">.</span><span class="n">crawl</span><span class="p">())</span>
</pre></div>
</div>
<p>How does the program end? Since <code class="docutils literal"><span class="pre">crawl</span></code> is a generator function,
calling it returns a generator. To drive the generator, asyncio wraps it
in a task:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EventLoop</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">run_until_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run until the coroutine is done.&quot;&quot;&quot;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">stop_callback</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">StopError</span><span class="p">:</span>
            <span class="k">pass</span>

<span class="k">class</span> <span class="nc">StopError</span><span class="p">(</span><span class="ne">BaseException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised to stop the event loop.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">stop_callback</span><span class="p">(</span><span class="n">future</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">StopError</span>
</pre></div>
</div>
<p>When the task completes, it raises <code class="docutils literal"><span class="pre">StopError</span></code>, which the loop uses as
a signal that it has arrived at normal completion.</p>
<p>But what's this? The task has methods called <code class="docutils literal"><span class="pre">add_done_callback</span></code> and
<code class="docutils literal"><span class="pre">result</span></code>? You might think that a task resembles a future. Your
instinct is correct. We must admit a detail about the Task class we hid
from you: a task is a future.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Task</span><span class="p">(</span><span class="n">Future</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A coroutine wrapped in a Future.&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Normally a future is resolved by someone else calling <code class="docutils literal"><span class="pre">set_result</span></code> on
it. But a task resolves <em>itself</em> when its coroutine stops. Remember from
our earlier exploration of Python generators that when a generator
returns, it throws the special <code class="docutils literal"><span class="pre">StopIteration</span></code> exception:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Method of class Task.</span>
<span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">CancelledError</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cancelled</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span>
    <span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>

        <span class="c1"># Task resolves itself with coro&#39;s return</span>
        <span class="c1"># value.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">next_future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
</pre></div>
</div>
<p>So when the event loop calls <code class="docutils literal"><span class="pre">task.add_done_callback(stop_callback)</span></code>,
it prepares to be stopped by the task. Here is <code class="docutils literal"><span class="pre">run_until_complete</span></code>
again:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Method of event loop.</span>
<span class="k">def</span> <span class="nf">run_until_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
    <span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">stop_callback</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">StopError</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>When the task catches <code class="docutils literal"><span class="pre">StopIteration</span></code> and resolves itself, the
callback raises <code class="docutils literal"><span class="pre">StopError</span></code> from within the loop. The loop stops and
the call stack is unwound to <code class="docutils literal"><span class="pre">run_until_complete</span></code>. Our program is
finished.</p>
<p class="rubric" id="conclusion">Conclusion</p>
<p>Increasingly often, modern programs are I/O-bound instead of CPU-bound.
For such programs, Python threads are the worst of both worlds: the
global interpreter lock prevents them from actually executing
computations in parallel, and preemptive switching makes them prone to
races. Async is often the right pattern. But as callback-based async
code grows, it tends to become a dishevelled mess. Coroutines are a tidy
alternative. They factor naturally into subroutines, with sane exception
handling and stack traces.</p>
<p>If we squint so that the <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> statements blur, a coroutine
looks like a thread doing traditional blocking I/O. We can even
coordinate coroutines with classic patterns from multi-threaded
programming. There is no need for reinvention. Thus, compared to
callbacks, coroutines are an inviting idiom to the coder experienced
with multithreading.</p>
<p>But when we open our eyes and focus on the <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> statements, we
see they mark points when the coroutine cedes control and allows others
to run. Unlike threads, coroutines display where our code can be
interrupted and where it cannot. In his illuminating essay
&quot;Unyielding&quot;<a class="reference external" href="#fn14">:sup:`14`</a>, Glyph Lefkowitz writes, &quot;Threads make local
reasoning difficult, and local reasoning is perhaps the most important
thing in software development.&quot; Explicitly yielding, however, makes it
possible to &quot;understand the behavior (and thereby, the correctness) of a
routine by examining the routine itself rather than examining the entire
system.&quot;</p>
<p>This chapter was written during a renaissance in the history of Python
and async. Generator-based coroutines, whose devising you have just
learned, were released in the &quot;asyncio&quot; module with Python 3.4 in March
2014. In September 2015, Python 3.5 was released with coroutines built
in to the language itself. These native coroutinesare declared with the
new syntax &quot;async def&quot;, and instead of &quot;yield from&quot;, they use the new
&quot;await&quot; keyword to delegate to a coroutine or wait for a Future.</p>
<p>Despite these advances, the core ideas remain. Python's new native
coroutines will be syntactically distinct from generators but work very
similarly; indeed, they will share an implementation within the Python
interpreter. Task, Future, and the event loop will continue to play
their roles in asyncio.</p>
<p>Now that you know how asyncio coroutines work, you can largely forget
the details. The machinery is tucked behind a dapper interface. But your
grasp of the fundamentals empowers you to code correctly and efficiently
in modern async environments.</p>
<div class="footnotes"><hr class="docutils" />
<ol class="arabic">
<li><div class="first"><div id="fn1"></div></div><p>Guido introduced the standard asyncio library, called &quot;Tulip&quot; then,
at <a class="reference external" href="http://pyvideo.org/video/1667/keynote">PyCon 2013</a>.<a class="reference external" href="#fnref1">↩</a></p>
</li>
<li><div class="first"><div id="fn2"></div></div><p>Even calls to <code class="docutils literal"><span class="pre">send</span></code> can block, if the recipient is slow to
acknowledge outstanding messages and the system's buffer of outgoing
data is full.<a class="reference external" href="#fnref2">↩</a></p>
</li>
<li><div class="first"><div id="fn3"></div></div><p><a class="reference external" href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a><a class="reference external" href="#fnref3">↩</a></p>
</li>
<li><div class="first"><div id="fn4"></div></div><p>Python's global interpreter lock prohibits running Python code in
parallel in one process anyway. Parallelizing CPU-bound algorithms in
Python requires multiple processes, or writing the parallel portions
of the code in C. But that is a topic for another
day.<a class="reference external" href="#fnref4">↩</a></p>
</li>
<li><div class="first"><div id="fn5"></div></div><p>Jesse listed indications and contraindications for using async in
<a class="reference external" href="http://pyvideo.org/video/2565/what-is-async-how-does-it-work-and-when-should">&quot;What Is Async, How Does It Work, And When Should I Use It?&quot;:</a>.
Mike Bayer compared the throughput of asyncio and multithreading for
different workloads in <a class="reference external" href="http://techspot.zzzeek.org/2015/02/15/asynchronous-python-and-databases/">&quot;Asynchronous Python and
Databases&quot;:</a><a class="reference external" href="#fnref5">↩</a></p>
</li>
<li><div class="first"><div id="fn6"></div></div><p>For a complex solution to this problem, see
<a class="reference external" href="http://www.tornadoweb.org/en/stable/stack_context.html">http://www.tornadoweb.org/en/stable/stack_context.html</a><a class="reference external" href="#fnref6">↩</a></p>
</li>
<li><div class="first"><div id="fn7"></div></div><p>The <code class="docutils literal"><span class="pre">&#64;asyncio.coroutine</span></code> decorator is not magical. In fact, if it
decorates a generator function and the <code class="docutils literal"><span class="pre">PYTHONASYNCIODEBUG</span></code>
environment variable is not set, the decorator does practically
nothing. It just sets an attribute, <code class="docutils literal"><span class="pre">_is_coroutine</span></code>, for the
convenience of other parts of the framework. It is possible to use
asyncio with bare generators not decorated with
<code class="docutils literal"><span class="pre">&#64;asyncio.coroutine</span></code> at all.<a class="reference external" href="#fnref7">↩</a></p>
</li>
<li><div class="first"><div id="fn8"></div></div><p>Python 3.5's built-in coroutines are described in <a class="reference external" href="https://www.python.org/dev/peps/pep-0492/">PEP 492</a>,
&quot;Coroutines with async and await syntax.&quot;<a class="reference external" href="#fnref8">↩</a></p>
</li>
<li><div class="first"><div id="fn9"></div></div><p>This future has many deficiencies. For example, once this future is
resolved, a coroutine that yields it should resume immediately
instead of pausing, but with our code it does not. See asyncio's
Future class for a complete implementation.<a class="reference external" href="#fnref9">↩</a></p>
</li>
<li><div class="first"><div id="fn10"></div></div><p>In fact, this is exactly how &quot;yield from&quot; works in CPython. A
function increments its instruction pointer before executing each
statement. But after the outer generator executes &quot;yield from&quot;, it
subtracts 1 from its instruction pointer to keep itself pinned at the
&quot;yield from&quot; statement. Then it yields to <em>its</em> caller. The cycle
repeats until the inner generator throws <code class="docutils literal"><span class="pre">StopIteration</span></code>, at which
point the outer generator finally allows itself to advance to the
next instruction.<a class="reference external" href="#fnref10">↩</a></p>
</li>
<li><div class="first"><div id="fn11"></div></div><p><a class="reference external" href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a><a class="reference external" href="#fnref11">↩</a></p>
</li>
<li><div class="first"><div id="fn12"></div></div><p><a class="reference external" href="https://docs.python.org/3/library/asyncio-sync.html">https://docs.python.org/3/library/asyncio-sync.html</a><a class="reference external" href="#fnref12">↩</a></p>
</li>
<li><div class="first"><div id="fn13"></div></div><p>The actual <code class="docutils literal"><span class="pre">asyncio.Queue</span></code> implementation uses an <code class="docutils literal"><span class="pre">asyncio.Event</span></code>
in place of the Future shown here. The difference is an Event can be
reset, whereas a Future cannot transition from resolved back to
pending.<a class="reference external" href="#fnref13">↩</a></p>
</li>
<li><div class="first"><div id="fn14"></div></div><p><a class="reference external" href="https://glyph.twistedmatrix.com/2014/02/unyielding.html">https://glyph.twistedmatrix.com/2014/02/unyielding.html</a><a class="reference external" href="#fnref14">↩</a></p>
</li>
</ol>
</div></div></div></div></div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Learn-Computer-and-Math-again</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="blockcode-a-visual-programming-toolkit.html">500 Lines or Less | Blockcode: A visual programming toolkit</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, timger.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/chapters/a-web-crawler-with-asyncio-coroutines.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>