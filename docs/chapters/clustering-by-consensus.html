
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>500 Lines or Less | Clustering by Consensus &#8212; Learn-Computer-and-Math-again 0.0.1 文档</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lines-or-less-clustering-by-consensus">
<h1>500 Lines or Less | Clustering by Consensus<a class="headerlink" href="#lines-or-less-clustering-by-consensus" title="永久链接至标题">¶</a></h1>
<div class="container"><div class="row"><div class="hero-unit"><p><a href="#id1"><span class="problematic" id="id2">``</span></a>_
.. rubric:: Clustering by Consensus</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">clustering-by-consensus</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p class="author rubric" id="dustin-j-mitchell">Dustin J. Mitchell</p>
</div></div><div class="row"><div id="content" class="span10 offset1"><p><em>Dustin is an open source software developer and release engineer at
Mozilla. He has worked on projects as varied as a host configuration
system in Puppet, a Flask-based web framework, unit tests for firewall
configurations, and a continuous integration framework in Twisted
Python. Find him as `&#64;djmitche`_ on GitHub or at</em>
dustin at mozilla dot com
.
.. rubric:: Introduction</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">introduction</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>In this chapter, we'll explore implementation of a network protocol
designed to support reliable distributed computation. Network protocols
can be difficult to implement correctly, so we'll look at some
techniques for minimizing bugs and for catching and fixing the remaining
few. Building reliable software, too, requires some special development
and debugging techniques.</p>
<p class="rubric" id="motivating-example">Motivating Example</p>
<p>The focus of this chapter is on the protocol implementation, but as a
motivating example let's consider a simple bank account management
service. In this service, each account has a current balance and is
identified with an account number. Users access the accounts by
requesting operations like &quot;deposit&quot;, &quot;transfer&quot;, or &quot;get-balance&quot;. The
&quot;transfer&quot; operation operates on two accounts at once -- the source and
destination accounts -- and must be rejected if the source account's
balance is too low.</p>
<p>If the service is hosted on a single server, this is easy to implement:
use a lock to make sure that transfer operations don't run in parallel,
and verify the source account's balance in that method. However, a bank
cannot rely on a single server for its critical account balances.
Instead, the service is <em>distributed</em> over multiple servers, with each
running a separate instance of exactly the same code. Users can then
contact any server to perform an operation.</p>
<p>In a naive implementation of distributed processing, each server would
keep a local copy of every account's balance. It would handle any
operations it received, and send updates for account balances to other
servers. But this approach introduces a serious failure mode: if two
servers process operations for the same account at the same time, which
new account balance is correct? Even if the servers share operations
with one another instead of balances, two simultaneous transfers out of
an account might overdraw the account.</p>
<p>Fundamentally, these failures occur when servers use their local state
to perform operations, without first ensuring that the local state
matches the state on other servers. For example, imagine that server A
receives a transfer operation from Account 101 to Account 202, when
server B has already processed another transfer of Account 101's full
balance to Account 202, but not yet informed server A. The local state
on server A is different from that on server B, so server A incorrectly
allows the transfer to complete, even though the result is an overdraft
on Account 101.</p>
<p class="rubric" id="distributed-state-machines">Distributed State Machines</p>
<p>The technique for avoiding such problems is called a &quot;distributed state
machine&quot;. The idea is that each server executes exactly the same
deterministic state machine on exactly the same inputs. By the nature of
state machines, then, each server will see exactly the same outputs.
Operations such as &quot;transfer&quot; or &quot;get-balance&quot;, together with their
parameters (account numbers and amounts) represent the inputs to the
state machine.</p>
<p>The state machine for this application is simple:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">execute_operation</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">operation</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">operation</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;deposit&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">verify_signature</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">deposit_signature</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="kc">False</span>
        <span class="n">state</span><span class="o">.</span><span class="n">accounts</span><span class="p">[</span><span class="n">operation</span><span class="o">.</span><span class="n">destination_account</span><span class="p">]</span> <span class="o">+=</span> <span class="n">operation</span><span class="o">.</span><span class="n">amount</span>
        <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">operation</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;transfer&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">accounts</span><span class="p">[</span><span class="n">operation</span><span class="o">.</span><span class="n">source_account</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">operation</span><span class="o">.</span><span class="n">amount</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="kc">False</span>
        <span class="n">state</span><span class="o">.</span><span class="n">accounts</span><span class="p">[</span><span class="n">operation</span><span class="o">.</span><span class="n">source_account</span><span class="p">]</span> <span class="o">-=</span> <span class="n">operation</span><span class="o">.</span><span class="n">amount</span>
        <span class="n">state</span><span class="o">.</span><span class="n">accounts</span><span class="p">[</span><span class="n">operation</span><span class="o">.</span><span class="n">destination_account</span><span class="p">]</span> <span class="o">+=</span> <span class="n">operation</span><span class="o">.</span><span class="n">amount</span>
        <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">operation</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;get-balance&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">accounts</span><span class="p">[</span><span class="n">operation</span><span class="o">.</span><span class="n">account</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that executing the &quot;get-balance&quot; operation does not modify the
state, but is still implemented as a state transition. This guarantees
that the returned balance is the latest information in the cluster of
servers, and is not based on the (possibly stale) local state on a
single server.</p>
<p>This may look different than the typical state machine you'd learn about
in a computer science course. Rather than a finite set of named states
with labeled transitions, this machine's state is the collection of
account balances, so there are infinite possible states. Still, the
usual rules of deterministic state machines apply: starting with the
same state and processing the same operations will always produce the
same output.</p>
<p>So, the distributed state machine technique ensures that the same
operations occur on each host. But the problem remains of ensuring that
every server agrees on the inputs to the state machine. This is a
problem of <em>consensus</em>, and we'll address it with a derivative of the
Paxos algorithm.</p>
<p class="rubric" id="consensus-by-paxos">Consensus by Paxos</p>
<p>Paxos was described by Leslie Lamport in a fanciful paper, first
submitted in 1990 and eventually published in 1998, entitled &quot;The
Part-Time Parliament&quot;<a class="reference external" href="#fn1">:sup:`1`</a>. Lamport's paper has a great deal
more detail than we will get into here, and is a fun read. The
references at the end of the chapter describe some extensions of the
algorithm that we have adapted in this implementation.</p>
<p>The simplest form of Paxos provides a way for a set of servers to agree
on one value, for all time. Multi-Paxos builds on this foundation by
agreeing on a numbered sequence of facts, one at a time. To implement a
distributed state machine, we use Multi-Paxos to agree on each
state-machine input, and execute them in sequence.</p>
<p class="rubric" id="simple-paxos">Simple Paxos</p>
<p>So let's start with &quot;Simple Paxos&quot;, also known as the Synod protocol,
which provides a way to agree on a single value that can never change.
The name Paxos comes from the mythical island in &quot;The Part-Time
Parliament&quot;, where lawmakers vote on legislation through a process
Lamport dubbed the Synod protocol.</p>
<p>The algorithm is a building block for more complex algorithms, as we'll
see below. The single value we'll agree on in this example is the first
transaction processed by our hypothetical bank. While the bank will
process transactions every day, the first transaction will only occur
once and never change, so we can use Simple Paxos to agree on its
details.</p>
<p>The protocol operates in a series of ballots, each led by a single
member of the cluster, called the proposer. Each ballot has a unique
ballot number based on an integer and the proposer's identity. The
proposer's goal is to get a majority of cluster members, acting as
acceptors, to accept its value, but only if another value has not
already been decided.</p>
<div class="center figure"><p><img alt="Figure 3.1 - A Ballot" src="chapters/cluster-images/ballot.png" /></p>
</div><p>Figure 3.1 - A Ballot</p>
<p>A ballot begins with the proposer sending a <code class="docutils literal"><span class="pre">Prepare</span></code> message with the
ballot number <em>N</em> to the acceptors and waiting to hear from a majority
(<a class="reference external" href="#figure-3.1">Figure 3.1</a>.)</p>
<p>The <code class="docutils literal"><span class="pre">Prepare</span></code> message is a request for the accepted value (if any)
with the highest ballot number less than <em>N</em>. Acceptors respond with a
<code class="docutils literal"><span class="pre">Promise</span></code> containing any value they have already accepted, and
promising not to accept any ballot numbered less than <em>N</em> in the future.
If the acceptor has already made a promise for a larger ballot number,
it includes that number in the <code class="docutils literal"><span class="pre">Promise</span></code>, indicating that the proposer
has been pre-empted. In this case, the ballot is over, but the proposer
is free to try again in another ballot (and with a larger ballot
number).</p>
<p>When the proposer has heard back from a majority of the acceptors, it
sends an <code class="docutils literal"><span class="pre">Accept</span></code> message, including the ballot number and value, to
all acceptors. If the proposer did not receive any existing value from
any acceptor, then it sends its own desired value. Otherwise, it sends
the value from the highest-numbered promise.</p>
<p>Unless it would violate a promise, each acceptor records the value from
the <code class="docutils literal"><span class="pre">Accept</span></code> message as accepted and replies with an <code class="docutils literal"><span class="pre">Accepted</span></code>
message. The ballot is complete and the value decided when the proposer
has heard its ballot number from a majority of acceptors.</p>
<p>Returning to the example, initially no other value has been accepted, so
the acceptors all send back a <code class="docutils literal"><span class="pre">Promise</span></code> with no value, and the
proposer sends an <code class="docutils literal"><span class="pre">Accept</span></code> containing its value, say:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">operation</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;deposit&#39;</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mf">100.00</span><span class="p">,</span> <span class="n">destination_account</span><span class="o">=</span><span class="s1">&#39;Mike DiBernardo&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If another proposer later initiates a ballot with a lower ballot number
and a different operation (say, a transfer to acount
<code class="docutils literal"><span class="pre">'Dustin</span> <span class="pre">J.</span> <span class="pre">Mitchell'</span></code>), the acceptors will simply not accept it. If
that ballot has a larger ballot number, then the <code class="docutils literal"><span class="pre">Promise</span></code> from the
acceptors will inform the proposer about Michael's $100.00 deposit
operation, and the proposer will send that value in the <code class="docutils literal"><span class="pre">Accept</span></code>
message instead of the transfer to Dustin. The new ballot will be
accepted, but in favor of the same value as the first ballot.</p>
<p>In fact, the protocol will never allow two different values to be
decided, even if the ballots overlap, messages are delayed, or a
minority of acceptors fail.</p>
<p>When multiple proposers make a ballot at the same time, it is easy for
neither ballot to be accepted. Both proposers then re-propose, and
hopefully one wins, but the deadlock can continue indefinitely if the
timing works out just right.</p>
<p>Consider the following sequence of events:</p>
<ul class="simple">
<li>Proposer A performs the <code class="docutils literal"><span class="pre">Prepare</span></code>/<code class="docutils literal"><span class="pre">Promise</span></code> phase for ballot
number 1.</li>
<li>Before Proposer A manages to get its proposal accepted, Proposer B
performs a <code class="docutils literal"><span class="pre">Prepare</span></code>/<code class="docutils literal"><span class="pre">Promise</span></code> phase for ballot number 2.</li>
<li>When Proposer A finally sends its <code class="docutils literal"><span class="pre">Accept</span></code> with ballot number 1,
the acceptors reject it because they have already promised ballot
number 2.</li>
<li>Proposer A reacts by immediately sending a <code class="docutils literal"><span class="pre">Prepare</span></code> with a higher
ballot number (3), before Proposer B can send its <code class="docutils literal"><span class="pre">Accept</span></code> message.</li>
<li>Proposer B's subsequent <code class="docutils literal"><span class="pre">Accept</span></code> is rejected, and the process
repeats.</li>
</ul>
<p>With unlucky timing -- more common over long-distance connections where
the time between sending a message and getting a response is long --
this deadlock can continue for many rounds.</p>
<p class="rubric" id="multi-paxos">Multi-Paxos</p>
<p>Reaching consensus on a single static value is not particularly useful
on its own. Clustered systems such as the bank account service want to
agree on a particular state (account balances) that changes over time.
We use Paxos to agree on each operation, treated as a state machine
transition.</p>
<p>Multi-Paxos is, in effect, a sequence of simple Paxos instances (slots),
each numbered sequentially. Each state transition is given a &quot;slot
number&quot;, and each member of the cluster executes transitions in strict
numeric order. To change the cluster's state (to process a transfer
operation, for example), we try to achieve consensus on that operation
in the next slot. In concrete terms, this means adding a slot number to
each message, with all of the protocol state tracked on a per-slot
basis.</p>
<p>Running Paxos for every slot, with its minimum of two round trips, would
be too slow. Multi-Paxos optimizes by using the same set of ballot
numbers for all slots, and performing the <code class="docutils literal"><span class="pre">Prepare</span></code>/<code class="docutils literal"><span class="pre">Promise</span></code> phase
for all slots at once.</p>
<p class="rubric" id="paxos-made-pretty-hard">Paxos Made Pretty Hard</p>
<p>Implementing Multi-Paxos in practical software is notoriously difficult,
spawning a number of papers mocking Lamport's &quot;Paxos Made Simple&quot; with
titles like &quot;Paxos Made Practical&quot;.</p>
<p>First, the multiple-proposers problem described above can become
problematic in a busy environment, as each cluster member attempts to
get its state machine operation decided in each slot. The fix is to
elect a &quot;leader&quot; which is responsible for submitting ballots for each
slot. All other cluster nodes then send new operations to the leader for
execution. Thus, in normal operation with only one leader, ballot
conflicts do not occur.</p>
<p>The <code class="docutils literal"><span class="pre">Prepare</span></code>/<code class="docutils literal"><span class="pre">Promise</span></code> phase can function as a kind of leader
election: whichever cluster member owns the most recently promised
ballot number is considered the leader. The leader is then free to
execute the <code class="docutils literal"><span class="pre">Accept</span></code>/<code class="docutils literal"><span class="pre">Accepted</span></code> phase directly without repeating the
first phase. As we'll see below, leader elections are actually quite
complex.</p>
<p>Although simple Paxos guarantees that the cluster will not reach
conflicting decisions, it cannot guarantee that any decision will be
made. For example, if the initial <code class="docutils literal"><span class="pre">Prepare</span></code> message is lost and
doesn't reach the acceptors, then the proposer will wait for a
<code class="docutils literal"><span class="pre">Promise</span></code> message that will never arrive. Fixing this requires
carefully orchestrated re-transmissions: enough to eventually make
progress, but not so many that the cluster buries itself in a packet
storm.</p>
<p>Another problem is the dissemination of decisions. A simple broadcast of
a <code class="docutils literal"><span class="pre">Decision</span></code> message can take care of this for the normal case. If the
message is lost, though, a node can remain permanently ignorant of the
decision and unable to apply state machine transitions for later slots.
So an implementation needs some mechanism for sharing information about
decided proposals.</p>
<p>Our use of a distributed state machine presents another interesting
challenge: start-up. When a new node starts, it needs to catch up on the
existing state of the cluster. Although it can do so by catching up on
decisions for all slots since the first, in a mature cluster this may
involve millions of slots. Furthermore, we need some way to initialize a
new cluster.</p>
<p>But enough talk of theory and algorithms -- let's have a look at the
code.</p>
<p class="rubric" id="introducing-cluster">Introducing Cluster</p>
<p>The <em>Cluster</em> library in this chapter implements a simple form of
Multi-Paxos. It is designed as a library to provide a consensus service
to a larger application.</p>
<p>Users of this library will depend on its correctness, so it's important
to structure the code so that we can see -- and test -- its
correspondence to the specification. Complex protocols can exhibit
complex failures, so we will build support for reproducing and debugging
rare failures.</p>
<p>The implementation in this chapter is proof-of-concept code: enough to
demonstrate that the core concept is practical, but without all of the
mundane equipment required for use in production. The code is structured
so that such equipment can be added later with minimal changes to the
core implementation.</p>
<p>Let's get started.</p>
<p class="rubric" id="types-and-constants">Types and Constants</p>
<p>Cluster's protocol uses fifteen different message types, each defined as
a Python <a href="#id3"><span class="problematic" id="id4">``</span></a><a href="#id7"><span class="problematic" id="id8">`namedtuple```_</span></a>.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">Accepted</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Accepted&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;slot&#39;</span><span class="p">,</span> <span class="s1">&#39;ballot_num&#39;</span><span class="p">])</span>
<span class="n">Accept</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Accept&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;slot&#39;</span><span class="p">,</span> <span class="s1">&#39;ballot_num&#39;</span><span class="p">,</span> <span class="s1">&#39;proposal&#39;</span><span class="p">])</span>
<span class="n">Decision</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Decision&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;slot&#39;</span><span class="p">,</span> <span class="s1">&#39;proposal&#39;</span><span class="p">])</span>
<span class="n">Invoked</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Invoked&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;client_id&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">])</span>
<span class="n">Invoke</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Invoke&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;caller&#39;</span><span class="p">,</span> <span class="s1">&#39;client_id&#39;</span><span class="p">,</span> <span class="s1">&#39;input_value&#39;</span><span class="p">])</span>
<span class="n">Join</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Join&#39;</span><span class="p">,</span> <span class="p">[])</span>
<span class="n">Active</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Active&#39;</span><span class="p">,</span> <span class="p">[])</span>
<span class="n">Prepare</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Prepare&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ballot_num&#39;</span><span class="p">])</span>
<span class="n">Promise</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Promise&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ballot_num&#39;</span><span class="p">,</span> <span class="s1">&#39;accepted_proposals&#39;</span><span class="p">])</span>
<span class="n">Propose</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Propose&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;slot&#39;</span><span class="p">,</span> <span class="s1">&#39;proposal&#39;</span><span class="p">])</span>
<span class="n">Welcome</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Welcome&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">,</span> <span class="s1">&#39;slot&#39;</span><span class="p">,</span> <span class="s1">&#39;decisions&#39;</span><span class="p">])</span>
<span class="n">Decided</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Decided&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;slot&#39;</span><span class="p">])</span>
<span class="n">Preempted</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Preempted&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;slot&#39;</span><span class="p">,</span> <span class="s1">&#39;preempted_by&#39;</span><span class="p">])</span>
<span class="n">Adopted</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Adopted&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ballot_num&#39;</span><span class="p">,</span> <span class="s1">&#39;accepted_proposals&#39;</span><span class="p">])</span>
<span class="n">Accepting</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Accepting&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;leader&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Using named tuples to describe each message type keeps the code clean
and helps avoid some simple errors. The named tuple constructor will
raise an exception if it is not given exactly the right attributes,
making typos obvious. The tuples format themselves nicely in log
messages, and as an added bonus don't use as much memory as a
dictionary.</p>
<p>Creating a message reads naturally:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">msg</span> <span class="o">=</span> <span class="n">Accepted</span><span class="p">(</span><span class="n">slot</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ballot_num</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p>And the fields of that message are accessible with a minimum of extra
typing:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">got_ballot_num</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">ballot_num</span>
</pre></div>
</div>
<p>We'll see what these messages mean in the sections that follow. The code
also introduces a few constants, most of which define timeouts for
various messages:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">JOIN_RETRANSMIT</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="n">CATCHUP_INTERVAL</span> <span class="o">=</span> <span class="mf">0.6</span>
<span class="n">ACCEPT_RETRANSMIT</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">PREPARE_RETRANSMIT</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">INVOKE_RETRANSMIT</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">LEADER_TIMEOUT</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">NULL_BALLOT</span> <span class="o">=</span> <span class="n">Ballot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sorts before all real ballots</span>
<span class="n">NOOP_PROPOSAL</span> <span class="o">=</span> <span class="n">Proposal</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># no-op to fill otherwise empty slots</span>
</pre></div>
</div>
<p>Finally, Cluster uses two data types named to correspond to the protocol
description:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">Proposal</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Proposal&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;caller&#39;</span><span class="p">,</span> <span class="s1">&#39;client_id&#39;</span><span class="p">,</span> <span class="s1">&#39;input&#39;</span><span class="p">])</span>
<span class="n">Ballot</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Ballot&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;leader&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric" id="component-model">Component Model</p>
<p>Humans are limited by what we can hold in our active memory. We can't
reason about the entire Cluster implementation at once -- it's just too
much, so it's easy to miss details. For similar reasons, large
monolithic codebases are hard to test: test cases must manipulate many
moving pieces and are brittle, failing on almost any change to the code.</p>
<p>To encourage testability and keep the code readable, we break Cluster
down into a handful of classes corresponding to the roles described in
the protocol. Each is a subclass of <code class="docutils literal"><span class="pre">Role</span></code>.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Role</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">getChild</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_timer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">set_timer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span>
                                           <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="ow">and</span> <span class="n">callback</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>The roles that a cluster node has are glued together by the <code class="docutils literal"><span class="pre">Node</span></code>
class, which represents a single node on the network. Roles are added to
and removed from the node as execution proceeds. Messages that arrive on
the node are relayed to all active roles, calling a method named after
the message type with a <code class="docutils literal"><span class="pre">do_</span></code> prefix. These <code class="docutils literal"><span class="pre">do_</span></code> methods receive
the message's attributes as keyword arguments for easy access. The
<code class="docutils literal"><span class="pre">Node</span></code> class also provides a <code class="docutils literal"><span class="pre">send</span></code> method as a convenience, using
<code class="docutils literal"><span class="pre">functools.partial</span></code> to supply some arguments to the same methods of
the <code class="docutils literal"><span class="pre">Network</span></code> class.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">unique_ids</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span> <span class="ow">or</span> <span class="s1">&#39;N</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">SimTimeLogger</span><span class="p">(</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;network&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;starting&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roles</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">roles</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unregister</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roles</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roles</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">roles</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="n">handler_name</span> <span class="o">=</span> <span class="s1">&#39;do_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span>

        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">roles</span><span class="p">[:]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">handler_name</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;received </span><span class="si">%s</span><span class="s2"> from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">sender</span><span class="p">)</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">handler_name</span><span class="p">)</span>
            <span class="n">fn</span><span class="p">(</span><span class="n">sender</span><span class="o">=</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">message</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>
</pre></div>
</div>
<p class="rubric" id="application-interface">Application Interface</p>
<p>The application creates and starts a <code class="docutils literal"><span class="pre">Member</span></code> object on each cluster
member, providing an application-specific state machine and a list of
peers. The member object adds a bootstrap role to the node if it is
joining an existing cluster, or seed if it is creating a new cluster. It
then runs the protocol (via <code class="docutils literal"><span class="pre">Network.run</span></code>) in a separate thread.</p>
<p>The application interacts with the cluster through the <code class="docutils literal"><span class="pre">invoke</span></code>
method, which kicks off a proposal for a state transition. Once that
proposal is decided and the state machine runs, <code class="docutils literal"><span class="pre">invoke</span></code> returns the
machine's output. The method uses a simple synchronized <code class="docutils literal"><span class="pre">Queue</span></code> to
wait for the result from the protocol thread.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Member</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_machine</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">peers</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed_cls</span><span class="o">=</span><span class="n">Seed</span><span class="p">,</span> <span class="n">bootstrap_cls</span><span class="o">=</span><span class="n">Bootstrap</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">new_node</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">startup_role</span> <span class="o">=</span> <span class="n">seed_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">peers</span><span class="o">=</span><span class="n">peers</span><span class="p">,</span>
                                      <span class="n">execute_fn</span><span class="o">=</span><span class="n">state_machine</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">startup_role</span> <span class="o">=</span> <span class="n">bootstrap_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span>
                                      <span class="n">execute_fn</span><span class="o">=</span><span class="n">state_machine</span><span class="p">,</span> <span class="n">peers</span><span class="o">=</span><span class="n">peers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">requester</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">startup_role</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">run</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_value</span><span class="p">,</span> <span class="n">request_cls</span><span class="o">=</span><span class="n">Requester</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">requester</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">requester</span> <span class="o">=</span> <span class="n">request_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">input_value</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">requester</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">requester</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">output</span>
</pre></div>
</div>
<p class="rubric" id="role-classes">Role Classes</p>
<p>Let's look at each of the role classes in the library one by one.</p>
<p class="rubric" id="acceptor">Acceptor</p>
<p>The <code class="docutils literal"><span class="pre">Acceptor</span></code> implements the acceptor role in the protocol, so it
must store the ballot number representing its most recent promise, along
with the set of accepted proposals for each slot. It then responds to
<code class="docutils literal"><span class="pre">Prepare</span></code> and <code class="docutils literal"><span class="pre">Accept</span></code> messages according to the protocol. The
result is a short class that is easy to compare to the protocol.</p>
<p>For acceptors, Multi-Paxos looks a lot like Simple Paxos, with the
addition of slot numbers to the messages.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Acceptor</span><span class="p">(</span><span class="n">Role</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Acceptor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span> <span class="o">=</span> <span class="n">NULL_BALLOT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accepted_proposals</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># {slot: (ballot_num, proposal)}</span>

    <span class="k">def</span> <span class="nf">do_Prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">ballot_num</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ballot_num</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span> <span class="o">=</span> <span class="n">ballot_num</span>
            <span class="c1"># we&#39;ve heard from a scout, so it might be the next leader</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">],</span> <span class="n">Accepting</span><span class="p">(</span><span class="n">leader</span><span class="o">=</span><span class="n">sender</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="n">sender</span><span class="p">],</span> <span class="n">Promise</span><span class="p">(</span>
            <span class="n">ballot_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">,</span>
            <span class="n">accepted_proposals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">accepted_proposals</span>
        <span class="p">))</span>

    <span class="k">def</span> <span class="nf">do_Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">ballot_num</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">proposal</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ballot_num</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span> <span class="o">=</span> <span class="n">ballot_num</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">accepted_proposals</span>
            <span class="k">if</span> <span class="n">slot</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">acc</span><span class="p">[</span><span class="n">slot</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ballot_num</span><span class="p">:</span>
                <span class="n">acc</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ballot_num</span><span class="p">,</span> <span class="n">proposal</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="n">sender</span><span class="p">],</span> <span class="n">Accepted</span><span class="p">(</span>
            <span class="n">slot</span><span class="o">=</span><span class="n">slot</span><span class="p">,</span> <span class="n">ballot_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric" id="replica">Replica</p>
<p>The <code class="docutils literal"><span class="pre">Replica</span></code> class is the most complicated role class, as it has a
few closely related responsibilities:</p>
<ul class="simple">
<li>Making new proposals;</li>
<li>Invoking the local state machine when proposals are decided;</li>
<li>Tracking the current leader; and</li>
<li>Adding newly started nodes to the cluster.</li>
</ul>
<p>The replica creates new proposals in response to <code class="docutils literal"><span class="pre">Invoke</span></code> messages
from clients, selecting what it believes to be an unused slot and
sending a <code class="docutils literal"><span class="pre">Propose</span></code> message to the current leader (<a class="reference external" href="#figure-3.2">Figure 3.2</a>.)
Furthermore, if the consensus for the selected slot is for a different
proposal, the replica must re-propose with a new slot.</p>
<div class="center figure"><p><img alt="Figure 3.2 - Replica Role Control Flow" src="chapters/cluster-images/replica.png" /></p>
</div><p>Figure 3.2 - Replica Role Control Flow</p>
<p><code class="docutils literal"><span class="pre">Decision</span></code> messages represent slots on which the cluster has come to
consensus. Here, replicas store the new decision, then run the state
machine until it reaches an undecided slot. Replicas distinguish
<em>decided</em> slots, on which the cluster has agreed, from <em>committed</em>
slots, which the local state machine has processed. When slots are
decided out of order, the committed proposals may lag behind, waiting
for the next slot to be decided. When a slot is committed, each replica
sends an <code class="docutils literal"><span class="pre">Invoked</span></code> message back to the requester with the result of
the operation.</p>
<p>In some circumstances, it's possible for a slot to have no active
proposals and no decision. The state machine is required to execute
slots one by one, so the cluster must reach a consensus on something to
fill the slot. To protect against this possibility, replicas make a
&quot;no-op&quot; proposal whenever they catch up on a slot. If such a proposal is
eventually decided, then the state machine does nothing for that slot.</p>
<p>Likewise, it's possible for the same proposal to be decided twice. The
replica skips invoking the state machine for any such duplicate
proposals, performing no transition for that slot.</p>
<p>Replicas need to know which node is the active leader in order to send
<code class="docutils literal"><span class="pre">Propose</span></code> messages to it. There is a surprising amount of subtlety
required to get this right, as we'll see later. Each replica tracks the
active leader using three sources of information.</p>
<p>When the leader role becomes active, it sends an <code class="docutils literal"><span class="pre">Adopted</span></code> message to
the replica on the same node (<a class="reference external" href="#figure-3.3">Figure 3.3</a>.)</p>
<div class="center figure"><p><img alt="Figure 3.3 - Adopted" src="chapters/cluster-images/adopted.png" /></p>
</div><p>Figure 3.3 - Adopted</p>
<p>When the acceptor role sends a <code class="docutils literal"><span class="pre">Promise</span></code> to a new leader, it sends an
<code class="docutils literal"><span class="pre">Accepting</span></code> message to its local replica (<a class="reference external" href="#figure-3.4">Figure 3.4</a>.)</p>
<div class="center figure"><p><img alt="Figure 3.4 - Accepting" src="chapters/cluster-images/accepting.png" /></p>
</div><p>Figure 3.4 - Accepting</p>
<p>The active leader sends <code class="docutils literal"><span class="pre">Active</span></code> messages as a heartbeat (<a class="reference external" href="#figure-3.5">Figure
3.5</a>.) If no such message arrives before the <code class="docutils literal"><span class="pre">LEADER_TIMEOUT</span></code>
expires, the replica assumes the leader is dead and moves on to the next
leader. In this case, it's important that all replicas choose the <em>same</em>
new leader, which we accomplish by sorting the members and selecting the
next one in the list.</p>
<div class="center figure"><p><img alt="Figure 3.5 - Active" src="chapters/cluster-images/active.png" /></p>
</div><p>Figure 3.5 - Active</p>
<p>Finally, when a node joins the network, the bootstrap role sends a
<code class="docutils literal"><span class="pre">Join</span></code> message (<a class="reference external" href="#figure-3.6">Figure 3.6</a>.) The replica responds with a
<code class="docutils literal"><span class="pre">Welcome</span></code> message containing its most recent state, allowing the new
node to come up to speed quickly.</p>
<div class="center figure"><p><img alt="Figure 3.6 - Bootstrap" src="chapters/cluster-images/bootstrap.png" /></p>
</div><p>Figure 3.6 - Bootstrap</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Replica</span><span class="p">(</span><span class="n">Role</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">execute_fn</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">decisions</span><span class="p">,</span> <span class="n">peers</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Replica</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execute_fn</span> <span class="o">=</span> <span class="n">execute_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slot</span> <span class="o">=</span> <span class="n">slot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span> <span class="o">=</span> <span class="n">decisions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peers</span> <span class="o">=</span> <span class="n">peers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># next slot num for a proposal (may lead slot)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_slot</span> <span class="o">=</span> <span class="n">slot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latest_leader</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latest_leader_timeout</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># making proposals</span>

    <span class="k">def</span> <span class="nf">do_Invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">caller</span><span class="p">,</span> <span class="n">client_id</span><span class="p">,</span> <span class="n">input_value</span><span class="p">):</span>
        <span class="n">proposal</span> <span class="o">=</span> <span class="n">Proposal</span><span class="p">(</span><span class="n">caller</span><span class="p">,</span> <span class="n">client_id</span><span class="p">,</span> <span class="n">input_value</span><span class="p">)</span>
        <span class="n">slot</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposals</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">proposal</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># propose, or re-propose if this proposal already has a slot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">propose</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">propose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proposal</span><span class="p">,</span> <span class="n">slot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Send (or resend, if slot is specified) a proposal to the leader&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">slot</span><span class="p">:</span>
            <span class="n">slot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_slot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_slot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_slot</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposals</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="c1"># find a leader we think is working - either the latest we know of, or</span>
        <span class="c1"># ourselves (which may trigger a scout to make us the leader)</span>
        <span class="n">leader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latest_leader</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;proposing </span><span class="si">%s</span><span class="s2"> at slot </span><span class="si">%d</span><span class="s2"> to leader </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">leader</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="n">leader</span><span class="p">],</span> <span class="n">Propose</span><span class="p">(</span><span class="n">slot</span><span class="o">=</span><span class="n">slot</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="n">proposal</span><span class="p">))</span>

    <span class="c1"># handling decided proposals</span>

    <span class="k">def</span> <span class="nf">do_Decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">proposal</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slot</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> \
                <span class="s2">&quot;next slot to commit is already decided&quot;</span>
        <span class="k">if</span> <span class="n">slot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">==</span> <span class="n">proposal</span><span class="p">,</span> \
                <span class="s2">&quot;slot </span><span class="si">%d</span><span class="s2"> already decided with </span><span class="si">%r</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="p">[</span><span class="n">slot</span><span class="p">])</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_slot</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next_slot</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># re-propose our proposal in a new slot if it lost its slot and wasn&#39;t a no-op</span>
        <span class="n">our_proposal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">slot</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">our_proposal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="n">our_proposal</span> <span class="o">!=</span> <span class="n">proposal</span> <span class="ow">and</span> <span class="n">our_proposal</span><span class="o">.</span><span class="n">caller</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">propose</span><span class="p">(</span><span class="n">our_proposal</span><span class="p">)</span>

        <span class="c1"># execute any pending, decided proposals</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">commit_proposal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slot</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">commit_proposal</span><span class="p">:</span>
                <span class="k">break</span>  <span class="c1"># not decided yet</span>
            <span class="n">commit_slot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">(</span><span class="n">commit_slot</span><span class="p">,</span> <span class="n">commit_proposal</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">proposal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Actually commit a proposal that is decided and in sequence&quot;&quot;&quot;</span>
        <span class="n">decided_proposals</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">slot</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">proposal</span> <span class="ow">in</span> <span class="n">decided_proposals</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;not committing duplicate proposal </span><span class="si">%r</span><span class="s2">, slot </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">proposal</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>
            <span class="k">return</span>  <span class="c1"># duplicate</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;committing </span><span class="si">%r</span><span class="s2"> at slot </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="n">slot</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">proposal</span><span class="o">.</span><span class="n">caller</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># perform a client operation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">proposal</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="n">proposal</span><span class="o">.</span><span class="n">caller</span><span class="p">],</span>
                <span class="n">Invoked</span><span class="p">(</span><span class="n">client_id</span><span class="o">=</span><span class="n">proposal</span><span class="o">.</span><span class="n">client_id</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">))</span>

    <span class="c1"># tracking the leader</span>

    <span class="k">def</span> <span class="nf">do_Adopted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">ballot_num</span><span class="p">,</span> <span class="n">accepted_proposals</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latest_leader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leader_alive</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">do_Accepting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">leader</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latest_leader</span> <span class="o">=</span> <span class="n">leader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leader_alive</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">do_Active</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sender</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latest_leader</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leader_alive</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">leader_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">latest_leader_timeout</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latest_leader_timeout</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">reset_leader</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latest_leader</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latest_leader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">[(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;leader timed out; tring the next one, </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">latest_leader</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latest_leader_timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_timer</span><span class="p">(</span><span class="n">LEADER_TIMEOUT</span><span class="p">,</span> <span class="n">reset_leader</span><span class="p">)</span>

    <span class="c1"># adding new cluster members</span>

    <span class="k">def</span> <span class="nf">do_Join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sender</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="n">sender</span><span class="p">],</span> <span class="n">Welcome</span><span class="p">(</span>
                <span class="n">state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">slot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slot</span><span class="p">,</span> <span class="n">decisions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric" id="leader-scout-and-commander">Leader, Scout, and Commander</p>
<p>The leader's primary task is to take <code class="docutils literal"><span class="pre">Propose</span></code> messages requesting new
ballots and produce decisions. A leader is &quot;active&quot; when it has
successfully carried out the <code class="docutils literal"><span class="pre">Prepare</span></code>/<code class="docutils literal"><span class="pre">Promise</span></code> portion of the
protocol. An active leader can immediately send an <code class="docutils literal"><span class="pre">Accept</span></code> message in
response to a <code class="docutils literal"><span class="pre">Propose</span></code>.</p>
<p>In keeping with the class-per-role model, the leader delegates to the
scout and commander roles to carry out each portion of the protocol.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Leader</span><span class="p">(</span><span class="n">Role</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">peers</span><span class="p">,</span> <span class="n">commander_cls</span><span class="o">=</span><span class="n">Commander</span><span class="p">,</span> <span class="n">scout_cls</span><span class="o">=</span><span class="n">Scout</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Leader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span> <span class="o">=</span> <span class="n">Ballot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">commander_cls</span> <span class="o">=</span> <span class="n">commander_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scout_cls</span> <span class="o">=</span> <span class="n">scout_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scouting</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peers</span> <span class="o">=</span> <span class="n">peers</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># reminder others we&#39;re active before LEADER_TIMEOUT expires</span>
        <span class="k">def</span> <span class="nf">active</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">,</span> <span class="n">Active</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_timer</span><span class="p">(</span><span class="n">LEADER_TIMEOUT</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">active</span><span class="p">)</span>
        <span class="n">active</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">spawn_scout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scouting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scouting</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scout_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">do_Adopted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">ballot_num</span><span class="p">,</span> <span class="n">accepted_proposals</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scouting</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposals</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">accepted_proposals</span><span class="p">)</span>
        <span class="c1"># note that we don&#39;t re-spawn commanders here; if there are undecided</span>
        <span class="c1"># proposals, the replicas will re-propose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;leader becoming active&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">spawn_commander</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ballot_num</span><span class="p">,</span> <span class="n">slot</span><span class="p">):</span>
        <span class="n">proposal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposals</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">commander_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">ballot_num</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">proposal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">do_Preempted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">preempted_by</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">slot</span><span class="p">:</span>  <span class="c1"># from the scout</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scouting</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;leader preempted by </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">preempted_by</span><span class="o">.</span><span class="n">leader</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span> <span class="o">=</span> <span class="n">Ballot</span><span class="p">((</span><span class="n">preempted_by</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">)</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="o">.</span><span class="n">leader</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_Propose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">proposal</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">slot</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposals</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">proposals</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">proposal</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;spawning commander for slot </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">slot</span><span class="p">,))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spawn_commander</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scouting</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;got PROPOSE when not active - scouting&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spawn_scout</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;got PROPOSE while scouting; ignored&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;got PROPOSE for a slot already being proposed&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The leader creates a scout role when it wants to become active, in
response to receiving a <code class="docutils literal"><span class="pre">Propose</span></code> when it is inactive (<a class="reference external" href="#figure-3.7">Figure 3.7</a>.)
The scout sends (and re-sends, if necessary) a <code class="docutils literal"><span class="pre">Prepare</span></code> message, and
collects <code class="docutils literal"><span class="pre">Promise</span></code> responses until it has heard from a majority of its
peers or until it has been preempted. It communicates back to the leader
with <code class="docutils literal"><span class="pre">Adopted</span></code> or <code class="docutils literal"><span class="pre">Preempted</span></code>, respectively.</p>
<div class="center figure"><p><img alt="Figure 3.7 - Scout" src="chapters/cluster-images/leaderscout.png" /></p>
</div><p>Figure 3.7 - Scout</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Scout</span><span class="p">(</span><span class="n">Role</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">ballot_num</span><span class="p">,</span> <span class="n">peers</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Scout</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span> <span class="o">=</span> <span class="n">ballot_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accepted_proposals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peers</span> <span class="o">=</span> <span class="n">peers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quorum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peers</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retransmit_timer</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;scout starting&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_prepare</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">send_prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">,</span> <span class="n">Prepare</span><span class="p">(</span><span class="n">ballot_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retransmit_timer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_timer</span><span class="p">(</span><span class="n">PREPARE_RETRANSMIT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_prepare</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_accepted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">accepted_proposals</span><span class="p">):</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">accepted_proposals</span>
        <span class="k">for</span> <span class="n">slot</span><span class="p">,</span> <span class="p">(</span><span class="n">ballot_num</span><span class="p">,</span> <span class="n">proposal</span><span class="p">)</span> <span class="ow">in</span> <span class="n">accepted_proposals</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">slot</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">acc</span><span class="p">[</span><span class="n">slot</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ballot_num</span><span class="p">:</span>
                <span class="n">acc</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ballot_num</span><span class="p">,</span> <span class="n">proposal</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_Promise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">ballot_num</span><span class="p">,</span> <span class="n">accepted_proposals</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ballot_num</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;got matching promise; need </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">quorum</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_accepted</span><span class="p">(</span><span class="n">accepted_proposals</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sender</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quorum</span><span class="p">:</span>
                <span class="c1"># strip the ballot numbers from self.accepted_proposals, now that it</span>
                <span class="c1"># represents a majority</span>
                <span class="n">accepted_proposals</span> <span class="o">=</span> \
                    <span class="nb">dict</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">accepted_proposals</span><span class="o">.</span><span class="n">iteritems</span><span class="p">())</span>
                <span class="c1"># We&#39;re adopted; note that this does *not* mean that no other</span>
                <span class="c1"># leader is active.  # Any such conflicts will be handled by the</span>
                <span class="c1"># commanders.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">],</span>
                    <span class="n">Adopted</span><span class="p">(</span><span class="n">ballot_num</span><span class="o">=</span><span class="n">ballot_num</span><span class="p">,</span>
                            <span class="n">accepted_proposals</span><span class="o">=</span><span class="n">accepted_proposals</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this acceptor has promised another leader a higher ballot number,</span>
            <span class="c1"># so we&#39;ve lost</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">],</span>
                <span class="n">Preempted</span><span class="p">(</span><span class="n">slot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">preempted_by</span><span class="o">=</span><span class="n">ballot_num</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p>The leader creates a commander role for each slot where it has an active
proposal (<a class="reference external" href="#figure-3.8">Figure 3.8</a>.) Like a scout, a commander sends and re-sends
<code class="docutils literal"><span class="pre">Accept</span></code> messages and waits for a majority of acceptors to reply with
<code class="docutils literal"><span class="pre">Accepted</span></code>, or for news of its preemption. When a proposal is
accepted, the commander broadcasts a <code class="docutils literal"><span class="pre">Decision</span></code> message to all nodes.
It responds to the leader with <code class="docutils literal"><span class="pre">Decided</span></code> or <code class="docutils literal"><span class="pre">Preempted</span></code>.</p>
<div class="center figure"><p><img alt="Figure 3.8 - Commander" src="chapters/cluster-images/leadercommander.png" /></p>
</div><p>Figure 3.8 - Commander</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Commander</span><span class="p">(</span><span class="n">Role</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">ballot_num</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">proposal</span><span class="p">,</span> <span class="n">peers</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Commander</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span> <span class="o">=</span> <span class="n">ballot_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slot</span> <span class="o">=</span> <span class="n">slot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peers</span> <span class="o">=</span> <span class="n">peers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quorum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peers</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">,</span> <span class="n">Accept</span><span class="p">(</span>
            <span class="n">slot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slot</span><span class="p">,</span> <span class="n">ballot_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_timer</span><span class="p">(</span><span class="n">ACCEPT_RETRANSMIT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">finished</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ballot_num</span><span class="p">,</span> <span class="n">preempted</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">preempted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">],</span>
                           <span class="n">Preempted</span><span class="p">(</span><span class="n">slot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slot</span><span class="p">,</span> <span class="n">preempted_by</span><span class="o">=</span><span class="n">ballot_num</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">],</span>
                           <span class="n">Decided</span><span class="p">(</span><span class="n">slot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slot</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">do_Accepted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">ballot_num</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">slot</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slot</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">ballot_num</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sender</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">quorum</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">,</span> <span class="n">Decision</span><span class="p">(</span>
                           <span class="n">slot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slot</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="p">(</span><span class="n">ballot_num</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="p">(</span><span class="n">ballot_num</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>As an aside, a surprisingly subtle bug appeared here during development.
At the time, the network simulator introduced packet loss even on
messages within a node. When <em>all</em> <code class="docutils literal"><span class="pre">Decision</span></code> messages were lost, the
protocol could not proceed. The replica continued to re-transmit
<code class="docutils literal"><span class="pre">Propose</span></code> messages, but the leader ignored them as it already had a
proposal for that slot. The replica's catch-up process could not find
the result, as no replica had heard of the decision. The solution was to
ensure that local messages are always delivered, as is the case for real
network stacks.</p>
<p class="rubric" id="bootstrap">Bootstrap</p>
<p>When a node joins the cluster, it must determine the current cluster
state before it can participate. The bootstrap role handles this by
sending <code class="docutils literal"><span class="pre">Join</span></code> messages to each peer in turn until it receives a
<code class="docutils literal"><span class="pre">Welcome</span></code>. Bootstrap's communication diagram is shown above in
<a href="#id9"><span class="problematic" id="id10">`Replica`_</span></a>.</p>
<p>An early version of the implementation started each node with a full set
of roles (replica, leader, and acceptor), each of which began in a
&quot;startup&quot; phase, waiting for information from the <code class="docutils literal"><span class="pre">Welcome</span></code> message.
This spread the initialization logic around every role, requiring
separate testing of each one. The final design has the bootstrap role
adding each of the other roles to the node once startup is complete,
passing the initial state to their constructors.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Bootstrap</span><span class="p">(</span><span class="n">Role</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">peers</span><span class="p">,</span> <span class="n">execute_fn</span><span class="p">,</span>
                 <span class="n">replica_cls</span><span class="o">=</span><span class="n">Replica</span><span class="p">,</span> <span class="n">acceptor_cls</span><span class="o">=</span><span class="n">Acceptor</span><span class="p">,</span> <span class="n">leader_cls</span><span class="o">=</span><span class="n">Leader</span><span class="p">,</span>
                 <span class="n">commander_cls</span><span class="o">=</span><span class="n">Commander</span><span class="p">,</span> <span class="n">scout_cls</span><span class="o">=</span><span class="n">Scout</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Bootstrap</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execute_fn</span> <span class="o">=</span> <span class="n">execute_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peers</span> <span class="o">=</span> <span class="n">peers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peers_cycle</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">peers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replica_cls</span> <span class="o">=</span> <span class="n">replica_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptor_cls</span> <span class="o">=</span> <span class="n">acceptor_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leader_cls</span> <span class="o">=</span> <span class="n">leader_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">commander_cls</span> <span class="o">=</span> <span class="n">commander_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scout_cls</span> <span class="o">=</span> <span class="n">scout_cls</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peers_cycle</span><span class="p">)],</span> <span class="n">Join</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_timer</span><span class="p">(</span><span class="n">JOIN_RETRANSMIT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_Welcome</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">decisions</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptor_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replica_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">execute_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">execute_fn</span><span class="p">,</span> <span class="n">peers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">,</span>
                         <span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">,</span> <span class="n">slot</span><span class="o">=</span><span class="n">slot</span><span class="p">,</span> <span class="n">decisions</span><span class="o">=</span><span class="n">decisions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leader_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">peers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">,</span> <span class="n">commander_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">commander_cls</span><span class="p">,</span>
                        <span class="n">scout_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scout_cls</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric" id="seed">Seed</p>
<p>In normal operation, when a node joins the cluster, it expects to find
the cluster already running, with at least one node willing to respond
to a <code class="docutils literal"><span class="pre">Join</span></code> message. But how does the cluster get started? One option
is for the bootstrap role to determine, after attempting to contact
every other node, that it is the first in the cluster. But this has two
problems. First, for a large cluster it means a long wait while each
<code class="docutils literal"><span class="pre">Join</span></code> times out. More importantly, in the event of a network
partition, a new node might be unable to contact any others and start a
new cluster.</p>
<p>Network partitions are the most challenging failure case for clustered
applications. In a network partition, all cluster members remain alive,
but communication fails between some members. For example, if the
network link joining a cluster with nodes in Berlin and Taipei fails,
the network is partitioned. If both parts of a cluster continue to
operate during a partition, then re-joining the parts after the network
link is restored can be challenging. In the Multi-Paxos case, the healed
network would be hosting two clusters with different decisions for the
same slot numbers.</p>
<p>To avoid this outcome, creating a new cluster is a user-specified
operation. Exactly one node in the cluster runs the seed role, with the
others running bootstrap as usual. The seed waits until it has received
<code class="docutils literal"><span class="pre">Join</span></code> messages from a majority of its peers, then sends a <code class="docutils literal"><span class="pre">Welcome</span></code>
with an initial state for the state machine and an empty set of
decisions. The seed role then stops itself and starts a bootstrap role
to join the newly-seeded cluster.</p>
<p>Seed emulates the <code class="docutils literal"><span class="pre">Join</span></code>/<code class="docutils literal"><span class="pre">Welcome</span></code> part of the bootstrap/replica
interaction, so its communication diagram is the same as for the replica
role.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Seed</span><span class="p">(</span><span class="n">Role</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">execute_fn</span><span class="p">,</span> <span class="n">peers</span><span class="p">,</span>
                 <span class="n">bootstrap_cls</span><span class="o">=</span><span class="n">Bootstrap</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Seed</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span> <span class="o">=</span> <span class="n">initial_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execute_fn</span> <span class="o">=</span> <span class="n">execute_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peers</span> <span class="o">=</span> <span class="n">peers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_cls</span> <span class="o">=</span> <span class="n">bootstrap_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seen_peers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exit_timer</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">do_Join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seen_peers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sender</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seen_peers</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># cluster is ready - welcome everyone</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seen_peers</span><span class="p">),</span> <span class="n">Welcome</span><span class="p">(</span>
            <span class="n">state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">slot</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">decisions</span><span class="o">=</span><span class="p">{}))</span>

        <span class="c1"># stick around for long enough that we don&#39;t hear any new JOINs from</span>
        <span class="c1"># the newly formed cluster</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_timer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exit_timer</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exit_timer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_timer</span><span class="p">(</span><span class="n">JOIN_RETRANSMIT</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">finish</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># bootstrap this node into the cluster we just seeded</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span>
                                <span class="n">peers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">,</span> <span class="n">execute_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">execute_fn</span><span class="p">)</span>
        <span class="n">bs</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric" id="requester">Requester</p>
<p>The requester role manages a request to the distributed state machine.
The role class simply sends <code class="docutils literal"><span class="pre">Invoke</span></code> messages to the local replica
until it receives a corresponding <code class="docutils literal"><span class="pre">Invoked</span></code>. See the &quot;Replica&quot;
section, above, for this role's communication diagram.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Requester</span><span class="p">(</span><span class="n">Role</span><span class="p">):</span>

    <span class="n">client_ids</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Requester</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_ids</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">],</span>
                       <span class="n">Invoke</span><span class="p">(</span><span class="n">caller</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                              <span class="n">client_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">client_id</span><span class="p">,</span> <span class="n">input_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invoke_timer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_timer</span><span class="p">(</span><span class="n">INVOKE_RETRANSMIT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_Invoked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">client_id</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">client_id</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_id</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;received output </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">output</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invoke_timer</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric" id="summary">Summary</p>
<p>To recap, cluster's roles are:</p>
<ul class="simple">
<li>Acceptor -- make promises and accept proposals</li>
<li>Replica -- manage the distributed state machine: submitting
proposals, committing decisions, and responding to requesters</li>
<li>Leader -- lead rounds of the Multi-Paxos algorithm</li>
<li>Scout -- perform the <code class="docutils literal"><span class="pre">Prepare</span></code>/<code class="docutils literal"><span class="pre">Promise</span></code> portion of the
Multi-Paxos algorithm for a leader</li>
<li>Commander -- perform the <code class="docutils literal"><span class="pre">Accept</span></code>/<code class="docutils literal"><span class="pre">Accepted</span></code> portion of the
Multi-Paxos algorithm for a leader</li>
<li>Bootstrap -- introduce a new node to an existing cluster</li>
<li>Seed -- create a new cluster</li>
<li>Requester -- request a distributed state machine operation</li>
</ul>
<p>There is just one more piece of equipment required to make Cluster go:
the network through which all of the nodes communicate.</p>
<p class="rubric" id="network">Network</p>
<p>Any network protocol needs the ability to send and receive messages and
a means of calling functions at a time in the future.</p>
<p>The <code class="docutils literal"><span class="pre">Network</span></code> class provides a simple simulated network with these
capabilities and also simulates packet loss and message propagation
delays.</p>
<p>Timers are handled using Python's <code class="docutils literal"><span class="pre">heapq</span></code> module, allowing efficient
selection of the next event. Setting a timer involves pushing a
<code class="docutils literal"><span class="pre">Timer</span></code> object onto the heap. Since removing items from a heap is
inefficient, cancelled timers are left in place but marked as cancelled.</p>
<p>Message transmission uses the timer functionality to schedule a later
delivery of the message at each node, using a random simulated delay. We
again use <code class="docutils literal"><span class="pre">functools.partial</span></code> to set up a future call to the
destination node's <code class="docutils literal"><span class="pre">receive</span></code> method with appropriate arguments.</p>
<p>Running the simulation just involves popping timers from the heap and
executing them if they have not been cancelled and if the destination
node is still active.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Timer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expires</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">expires</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cancelled</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expires</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">expires</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cancelled</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">Network</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">PROP_DELAY</span> <span class="o">=</span> <span class="mf">0.03</span>
    <span class="n">PROP_JITTER</span> <span class="o">=</span> <span class="mf">0.02</span>
    <span class="n">DROP_PROB</span> <span class="o">=</span> <span class="mf">0.05</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnd</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">now</span> <span class="o">=</span> <span class="mf">1000.0</span>

    <span class="k">def</span> <span class="nf">new_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">return</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">timers</span><span class="p">:</span>
            <span class="n">next_timer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">next_timer</span><span class="o">.</span><span class="n">expires</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">now</span> <span class="o">=</span> <span class="n">next_timer</span><span class="o">.</span><span class="n">expires</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timers</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_timer</span><span class="o">.</span><span class="n">cancelled</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">next_timer</span><span class="o">.</span><span class="n">address</span> <span class="ow">or</span> <span class="n">next_timer</span><span class="o">.</span><span class="n">address</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="n">next_timer</span><span class="o">.</span><span class="n">callback</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timers</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">set_timer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span> <span class="o">+</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timers</span><span class="p">,</span> <span class="n">timer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">timer</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="n">sender</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;sending </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">destinations</span><span class="p">)</span>
        <span class="c1"># avoid aliasing by making a closure containing distinct deep copy of</span>
        <span class="c1"># message for each dest</span>
        <span class="k">def</span> <span class="nf">sendto</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dest</span> <span class="o">==</span> <span class="n">sender</span><span class="o">.</span><span class="n">address</span><span class="p">:</span>
                <span class="c1"># reliably deliver local messages with no delay</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_timer</span><span class="p">(</span><span class="n">sender</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                               <span class="k">lambda</span><span class="p">:</span> <span class="n">sender</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="n">sender</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnd</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">DROP_PROB</span><span class="p">:</span>
                <span class="n">delay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PROP_DELAY</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnd</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">PROP_JITTER</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">PROP_JITTER</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_timer</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span>
                               <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span><span class="o">.</span><span class="n">receive</span><span class="p">,</span>
                                                 <span class="n">sender</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">dest</span> <span class="ow">in</span> <span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">destinations</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">sendto</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>
</pre></div>
</div>
<p>While it's not included in this implementation, the component model
allows us to swap in a real-world network implementation, communicating
between actual servers on a real network, with no changes to the other
components. Testing and debugging can take place using the simulated
network, with production use of the library operating over real network
hardware.</p>
<p class="rubric" id="debugging-support">Debugging Support</p>
<p>When developing a complex system such as this, the bugs quickly
transition from trivial, like a simple <code class="docutils literal"><span class="pre">NameError</span></code>, to obscure
failures that only manifest after several minutes of (simulated) proocol
operation. Chasing down bugs like this involves working backward from
the point where the error became obvious. Interactive debuggers are
useless here, as they can only step forward in time.</p>
<p>The most important debugging feature in Cluster is a <em>deterministic</em>
simulator. Unlike a real network, it will behave exactly the same way on
every run, given the same seed for the random number generator. This
means that we can add additional debugging checks or output to the code
and re-run the simulation to see the same failure in more detail.</p>
<p>Of course, much of that detail is in the messages exchanged by the nodes
in the cluster, so those are automatically logged in their entirety.
That logging includes the role class sending or receiving the message,
as well as the simulated timestamp injected via the <code class="docutils literal"><span class="pre">SimTimeLogger</span></code>
class.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SimTimeLogger</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">LoggerAdapter</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;T=</span><span class="si">%.3f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">msg</span><span class="p">),</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">getChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">getChild</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
                              <span class="p">{</span><span class="s1">&#39;network&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">]})</span>
</pre></div>
</div>
<p>A resilient protocol such as this one can often run for a long time
after a bug has been triggered. For example, during development, a data
aliasing error caused all replicas to share the same <code class="docutils literal"><span class="pre">decisions</span></code>
dictionary. This meant that once a decision was handled on one node, all
other nodes saw it as already decided. Even with this serious bug, the
cluster produced correct results for several transactions before
deadlocking.</p>
<p>Assertions are an important tool to catch this sort of error early.
Assertions should include any invariants from the algorithm design, but
when the code doesn't behave as we expect, asserting our expectations is
a great way to see where things go astray.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slot</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> \
        <span class="s2">&quot;next slot to commit is already decided&quot;</span>
<span class="k">if</span> <span class="n">slot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="p">:</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">==</span> <span class="n">proposal</span><span class="p">,</span> \
        <span class="s2">&quot;slot </span><span class="si">%d</span><span class="s2"> already decided with </span><span class="si">%r</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decisions</span><span class="p">[</span><span class="n">slot</span><span class="p">])</span>
</pre></div>
</div>
<p>Identifying the right assumptions we make while reading code is a part
of the art of debugging. In this code from <code class="docutils literal"><span class="pre">Replica.do_Decision</span></code>, the
problem was that the <code class="docutils literal"><span class="pre">Decision</span></code> for the next slot to commit was being
ignored because it was already in <code class="docutils literal"><span class="pre">self.decisions</span></code>. The underlying
assumption being violated was that the next slot to be committed was not
yet decided. Asserting this at the beginning of <code class="docutils literal"><span class="pre">do_Decision</span></code>
identified the flaw and led quickly to the fix. Similarly, other bugs
led to cases where different proposals were decided in the same slot --
a serious error.</p>
<p>Many other assertions were added during development of the protocol, but
in the interests of space, only a few remain.</p>
<p class="rubric" id="testing">Testing</p>
<p>Some time in the last ten years, coding without tests finally became as
crazy as driving without a seatbelt. Code without tests is probably
incorrect, and modifying code is risky without a way to see if its
behavior has changed.</p>
<p>Testing is most effective when the code is organized for testability.
There are a few active schools of thought in this area, but the approach
we've taken is to divide the code into small, minimally connected units
that can be tested in isolation. This agrees nicely with the role model,
where each role has a specific purpose and can operate in isolation from
the others, resulting in a compact, self-sufficient class.</p>
<p>Cluster is written to maximize that isolation: all communication between
roles takes place via messages, with the exception of creating new
roles. For the most part, then, roles can be tested by sending messages
to them and observing their responses.</p>
<p class="rubric" id="unit-testing">Unit Testing</p>
<p>The unit tests for Cluster are simple and short:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Tests</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">ComponentTestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_propose_active</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A PROPOSE received while active spawns a commander.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activate_leader</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">fake_message</span><span class="p">(</span><span class="n">Propose</span><span class="p">(</span><span class="n">slot</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="n">PROPOSAL1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertCommanderStarted</span><span class="p">(</span><span class="n">Ballot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;F999&#39;</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="n">PROPOSAL1</span><span class="p">)</span>
</pre></div>
</div>
<p>This method tests a single behavior (commander spawning) of a single
unit (the <code class="docutils literal"><span class="pre">Leader</span></code> class). It follows the well-known &quot;arrange, act,
assert&quot; pattern: set up an active leader, send it a message, and check
the result.</p>
<p class="rubric" id="dependency-injection">Dependency Injection</p>
<p>We use a technique called &quot;dependency injection&quot; to handle creation of
new roles. Each role class which adds other roles to the network takes a
list of class objects as constructor arguments, defaulting to the actual
classes. For example, the constructor for <code class="docutils literal"><span class="pre">Leader</span></code> looks like this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Leader</span><span class="p">(</span><span class="n">Role</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">peers</span><span class="p">,</span> <span class="n">commander_cls</span><span class="o">=</span><span class="n">Commander</span><span class="p">,</span> <span class="n">scout_cls</span><span class="o">=</span><span class="n">Scout</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Leader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span> <span class="o">=</span> <span class="n">Ballot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">commander_cls</span> <span class="o">=</span> <span class="n">commander_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scout_cls</span> <span class="o">=</span> <span class="n">scout_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scouting</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peers</span> <span class="o">=</span> <span class="n">peers</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">spawn_scout</span></code> method (and similarly, <code class="docutils literal"><span class="pre">spawn_commander</span></code>) creates
the new role object with <code class="docutils literal"><span class="pre">self.scout_cls</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Leader</span><span class="p">(</span><span class="n">Role</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">spawn_scout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scouting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scouting</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scout_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ballot_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peers</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>The magic of this technique is that, in testing, <code class="docutils literal"><span class="pre">Leader</span></code> can be given
fake classes and thus tested separately from <code class="docutils literal"><span class="pre">Scout</span></code> and
<code class="docutils literal"><span class="pre">Commander</span></code>.</p>
<p class="rubric" id="interface-correctness">Interface Correctness</p>
<p>One pitfall of a focus on small units is that it does not test the
interfaces between units. For example, unit tests for the acceptor role
verify the format of the <code class="docutils literal"><span class="pre">accepted</span></code> attribute of the <code class="docutils literal"><span class="pre">Promise</span></code>
message, and the unit tests for the scout role supply well-formatted
values for the attribute. Neither test checks that those formats match.</p>
<p>One approach to fixing this issue is to make the interfaces
self-enforcing. In Cluster, the use of named tuples and keyword
arguments avoids any disagreement over messages' attributes. Because the
only interaction between role classes is via messages, this covers a
large part of the interface.</p>
<p>For specific issues such as the format of <code class="docutils literal"><span class="pre">accepted_proposals</span></code>, both
the real and test data can be verified using the same function, in this
case <code class="docutils literal"><span class="pre">verifyPromiseAccepted</span></code>. The tests for the acceptor use this
method to verify each returned <code class="docutils literal"><span class="pre">Promise</span></code>, and the tests for the scout
use it to verify every fake <code class="docutils literal"><span class="pre">Promise</span></code>.</p>
<p class="rubric" id="integration-testing">Integration Testing</p>
<p>The final bulwark against interface problems and design errors is
integration testing. An integration test assembles multiple units
together and tests their combined effect. In our case, that means
building a network of several nodes, injecting some requests into it,
and verifying the results. If there are any interface issues not
discovered in unit testing, they should cause the integration tests to
fail quickly.</p>
<p>Because the protocol is intended to handle node failure gracefully, we
test a few failure scenarios as well, including the untimely failure of
the active leader.</p>
<p>Integration tests are harder to write than unit tests, because they are
less well-isolated. For Cluster, this is clearest in testing the failed
leader, as any node could be the active leader. Even with a
deterministic network, a change in one message alters the random number
generator's state and thus unpredictably changes later events. Rather
than hard-coding the expected leader, the test code must dig into the
internal state of each leader to find one that believes itself to be
active.</p>
<p class="rubric" id="fuzz-testing">Fuzz Testing</p>
<p>It's very difficult to test resilient code: it is likely to be resilient
to its own bugs, so integration tests may not detect even very serious
bugs. It is also hard to imagine and construct tests for every possible
failure mode.</p>
<p>A common approach to this sort of problem is &quot;fuzz testing&quot;: running the
code repeatedly with randomly changing inputs until something breaks.
When something <em>does</em> break, all of the debugging support becomes
critical: if the failure can't be reproduced, and the logging
information isn't sufficient to find the bug, then you can't fix it!</p>
<p>I performed some manual fuzz testing of cluster during development, but
a full fuzz-testing infrastructure is beyond the scope of this project.</p>
<p class="rubric" id="power-struggles">Power Struggles</p>
<p>A cluster with many active leaders is a very noisy place, with scouts
sending ever-increasing ballot numbers to acceptors, and no ballots
being decided. A cluster with no active leader is quiet, but equally
nonfunctional. Balancing the implementation so that a cluster almost
always agrees on exactly one leader is remarkably difficult.</p>
<p>It's easy enough to avoid fighting leaders: when preempted, a leader
just accepts its new inactive status. However, this easily leads to a
case where there are no active leaders, so an inactive leader will try
to become active every time it gets a <code class="docutils literal"><span class="pre">Propose</span></code> message.</p>
<p>If the whole cluster doesn't agree on which member is the active leader,
there's trouble: different replicas send <code class="docutils literal"><span class="pre">Propose</span></code> messages to
different leaders, leading to battling scouts. So it's important that
leader elections be decided quickly, and that all cluster members find
out about the result as quickly as possible.</p>
<p>Cluster handles this by detecting a leader change as quickly as
possible: when an acceptor sends a <code class="docutils literal"><span class="pre">Promise</span></code>, chances are good that
the promised member will be the next leader. Failures are detected with
a heartbeat protocol.</p>
<p class="rubric" id="further-extensions">Further Extensions</p>
<p>Of course, there are plenty of ways we could extend and improve this
implementation.</p>
<p class="rubric" id="catching-up">Catching Up</p>
<p>In &quot;pure&quot; Multi-Paxos, nodes which fail to receive messages can be many
slots behind the rest of the cluster. As long as the state of the
distributed state machine is never accessed except via state machine
transitions, this design is functional. To read from the state, the
client requests a state-machine transition that does not actually alter
the state, but which returns the desired value. This transition is
executed cluster-wide, ensuring that it returns the same value
everywhere, based on the state at the slot in which it is proposed.</p>
<p>Even in the optimal case, this is slow, requiring several round trips
just to read a value. If a distributed object store made such a request
for every object access, its performance would be dismal. But when the
node receiving the request is lagging behind, the request delay is much
greater as that node must catch up to the rest of the cluster before
making a successful proposal.</p>
<p>A simple solution is to implement a gossip-style protocol, where each
replica periodically contacts other replicas to share the highest slot
it knows about and to request information on unknown slots. Then even
when a <code class="docutils literal"><span class="pre">Decision</span></code> message was lost, the replica would quickly find out
about the decision from one of its peers.</p>
<p class="rubric" id="consistent-memory-usage">Consistent Memory Usage</p>
<p>A cluster-management library provides reliability in the presence of
unreliable components. It shouldn't add unreliability of its own.
Unfortunately, Cluster will not run for long without failing due to
ever-growing memory use and message size.</p>
<p>In the protocol definition, acceptors and replicas form the &quot;memory&quot; of
the protocol, so they need to remember everything. These classes never
know when they will receive a request for an old slot, perhaps from a
lagging replica or leader. To maintain correctness, then, they keep a
list of every decision, ever, since the cluster was started. Worse,
these decisions are transmitted between replicas in <code class="docutils literal"><span class="pre">Welcome</span></code>
messages, making these messages enormous in a long-lived cluster.</p>
<p>One technique to address this issue is to periodically &quot;checkpoint&quot; each
node's state, keeping information about some limited number of decisions
on hand. Nodes which are so out of date that they have not committed all
slots up to the checkpoint must &quot;reset&quot; themselves by leaving and
re-joining the cluster.</p>
<p class="rubric" id="persistent-storage">Persistent Storage</p>
<p>While it's OK for a minority of cluster members to fail, it's not OK for
an acceptor to &quot;forget&quot; any of the values it has accepted or promises it
has made.</p>
<p>Unfortunately, this is exactly what happens when a cluster member fails
and restarts: the newly initialized Acceptor instance has no record of
the promises its predecessor made. The problem is that the newly-started
instance takes the place of the old.</p>
<p>There are two ways to solve this issue. The simpler solution involves
writing acceptor state to disk and re-reading that state on startup. The
more complex solution is to remove failed cluster members from the
cluster, and require that new members be added to the cluster. This kind
of dynamic adjustment of the cluster membership is called a &quot;view
change&quot;.</p>
<p class="rubric" id="view-changes">View Changes</p>
<p>Operations engineers need to be able to resize clusters to meet load and
availability requirements. A simple test project might begin with a
minimal cluster of three nodes, where any one can fail without impact.
When that project goes &quot;live&quot;, though, the additional load will require
a larger cluster.</p>
<p>Cluster, as written, cannot change the set of peers in a cluster without
restarting the entire cluster. Ideally, the cluster would be able to
maintain a consensus about its membership, just as it does about state
machine transitions. This means that the set of cluster members (the
<em>view</em>) can be changed by special view-change proposals. But the Paxos
algorithm depends on universal agreement about the members in the
cluster, so we must define the view for each slot.</p>
<p>Lamport addresses this challenge in the final paragraph of &quot;Paxos Made
Simple&quot;:</p>
<blockquote>
<div>We can allow a leader to get \(\alpha\) commands ahead by letting
the set of servers that execute instance \(i+\alpha\) of the
consensus algorithm be specified by the state after execution of the
\(i\)th state machine command. (Lamport, 2001)</div></blockquote>
<p>The idea is that each instance of Paxos (slot) uses the view from
\(\alpha\) slots earlier. This allows the cluster to work on, at
most, \(\alpha\) slots at any one time, so a very small value of
\(\alpha\) limits concurrency, while a very large value of
\(\alpha\) makes view changes slow to take effect.</p>
<p>In early drafts of this implementation (dutifully preserved in the git
history!), I implemented support for view changes (using \(\alpha\)
in place of 3). This seemingly simple change introduced a great deal of
complexity:</p>
<ul class="simple">
<li>tracking the view for each of the last \(\alpha\) committed slots
and correctly sharing this with new nodes,</li>
<li>ignoring proposals for which no slot is available,</li>
<li>detecting failed nodes,</li>
<li>properly serializing multiple competing view changes, and</li>
<li>communicating view information between the leader and replica.</li>
</ul>
<p>The result was far too large for this book!</p>
<p class="rubric" id="references">References</p>
<p>In addition to the original Paxos paper and Lamport's follow-up &quot;Paxos
Made Simple&quot;<a class="reference external" href="#fn2">:sup:`2`</a>, our implementation added extensions that were
informed by several other resources. The role names were taken from
&quot;Paxos Made Moderately Complex&quot;<a class="reference external" href="#fn3">:sup:`3`</a>. &quot;Paxos Made
Live&quot;<a class="reference external" href="#fn4">:sup:`4`</a> was helpful regarding snapshots in particular, and
<a class="reference external" href="http://www.scs.stanford.edu/~dm/home/papers/paxos.pdf">&quot;Paxos Made Practical&quot;</a> described view changes (although not of the
type described here.) Liskov's &quot;From Viewstamped Replication to
Byzantine Fault Tolerance&quot;<a class="reference external" href="#fn5">:sup:`5`</a> provided yet another perspective
on view changes. Finally, a <a class="reference external" href="http://stackoverflow.com/questions/21353312/in-part-time-parliament-why-does-using-the-membership-from-decree-n-3-work-to">Stack Overflow discussion</a> was helpful in
learning how members are added and removed from the system.</p>
<div class="footnotes"><hr class="docutils" />
<ol class="arabic">
<li><div class="first"><div id="fn1"></div></div><p>L. Lamport, &quot;The Part-Time Parliament,&quot; ACM Transactions on Computer
Systems, 16(2):133–169, May 1998.<a class="reference external" href="#fnref1">↩</a></p>
</li>
<li><div class="first"><div id="fn2"></div></div><p>L. Lamport, &quot;Paxos Made Simple,&quot; ACM SIGACT News (Distributed
Computing Column) 32, 4 (Whole Number 121, December 2001)
51-58.<a class="reference external" href="#fnref2">↩</a></p>
</li>
<li><div class="first"><div id="fn3"></div></div><p>R. Van Renesse and D. Altinbuken, &quot;Paxos Made Moderately Complex,&quot;
ACM Comp. Survey 47, 3, Article 42 (Feb. 2015)<a class="reference external" href="#fnref3">↩</a></p>
</li>
<li><div class="first"><div id="fn4"></div></div><p>T. Chandra, R. Griesemer, and J. Redstone, &quot;Paxos Made Live - An
Engineering Perspective,&quot; Proceedings of the twenty-sixth annual ACM
symposium on Principles of distributed computing (PODC '07). ACM, New
York, NY, USA, 398-407.<a class="reference external" href="#fnref4">↩</a></p>
</li>
<li><div class="first"><div id="fn5"></div></div><p>B. Liskov, &quot;From Viewstamped Replication to Byzantine Fault
Tolerance,&quot; In <em>Replication</em>, Springer-Verlag, Berlin, Heidelberg
121-149 (2010)`↩ &lt;#fnref5&gt;`__</p>
</li>
</ol>
</div></div></div></div></div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Learn-Computer-and-Math-again</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="blockcode-a-visual-programming-toolkit.html">500 Lines or Less | Blockcode: A visual programming toolkit</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, timger.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/chapters/clustering-by-consensus.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>