
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>500 Lines or Less | A Simple Object Model &#8212; Learn-Computer-and-Math-again 0.0.1 文档</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lines-or-less-a-simple-object-model">
<h1>500 Lines or Less | A Simple Object Model<a class="headerlink" href="#lines-or-less-a-simple-object-model" title="永久链接至标题">¶</a></h1>
<div class="container"><div class="row"><div class="hero-unit"><p><a href="#id1"><span class="problematic" id="id2">``</span></a>_
.. rubric:: A Simple Object Model</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">a-simple-object-model</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p class="author rubric" id="carl-friedrich-bolz">Carl Friedrich Bolz</p>
</div></div><div class="row"><div id="content" class="span10 offset1"><p><em>Carl Friedrich Bolz is a researcher at King's College London and is
broadly interested in the implementation and optimization of all kinds
of dynamic languages. He is one of the core authors of PyPy/RPython and
has worked on implementations of Prolog, Racket, Smalltalk, PHP and
Ruby. He's `&#64;cfbolz`_ on Twitter.</em></p>
<p class="rubric" id="introduction">Introduction</p>
<p>Object-oriented programming is one of the major programming paradigms in
use today, with a lot of languages providing some form of
object-orientation. While on the surface the mechanisms that different
object-oriented programming languages provide to the programmer are very
similar, the details can vary a lot. Commonalities of most languages are
the presence of objects and some kind of inheritance mechanism. Classes,
however, are a feature that not every language supports directly. For
example, in prototype-based languages like Self or JavaScript, the
concept of class does not exist and objects instead inherit directly
from each other.</p>
<p>Understanding the differences between different object models can be
interesting. They often reveal the family resemblance between different
languages. It can be useful to put the model of a new language into the
context of the models of other languages, both to quickly understand the
new model, and to get a better feeling for the programming language
design space.</p>
<p>This chapter explores the implementation of a series of very simple
object models. It starts out with simple instances and classes, and the
ability to call methods on instances. This is the &quot;classical&quot;
object-oriented approach that was established in early OO languages such
as Simula 67 and Smalltalk. This model is then extended step by step,
the next two steps exploring different language design choices, and the
last step improving the efficiency of the object model. The final model
is not that of a real language, but an idealized, simplified version of
Python's object model.</p>
<p>The object models presented in this chapter will be implemented in
Python. The code works on both Python 2.7 and 3.4. To understand the
behaviour and the design choices better, the chapter will also present
tests for the object model. The tests can be run with either py.test or
nose.</p>
<p>The choice of Python as an implementation language is quite unrealistic.
A &quot;real&quot; VM is typically implemented in a low-level language like C/C++
and needs a lot of attention to engineering detail to make it efficient.
However, the simpler implementation language makes it easier to focus on
actual behaviour differences instead of getting bogged down by
implementation details.</p>
<p class="rubric" id="method-based-model">Method-Based Model</p>
<p>The object model we will start out with is an extremely simplified
version of that of Smalltalk. Smalltalk was an object-oriented
programming language designed by Alan Kay's group at Xerox PARC in the
1970s. It popularized object-oriented programming, and is the source of
many features found in today's programming languages. One of the core
tenets of Smalltalk's language design was &quot;everything is an object&quot;.
Smalltalk's most immediate successor in use today is Ruby, which uses a
more C-like syntax but retains most of Smalltalk's object model.</p>
<p>The object model in this section will have classes and instances of
them, the ability to read and write attributes into objects, the ability
to call methods on objects, and the ability for a class to be a subclass
of another class. Right from the beginning, classes will be completely
ordinary objects that can themselves have attributes and methods.</p>
<p>A note on terminology: In this chapter I will use the word &quot;instance&quot; to
mean -&quot;an object that is not a class&quot;.</p>
<p>A good approach to start with is to write a test to specify what the
to-be-implemented behaviour should be. All tests presented in this
chapter will consist of two parts. First, a bit of regular Python code
defining and using a few classes, and making use of increasingly
advanced features of the Python object model. Second, the corresponding
test using the object model we will implement in this chapter, instead
of normal Python classes.</p>
<p>The mapping between using normal Python classes and using our object
model will be done manually in the tests. For example, instead of
writing <code class="docutils literal"><span class="pre">obj.attribute</span></code> in Python, in the object model we would use a
method <code class="docutils literal"><span class="pre">obj.read_attr(&quot;attribute&quot;)</span></code>. This mapping would, in a real
language implementation, be done by the interpreter of the language, or
a compiler.</p>
<p>A further simplification in this chapter is that we make no sharp
distinction between the code that implements the object model and the
code that is used to write the methods used in the objects. In a real
system, the two would often be implemented in different programming
languages.</p>
<p>Let us start with a simple test for reading and writing object fields.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_read_write_field</span><span class="p">():</span>
    <span class="c1"># Python code</span>
    <span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">obj</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">b</span> <span class="o">==</span> <span class="mi">5</span>

    <span class="n">obj</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">b</span> <span class="o">==</span> <span class="mi">5</span>

    <span class="c1"># Object model code</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">OBJECT</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{},</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>

    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</pre></div>
</div>
<p>The test uses three things that we have to implement. The classes
<code class="docutils literal"><span class="pre">Class</span></code> and <code class="docutils literal"><span class="pre">Instance</span></code> represent classes and instances of our object
model, respectively. There are two special instances of class:
<code class="docutils literal"><span class="pre">OBJECT</span></code> and <code class="docutils literal"><span class="pre">TYPE</span></code>. <code class="docutils literal"><span class="pre">OBJECT</span></code> corresponds to <code class="docutils literal"><span class="pre">object</span></code> in Python
and is the ultimate base class of the inheritance hierarchy. <code class="docutils literal"><span class="pre">TYPE</span></code>
corresponds to <code class="docutils literal"><span class="pre">type</span></code> in Python and is the type of all classes.</p>
<p>To do anything with instances of <code class="docutils literal"><span class="pre">Class</span></code> and <code class="docutils literal"><span class="pre">Instance</span></code>, they
implement a shared interface by inheriting from a shared base class
<code class="docutils literal"><span class="pre">Base</span></code> that exposes a number of methods:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; The base class that all of the object model classes inherit from. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Every object has a class. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls</span> <span class="o">=</span> <span class="n">cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span> <span class="o">=</span> <span class="n">fields</span>

    <span class="k">def</span> <span class="nf">read_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; read field &#39;fieldname&#39; out of the object &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_dict</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; write field &#39;fieldname&#39; into the object &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_dict</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return True if the object is an instance of class cls &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">issubclass</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">callmethod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methname</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; call method &#39;methname&#39; with arguments &#39;args&#39; on object &quot;&quot;&quot;</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">_read_from_class</span><span class="p">(</span><span class="n">methname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; read an field &#39;fieldname&#39; out of the object&#39;s dict &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">MISSING</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; write a field &#39;fieldname&#39; into the object&#39;s dict &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="n">MISSING</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">Base</span></code> class implements storing the class of an object, and a
dictionary containing the field values of the object. Now we need to
implement <code class="docutils literal"><span class="pre">Class</span></code> and <code class="docutils literal"><span class="pre">Instance</span></code>. The constructor of <code class="docutils literal"><span class="pre">Instance</span></code>
takes the class to be instantiated and initializes the <code class="docutils literal"><span class="pre">fields</span></code>
<code class="docutils literal"><span class="pre">dict</span></code> as an empty dictionary. Otherwise <code class="docutils literal"><span class="pre">Instance</span></code> is just a very
thin subclass around <code class="docutils literal"><span class="pre">Base</span></code> that does not add any extra functionality.</p>
<p>The constructor of <code class="docutils literal"><span class="pre">Class</span></code> takes the name of the class, the base
class, the dictionary of the class and the metaclass. For classes, the
fields are passed into the constructor by the user of the object model.
The class constructor also takes a base class, which the tests so far
don't need but which we will make use of in the next section.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Instance</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Instance of a user-defined class. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">Class</span><span class="p">)</span>
        <span class="n">Base</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="p">{})</span>


<span class="k">class</span> <span class="nc">Class</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A User-defined class. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">base_class</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">metaclass</span><span class="p">):</span>
        <span class="n">Base</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metaclass</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_class</span> <span class="o">=</span> <span class="n">base_class</span>
</pre></div>
</div>
<p>Since classes are also a kind of object, they (indirectly) inherit from
<code class="docutils literal"><span class="pre">Base</span></code>. Thus, the class needs to be an instance of another class: its
metaclass.</p>
<p>Now our first test almost passes. The only missing bit is the definition
of the base classes <code class="docutils literal"><span class="pre">TYPE</span></code> and <code class="docutils literal"><span class="pre">OBJECT</span></code>, which are both instances of
<code class="docutils literal"><span class="pre">Class</span></code>. For these we will make a major departure from the Smalltalk
model, which has a fairly complex metaclass system. Instead we will use
the model introduced in ObjVlisp<a class="reference external" href="#fn1">:sup:`1`</a>, which Python adopted.</p>
<p>In the ObjVlisp model, <code class="docutils literal"><span class="pre">OBJECT</span></code> and <code class="docutils literal"><span class="pre">TYPE</span></code> are intertwined.
<code class="docutils literal"><span class="pre">OBJECT</span></code> is the base class of all classes, meaning it has no base
class. <code class="docutils literal"><span class="pre">TYPE</span></code> is a subclass of <code class="docutils literal"><span class="pre">OBJECT</span></code>. By default, every class is
an instance of <code class="docutils literal"><span class="pre">TYPE</span></code>. In particular, both <code class="docutils literal"><span class="pre">TYPE</span></code> and <code class="docutils literal"><span class="pre">OBJECT</span></code> are
instances of <code class="docutils literal"><span class="pre">TYPE</span></code>. However, the programmer can also subclass
<code class="docutils literal"><span class="pre">TYPE</span></code> to make a new metaclass:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># set up the base hierarchy as in Python (the ObjVLisp model)</span>
<span class="c1"># the ultimate base class is OBJECT</span>
<span class="n">OBJECT</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{},</span> <span class="n">metaclass</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="c1"># TYPE is a subclass of OBJECT</span>
<span class="n">TYPE</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">OBJECT</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{},</span> <span class="n">metaclass</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="c1"># TYPE is an instance of itself</span>
<span class="n">TYPE</span><span class="o">.</span><span class="n">cls</span> <span class="o">=</span> <span class="n">TYPE</span>
<span class="c1"># OBJECT is an instance of TYPE</span>
<span class="n">OBJECT</span><span class="o">.</span><span class="n">cls</span> <span class="o">=</span> <span class="n">TYPE</span>
</pre></div>
</div>
<p>To define new metaclasses, it is enough to subclass <code class="docutils literal"><span class="pre">TYPE</span></code>. However,
in the rest of this chapter we won't do that; we'll simply always use
<code class="docutils literal"><span class="pre">TYPE</span></code> as the metaclass of every class.</p>
<div class="center figure"><p><img alt="Figure 14.1 - Inheritance" src="chapters/objmodel-images/inheritance.png" /></p>
</div><p>Figure 14.1 - Inheritance</p>
<p>Now the first test passes. The second test checks that reading and
writing attributes works on classes as well. It's easy to write, and
passes immediately.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_read_write_field_class</span><span class="p">():</span>
    <span class="c1"># classes are objects too</span>
    <span class="c1"># Python code</span>
    <span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="n">A</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">A</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">6</span>

    <span class="c1"># Object model code</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">OBJECT</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">A</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</pre></div>
</div>
<p class="rubric" id="isinstance-checking"><code class="docutils literal"><span class="pre">isinstance</span></code> Checking</p>
<p>So far we haven't taken advantage of the fact that objects have classes.
The next test implements the <code class="docutils literal"><span class="pre">isinstance</span></code> machinery:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_isinstance</span><span class="p">():</span>
    <span class="c1"># Python code</span>
    <span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="c1"># Object model code</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">OBJECT</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{},</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{},</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">b</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">b</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">b</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">OBJECT</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span><span class="n">TYPE</span><span class="p">)</span>
</pre></div>
</div>
<p>To check whether an object <code class="docutils literal"><span class="pre">obj</span></code> is an instance of a certain class
<code class="docutils literal"><span class="pre">cls</span></code>, it is enough to check whether <code class="docutils literal"><span class="pre">cls</span></code> is a superclass of the
class of <code class="docutils literal"><span class="pre">obj</span></code>, or the class itself. To check whether a class is a
superclass of another class, the chain of superclasses of that class is
walked. If and only if the other class is found in that chain, it is a
superclass. The chain of superclasses of a class, including the class
itself, is called the &quot;method resolution order&quot; of that class. It can
easily be computed recursively:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Class</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">method_resolution_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; compute the method resolution order of the class &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_class</span><span class="o">.</span><span class="n">method_resolution_order</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; is self a subclass of cls? &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_resolution_order</span><span class="p">()</span>
</pre></div>
</div>
<p>With that code, the test passes.</p>
<p class="rubric" id="calling-methods">Calling Methods</p>
<p>The remaining missing feature for this first version of the object model
is the ability to call methods on objects. In this chapter we will
implement a simple single inheritance model.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_callmethod_simple</span><span class="p">():</span>
    <span class="c1"># Python code</span>
    <span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">f</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span>

    <span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">f</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="c1"># works on subclass too</span>

    <span class="c1"># Object model code</span>
    <span class="k">def</span> <span class="nf">f_A</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">OBJECT</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="n">f_A</span><span class="p">},</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">callmethod</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

    <span class="n">B</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{},</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">callmethod</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>To find the correct implementation of a method that is sent to an
object, we walk the method resolution order of the class of the object.
The first method found in the dictionary of one of the classes in the
method resolution order is called:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Class</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">_read_from_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methname</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_resolution_order</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">methname</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">methname</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">MISSING</span>
</pre></div>
</div>
<p>Together with the code for <code class="docutils literal"><span class="pre">callmethod</span></code> in the <code class="docutils literal"><span class="pre">Base</span></code>
implementation, this passes the test.</p>
<p>To make sure that methods with arguments work as well, and that
overriding of methods is implemented correctly, we can use the following
slightly more complex test, which already passes:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_callmethod_subclassing_and_arguments</span><span class="p">():</span>
    <span class="c1"># Python code</span>
    <span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">arg</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>

    <span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">arg</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">12</span>

    <span class="c1"># Object model code</span>
    <span class="k">def</span> <span class="nf">g_A</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">arg</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">OBJECT</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="n">g_A</span><span class="p">},</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">callmethod</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>

    <span class="k">def</span> <span class="nf">g_B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">arg</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="n">g_B</span><span class="p">},</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">callmethod</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">12</span>
</pre></div>
</div>
<p class="rubric" id="attribute-based-model">Attribute-Based Model</p>
<p>Now that the simplest version of our object model is working, we can
think of ways to change it. This section will introduce the distinction
between a method-based model and an attribute-based model. This is one
of the core differences between Smalltalk, Ruby, and JavaScript on the
one hand and Python and Lua on the other hand.</p>
<p>The method-based model has the method-calling as the primitive of
program execution:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
</pre></div>
</div>
<p>The attribute-based model splits up method calling into two steps:
looking up an attribute and calling the result:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">method</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">f</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
</pre></div>
</div>
<p>This difference can be shown in the following test:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_bound_method</span><span class="p">():</span>
    <span class="c1"># Python code</span>
    <span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">f</span>
    <span class="k">assert</span> <span class="n">m</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span>

    <span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">f</span>
    <span class="k">assert</span> <span class="n">m</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">12</span> <span class="c1"># works on subclass too</span>

    <span class="c1"># Object model code</span>
    <span class="k">def</span> <span class="nf">f_A</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">OBJECT</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="n">f_A</span><span class="p">},</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">m</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span>

    <span class="n">B</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{},</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">m</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">12</span>
</pre></div>
</div>
<p>While the setup is the same as the corresponding test for method calls,
the way that the methods are called is different. First, the attribute
with the name of the method is looked up on the object. The result of
that lookup operation is a <em>bound method</em>, an object that encapsulates
both the object as well as the function found in the class. Next, that
bound method is called with a call operation<a class="reference external" href="#fn2">:sup:`2`</a>.</p>
<p>To implement this behaviour, we need to change the <code class="docutils literal"><span class="pre">Base.read_attr</span></code>
implementation. If the attribute is not found in the dictionary, it is
looked for in the class. If it is found in the class, and the attribute
is a callable, it needs to be turned into a bound method. To emulate a
bound method we simply use a closure. In addition to changing
<code class="docutils literal"><span class="pre">Base.read_attr</span></code> we can also change <code class="docutils literal"><span class="pre">Base.callmethod</span></code> to use the new
approach to calling methods to make sure all the tests still pass.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">read_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; read field &#39;fieldname&#39; out of the object &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_dict</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MISSING</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">_read_from_class</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_is_bindable</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_make_boundmethod</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MISSING</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">callmethod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methname</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; call method &#39;methname&#39; with arguments &#39;args&#39; on object &quot;&quot;&quot;</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="n">methname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_is_bindable</span><span class="p">(</span><span class="n">meth</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">callable</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_make_boundmethod</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">bound</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bound</span>
</pre></div>
</div>
<p>The rest of the code does not need to be changed at all.</p>
<p class="rubric" id="meta-object-protocols">Meta-Object Protocols</p>
<p>In addition to &quot;normal&quot; methods that are called directly by the program,
many dynamic languages support <em>special methods</em>. These are methods that
aren't meant to be called directly but will be called by the object
system. In Python those special methods usually have names that start
and end with two underscores; e.g., <code class="docutils literal"><span class="pre">__init__</span></code>. Special methods can be
used to override primitive operations and provide custom behaviour for
them instead. Thus, they are hooks that tell the object model machinery
exactly how to do certain things. Python's object model has <a class="reference external" href="https://docs.python.org/2/reference/datamodel.html#special-method-names">dozens of
special methods</a>.</p>
<p>Meta-object protocols were introduced by Smalltalk, but were used even
more by the object systems for Common Lisp, such as CLOS. That is also
where the name <em>meta-object protocol</em>, for collections of special
methods, was coined<a class="reference external" href="#fn3">:sup:`3`</a>.</p>
<p>In this chapter we will add three such meta-hooks to our object model.
They are used to fine-tune what exactly happens when reading and writing
attributes. The special methods we will add first are <code class="docutils literal"><span class="pre">__getattr__</span></code>
and <code class="docutils literal"><span class="pre">__setattr__</span></code>, which closely follow the behaviour of Python's
namesakes.</p>
<p class="rubric" id="customizing-reading-and-writing-and-attribute">Customizing Reading and Writing and Attribute</p>
<p>The method <code class="docutils literal"><span class="pre">__getattr__</span></code> is called by the object model when the
attribute that is being looked up is not found by normal means; i.e.,
neither on the instance nor on the class. It gets the name of the
attribute being looked up as an argument. An equivalent of the
<code class="docutils literal"><span class="pre">__getattr__</span></code> special method was part of early Smalltalk<a class="reference external" href="#fn4">:sup:`4`</a>
systems under the name <code class="docutils literal"><span class="pre">doesNotUnderstand:</span></code>.</p>
<p>The case of <code class="docutils literal"><span class="pre">__setattr__</span></code> is a bit different. Since setting an
attribute always creates it, <code class="docutils literal"><span class="pre">__setattr__</span></code> is always called when
setting an attribute. To make sure that a <code class="docutils literal"><span class="pre">__setattr__</span></code> method always
exists, the <code class="docutils literal"><span class="pre">OBJECT</span></code> class has a definition of <code class="docutils literal"><span class="pre">__setattr__</span></code>. This
base implementation simply does what setting an attribute did so far,
which is write the attribute into the object's dictionary. This also
makes it possible for a user-defined <code class="docutils literal"><span class="pre">__setattr__</span></code> to delegate to the
base <code class="docutils literal"><span class="pre">OBJECT.__setattr__</span></code> in some cases.</p>
<p>A test for these two special methods is the following:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_getattr</span><span class="p">():</span>
    <span class="c1"># Python code</span>
    <span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;fahrenheit&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">celsius</span> <span class="o">*</span> <span class="mf">9.</span> <span class="o">/</span> <span class="mf">5.</span> <span class="o">+</span> <span class="mi">32</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;fahrenheit&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">celsius</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mf">5.</span> <span class="o">/</span> <span class="mf">9.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># call the base implementation</span>
                <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">celsius</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">fahrenheit</span> <span class="o">==</span> <span class="mi">86</span> <span class="c1"># test __getattr__</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">celsius</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">fahrenheit</span> <span class="o">==</span> <span class="mi">104</span>

    <span class="n">obj</span><span class="o">.</span><span class="n">fahrenheit</span> <span class="o">=</span> <span class="mi">86</span> <span class="c1"># test __setattr__</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">celsius</span> <span class="o">==</span> <span class="mi">30</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">fahrenheit</span> <span class="o">==</span> <span class="mi">86</span>

    <span class="c1"># Object model code</span>
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;fahrenheit&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;celsius&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="mf">9.</span> <span class="o">/</span> <span class="mf">5.</span> <span class="o">+</span> <span class="mi">32</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;fahrenheit&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;celsius&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mf">5.</span> <span class="o">/</span> <span class="mf">9.</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># call the base implementation</span>
            <span class="n">OBJECT</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;__setattr__&quot;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">OBJECT</span><span class="p">,</span>
              <span class="n">fields</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;__getattr__&quot;</span><span class="p">:</span> <span class="n">__getattr__</span><span class="p">,</span> <span class="s2">&quot;__setattr__&quot;</span><span class="p">:</span> <span class="n">__setattr__</span><span class="p">},</span>
              <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;celsius&quot;</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;fahrenheit&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">86</span> <span class="c1"># test __getattr__</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;celsius&quot;</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;fahrenheit&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">104</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;fahrenheit&quot;</span><span class="p">,</span> <span class="mi">86</span><span class="p">)</span> <span class="c1"># test __setattr__</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;celsius&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">30</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;fahrenheit&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">86</span>
</pre></div>
</div>
<p>To pass these tests, the <code class="docutils literal"><span class="pre">Base.read_attr</span></code> and <code class="docutils literal"><span class="pre">Base.write_attr</span></code>
methods need to be changed:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">read_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; read field &#39;fieldname&#39; out of the object &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_dict</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MISSING</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">_read_from_class</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_is_bindable</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_make_boundmethod</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MISSING</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">_read_from_class</span><span class="p">(</span><span class="s2">&quot;__getattr__&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MISSING</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; write field &#39;fieldname&#39; into the object &quot;&quot;&quot;</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">_read_from_class</span><span class="p">(</span><span class="s2">&quot;__setattr__&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>The procedure for reading an attribute is changed to call the
<code class="docutils literal"><span class="pre">__getattr__</span></code> method with the fieldname as an argument, if the method
exists, instead of raising an error. Note that <code class="docutils literal"><span class="pre">__getattr__</span></code> (and
indeed all special methods in Python) is looked up on the class only,
instead of recursively calling <code class="docutils literal"><span class="pre">self.read_attr(&quot;__getattr__&quot;)</span></code>. That
is because the latter would lead to an infinite recursion of
<code class="docutils literal"><span class="pre">read_attr</span></code> if <code class="docutils literal"><span class="pre">__getattr__</span></code> were not defined on the object.</p>
<p>Writing of attributes is fully deferred to the <code class="docutils literal"><span class="pre">__setattr__</span></code> method.
To make this work, <code class="docutils literal"><span class="pre">OBJECT</span></code> needs to have a <code class="docutils literal"><span class="pre">__setattr__</span></code> method
that calls the default behaviour, as follows:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">OBJECT__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_write_dict</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="n">OBJECT</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;__setattr__&quot;</span><span class="p">:</span> <span class="n">OBJECT__setattr__</span><span class="p">},</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>The behaviour of <code class="docutils literal"><span class="pre">OBJECT__setattr__</span></code> is like the previous behaviour of
<code class="docutils literal"><span class="pre">write_attr</span></code>. With these modifications, the new test passes.</p>
<p class="rubric" id="descriptor-protocol">Descriptor Protocol</p>
<p>The above test to provide automatic conversion between different
temperature scales worked but was annoying to write, as the attribute
name needed to be checked explicitly in the <code class="docutils literal"><span class="pre">__getattr__</span></code> and
<code class="docutils literal"><span class="pre">__setattr__</span></code> methods. To get around this, the <em>descriptor protocol</em>
was introduced in Python.</p>
<p>While <code class="docutils literal"><span class="pre">__getattr__</span></code> and <code class="docutils literal"><span class="pre">__setattr__</span></code> are called on the object the
attribute is being read from, the descriptor protocol calls a special
method on the <em>result</em> of getting an attribute from an object. It can be
seen as the generalization of binding a method to an object – and
indeed, binding a method to an object is done using the descriptor
protocol. In addition to bound methods, the most important use case for
the descriptor protocol in Python is the implementation of
<code class="docutils literal"><span class="pre">staticmethod</span></code>, <code class="docutils literal"><span class="pre">classmethod</span></code> and <code class="docutils literal"><span class="pre">property</span></code>.</p>
<p>In this subsection we will introduce the subset of the descriptor
protocol which deals with binding objects. This is done using the
special method <code class="docutils literal"><span class="pre">__get__</span></code>, and is best explained with an example test:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_get</span><span class="p">():</span>
    <span class="c1"># Python code</span>
    <span class="k">class</span> <span class="nc">FahrenheitGetter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">inst</span><span class="o">.</span><span class="n">celsius</span> <span class="o">*</span> <span class="mf">9.</span> <span class="o">/</span> <span class="mf">5.</span> <span class="o">+</span> <span class="mi">32</span>

    <span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="n">fahrenheit</span> <span class="o">=</span> <span class="n">FahrenheitGetter</span><span class="p">()</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">celsius</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">fahrenheit</span> <span class="o">==</span> <span class="mi">86</span>

    <span class="c1"># Object model code</span>
    <span class="k">class</span> <span class="nc">FahrenheitGetter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">inst</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;celsius&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="mf">9.</span> <span class="o">/</span> <span class="mf">5.</span> <span class="o">+</span> <span class="mi">32</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">OBJECT</span><span class="p">,</span>
              <span class="n">fields</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fahrenheit&quot;</span><span class="p">:</span> <span class="n">FahrenheitGetter</span><span class="p">()},</span>
              <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;celsius&quot;</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">read_attr</span><span class="p">(</span><span class="s2">&quot;fahrenheit&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">86</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">__get__</span></code> method is called on the <code class="docutils literal"><span class="pre">FahrenheitGetter</span></code> instance
after that has been looked up in the class of <code class="docutils literal"><span class="pre">obj</span></code>. The arguments to
<code class="docutils literal"><span class="pre">__get__</span></code> are the instance where the lookup was done<a class="reference external" href="#fn5">:sup:`5`</a>.</p>
<p>Implementing this behaviour is easy. We simply need to change
<code class="docutils literal"><span class="pre">_is_bindable</span></code> and <code class="docutils literal"><span class="pre">_make_boundmethod</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_is_bindable</span><span class="p">(</span><span class="n">meth</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="s2">&quot;__get__&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_make_boundmethod</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">meth</span><span class="o">.</span><span class="n">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>This makes the test pass. The previous tests about bound methods also
still pass, as Python's functions have a <code class="docutils literal"><span class="pre">__get__</span></code> method that returns
a bound method object.</p>
<p>In practice, the descriptor protocol is quite a lot more complex. It
also supports <code class="docutils literal"><span class="pre">__set__</span></code> to override what setting an attribute means on
a per-attribute basis. Also, the current implementation is cutting a few
corners. Note that <code class="docutils literal"><span class="pre">_make_boundmethod</span></code> calls the method <code class="docutils literal"><span class="pre">__get__</span></code> on
the implementation level, instead of using
<code class="docutils literal"><span class="pre">meth.read_attr(&quot;__get__&quot;)</span></code>. This is necessary since our object model
borrows functions and thus methods from Python, instead of having a
representation for them that uses the object model. A more complete
object model would have to solve this problem.</p>
<p class="rubric" id="instance-optimization">Instance Optimization</p>
<p>While the first three variants of the object model were concerned with
behavioural variation, in this last section we will look at an
optimization without any behavioural impact. This optimization is called
<em>maps</em> and was pioneered in the VM for the Self programming
language<a class="reference external" href="#fn6">:sup:`6`</a>. It is still one of the most important object
model optimizations: it's used in PyPy and all modern JavaScript VMs,
such as V8 (where the optimization is called <em>hidden classes</em>).</p>
<p>The optimization starts from the following observation: In the object
model as implemented so far all instances use a full dictionary to store
their attributes. A dictionary is implemented using a hash map, which
takes a lot of memory. In addition, the dictionaries of instances of the
same class typically have the same keys as well. For example, given a
class <code class="docutils literal"><span class="pre">Point</span></code>, the keys of all its instances' dictionaries are likely
<code class="docutils literal"><span class="pre">&quot;x&quot;</span></code> and <code class="docutils literal"><span class="pre">&quot;y&quot;</span></code>.</p>
<p>The maps optimization exploits this fact. It effectively splits up the
dictionary of every instance into two parts. A part storing the keys
(the map) that can be shared between all instances with the same set of
attribute names. The instance then only stores a reference to the shared
map and the values of the attributes in a list (which is a lot more
compact in memory than a dictionary). The map stores a mapping from
attribute names to indexes into that list.</p>
<p>A simple test of that behaviour looks like this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_maps</span><span class="p">():</span>
    <span class="c1"># white box test inspecting the implementation</span>
    <span class="n">Point</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Point&quot;</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="n">OBJECT</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">{},</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span>
    <span class="n">p1</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">p1</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">p1</span><span class="o">.</span><span class="n">storage</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">p1</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">attrs</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

    <span class="n">p2</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span>
    <span class="n">p2</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">p2</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">p1</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="n">p2</span><span class="o">.</span><span class="n">map</span>
    <span class="k">assert</span> <span class="n">p2</span><span class="o">.</span><span class="n">storage</span> <span class="o">==</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>

    <span class="n">p1</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">p1</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">p1</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="n">p2</span><span class="o">.</span><span class="n">map</span>
    <span class="k">assert</span> <span class="n">p1</span><span class="o">.</span><span class="n">storage</span> <span class="o">==</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">p3</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span>
    <span class="n">p3</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">p3</span><span class="o">.</span><span class="n">write_attr</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">343</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">p3</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">p1</span><span class="o">.</span><span class="n">map</span>
    <span class="k">assert</span> <span class="n">p3</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">attrs</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
</pre></div>
</div>
<p>Note that this is a different flavour of test than the ones we've
written before. All previous tests just tested the behaviour of the
classes via the exposed interfaces. This test instead checks the
implementation details of the <code class="docutils literal"><span class="pre">Instance</span></code> class by reading internal
attributes and comparing them to predefined values. Therefore this test
can be called a <em>white-box</em> test.</p>
<p>The <code class="docutils literal"><span class="pre">attrs</span></code> attribute of the map of <code class="docutils literal"><span class="pre">p1</span></code> describes the layout of the
instance as having two attributes <code class="docutils literal"><span class="pre">&quot;x&quot;</span></code> and <code class="docutils literal"><span class="pre">&quot;y&quot;</span></code> which are stored
at position 0 and 1 of the <code class="docutils literal"><span class="pre">storage</span></code> of <code class="docutils literal"><span class="pre">p1</span></code>. Making a second
instance <code class="docutils literal"><span class="pre">p2</span></code> and adding to it the same attributes in the same order
will make it end up with the same map. If, on the other hand, a
different attribute is added, the map can of course not be shared.</p>
<p>The <code class="docutils literal"><span class="pre">Map</span></code> class looks like this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Map</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">attrs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_maps</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">get_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">next_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">fieldname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span>
        <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_maps</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_maps</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">attrs</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_maps</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="n">EMPTY_MAP</span> <span class="o">=</span> <span class="n">Map</span><span class="p">({})</span>
</pre></div>
</div>
<p>Maps have two methods, <code class="docutils literal"><span class="pre">get_index</span></code> and <code class="docutils literal"><span class="pre">next_map</span></code>. The former is
used to find the index of an attribute name in the object's storage. The
latter is used when a new attribute is added to an object. In that case
the object needs to use a different map, which <code class="docutils literal"><span class="pre">next_map</span></code> computes.
The method uses the <code class="docutils literal"><span class="pre">next_maps</span></code> dictionary to cache already created
maps. That way, objects that have the same layout also end up using the
same <code class="docutils literal"><span class="pre">Map</span></code> object.</p>
<div class="center figure"><p><img alt="Figure 14.2 - Map transitions" src="chapters/objmodel-images/maptransition.png" /></p>
</div><p>Figure 14.2 - Map transitions</p>
<p>The <code class="docutils literal"><span class="pre">Instance</span></code> implementation that uses maps looks like this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Instance</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Instance of a user-defined class. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">Class</span><span class="p">)</span>
        <span class="n">Base</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">EMPTY_MAP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">storage</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_read_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MISSING</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_write_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">next_map</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">new_map</span>
</pre></div>
</div>
<p>The class now passes <code class="docutils literal"><span class="pre">None</span></code> as the fields dictionary to <code class="docutils literal"><span class="pre">Base</span></code>, as
<code class="docutils literal"><span class="pre">Instance</span></code> will store the content of the dictionary in another way.
Therefore it needs to override the <code class="docutils literal"><span class="pre">_read_dict</span></code> and <code class="docutils literal"><span class="pre">_write_dict</span></code>
methods. In a real implementation, we would refactor the <code class="docutils literal"><span class="pre">Base</span></code> class
so that it is no longer responsible for storing the fields dictionary,
but for now having instances store <code class="docutils literal"><span class="pre">None</span></code> there is good enough.</p>
<p>A newly created instance starts out using the <code class="docutils literal"><span class="pre">EMPTY_MAP</span></code>, which has
no attributes, and empty storage. To implement <code class="docutils literal"><span class="pre">_read_dict</span></code>, the
instance's map is asked for the index of the attribute name. Then the
corresponding entry of the storage list is returned.</p>
<p>Writing into the fields dictionary has two cases. On the one hand the
value of an existing attribute can be changed. This is done by simply
changing the storage at the corresponding index. On the other hand, if
the attribute does not exist yet, a <em>map transition</em> (<a class="reference external" href="#figure-14.2">Figure 14.2</a>) is
needed using the <code class="docutils literal"><span class="pre">next_map</span></code> method. The value of the new attribute is
appended to the storage list.</p>
<p>What does this optimization achieve? It optimizes use of memory in the
common case where there are many instances with the same layout. It is
not a universal optimization: code that creates instances with wildly
different sets of attributes will have a larger memory footprint than if
we just use dictionaries.</p>
<p>This is a common problem when optimizing dynamic languages. It is often
not possible to find optimizations that are faster or use less memory in
all cases. In practice, the optimizations chosen apply to how the
language is <em>typically</em> used, while potentially making behaviour worse
for programs that use extremely dynamic features.</p>
<p>Another interesting aspect of maps is that, while here they only
optimize for memory use, in actual VMs that use a just-in-time (JIT)
compiler they also improve the performance of the program. To achieve
that, the JIT uses the maps to compile attribute lookups to a lookup in
the objects' storage at a fixed offset, getting rid of all dictionary
lookups completely<a class="reference external" href="#fn7">:sup:`7`</a>.</p>
<p class="rubric" id="potential-extensions">Potential Extensions</p>
<p>It is easy to extend our object model and experiment with various
language design choices. Here are some possibilities:</p>
<ul class="simple">
<li>The easiest thing to do is to add further special methods. Some easy
and interesting ones to add are <code class="docutils literal"><span class="pre">__init__</span></code>, <code class="docutils literal"><span class="pre">__getattribute__</span></code>,
<code class="docutils literal"><span class="pre">__set__</span></code>.</li>
<li>The model can be very easily extended to support multiple
inheritance. To do this, every class would get a list of base
classes. Then the <code class="docutils literal"><span class="pre">Class.method_resolution_order</span></code> method would need
to be changed to support looking up methods. A simple method
resolution order could be computed using a depth-first search with
removal of duplicates. A more complicated but better one is the <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">C3
algorithm</a>, which adds better handling in the base of diamond-shaped
multiple inheritance hierarchies and rejects insensible inheritance
patterns.</li>
<li>A more radical change is to switch to a prototype model, which
involves the removal of the distinction between classes and
instances.</li>
</ul>
<p class="rubric" id="conclusions">Conclusions</p>
<p>Some of the core aspects of the design of an object-oriented programming
language are the details of its object model. Writing small object model
prototypes is an easy and fun way to understand the inner workings of
existing languages better and to get insights into the design space of
object-oriented languages. Playing with object models is a good way to
experiment with different language design ideas without having to worry
about the more boring parts of language implementation, such as parsing
and executing code.</p>
<p>Such object models can also be useful in practice, not just as vehicles
for experimentation. They can be embedded in and used from other
languages. Examples of this approach are common: the GObject object
model, written in C, that's used in GLib and other Gnome libraries; or
the various class system implementations in JavaScript.</p>
<div class="footnotes"><hr class="docutils" />
<ol class="arabic">
<li><div class="first"><div id="fn1"></div></div><p>P. Cointe, “Metaclasses are first class: The ObjVlisp Model,” SIGPLAN
Not, vol. 22, no. 12, pp. 156–162, 1987.<a class="reference external" href="#fnref1">↩</a></p>
</li>
<li><div class="first"><div id="fn2"></div></div><p>It seems that the attribute-based model is conceptually more complex,
because it needs both method lookup and call. In practice, calling
something is defined by looking up and calling a special attribute
<code class="docutils literal"><span class="pre">__call__</span></code>, so conceptual simplicity is regained. This won't be
implemented in this chapter, however.)<a class="reference external" href="#fnref2">↩</a></p>
</li>
<li><div class="first"><div id="fn3"></div></div><p>G. Kiczales, J. des Rivieres, and D. G. Bobrow, The Art of the
Metaobject Protocol. Cambridge, Mass: The MIT Press,
1991.<a class="reference external" href="#fnref3">↩</a></p>
</li>
<li><div class="first"><div id="fn4"></div></div><p>A. Goldberg, Smalltalk-80: The Language and its Implementation.
Addison-Wesley, 1983, page 61.<a class="reference external" href="#fnref4">↩</a></p>
</li>
<li><div class="first"><div id="fn5"></div></div><p>In Python the second argument is the class where the attribute was
found, though we will ignore that here.<a class="reference external" href="#fnref5">↩</a></p>
</li>
<li><div class="first"><div id="fn6"></div></div><p>C. Chambers, D. Ungar, and E. Lee, “An efficient implementation of
SELF, a dynamically-typed object-oriented language based on
prototypes,” in OOPSLA, 1989, vol. 24.<a class="reference external" href="#fnref6">↩</a></p>
</li>
<li><div class="first"><div id="fn7"></div></div><p>How that works is beyond the scope of this chapter. I tried to give a
reasonably readable account of it in a paper I wrote a few years ago.
It uses an object model that is basically a variant of the one in
this chapter: C. F. Bolz, A. Cuni, M. Fijałkowski, M. Leuschel, S.
Pedroni, and A. Rigo, “Runtime feedback in a meta-tracing JIT for
efficient dynamic languages,” in Proceedings of the 6th Workshop on
Implementation, Compilation, Optimization of Object-Oriented
Languages, Programs and Systems, New York, NY, USA, 2011, pp.
9:1–9:8.<a class="reference external" href="#fnref7">↩</a></p>
</li>
</ol>
</div></div></div></div></div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Learn-Computer-and-Math-again</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="blockcode-a-visual-programming-toolkit.html">500 Lines or Less | Blockcode: A visual programming toolkit</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, timger.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/chapters/a-simple-object-model.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>