
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>500 Lines or Less | A Template Engine &#8212; Learn-Computer-and-Math-again 0.0.1 文档</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lines-or-less-a-template-engine">
<h1>500 Lines or Less | A Template Engine<a class="headerlink" href="#lines-or-less-a-template-engine" title="永久链接至标题">¶</a></h1>
<div class="container"><div class="row"><div class="hero-unit"><p><a href="#id1"><span class="problematic" id="id2">``</span></a>_
.. rubric:: A Template Engine</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">a-template-engine</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p class="author rubric" id="ned-batchelder">Ned Batchelder</p>
</div></div><div class="row"><div id="content" class="span10 offset1"><p><em>Ned Batchelder is a software engineer with a long career, currently
working at edX to build open source software to educate the world. He's
the maintainer of coverage.py, an organizer of Boston Python, and has
spoken at many PyCons. He blogs at http://nedbatchelder.com. He once had
dinner at the White House.</em></p>
<p class="rubric" id="introduction">Introduction</p>
<p>Most programs contain a lot of logic, and a little bit of literal
textual data. Programming languages are designed to be good for this
sort of programming. But some programming tasks involve only a little
bit of logic, and a great deal of textual data. For these tasks, we'd
like to have a tool better suited to these text-heavy problems. A
template engine is such a tool. In this chapter, we build a simple
template engine.</p>
<p>The most common example of one of these text-heavy tasks is in web
applications. An important phase in any web application is generating
HTML to be served to the browser. Very few HTML pages are completely
static: they involve at least a small amount of dynamic data, such as
the user's name. Usually, they contain a great deal of dynamic data:
product listings, friends' news updates, and so on.</p>
<p>At the same time, every HTML page contains large swaths of static text.
And these pages are large, containing tens of thousands of bytes of
text. The web application developer has a problem to solve: how best to
generate a large string containing a mix of static and dynamic data? To
add to the problem, the static text is actually HTML markup that is
authored by another member of the team, the front-end designer, who
wants to be able to work with it in familiar ways.</p>
<p>For purposes of illustration, let's imagine we want to produce this toy
HTML:</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span>&lt;p&gt;Welcome, Charlie!&lt;/p&gt;
&lt;p&gt;Products:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Apple: $1.00&lt;/li&gt;
    &lt;li&gt;Fig: $1.50&lt;/li&gt;
    &lt;li&gt;Pomegranate: $3.25&lt;/li&gt;
&lt;/ul&gt;
</pre></div>
</div>
<p>Here, the user's name will be dynamic, as will the names and prices of
the products. Even the number of products isn't fixed: at another
moment, there could be more or fewer products to display.</p>
<p>One way to make this HTML would be to have string constants in our code,
and join them together to produce the page. Dynamic data would be
inserted with string substitution of some sort. Some of our dynamic data
is repetitive, like our lists of products. This means we'll have chunks
of HTML that repeat, so those will have to be handled separately and
combined with the rest of the page.</p>
<p>Producing our toy page in this way might look like this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># The main HTML for the whole page.</span>
<span class="n">PAGE_HTML</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;p&gt;Welcome, </span><span class="si">{name}</span><span class="s2">!&lt;/p&gt;</span>
<span class="s2">&lt;p&gt;Products:&lt;/p&gt;</span>
<span class="s2">&lt;ul&gt;</span>
<span class="si">{products}</span><span class="s2"></span>
<span class="s2">&lt;/ul&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="c1"># The HTML for each product displayed.</span>
<span class="n">PRODUCT_HTML</span> <span class="o">=</span> <span class="s2">&quot;&lt;li&gt;</span><span class="si">{prodname}</span><span class="s2">: </span><span class="si">{price}</span><span class="s2">&lt;/li&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>

<span class="k">def</span> <span class="nf">make_page</span><span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="n">products</span><span class="p">):</span>
    <span class="n">product_html</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">prodname</span><span class="p">,</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">products</span><span class="p">:</span>
        <span class="n">product_html</span> <span class="o">+=</span> <span class="n">PRODUCT_HTML</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">prodname</span><span class="o">=</span><span class="n">prodname</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="n">format_price</span><span class="p">(</span><span class="n">price</span><span class="p">))</span>
    <span class="n">html</span> <span class="o">=</span> <span class="n">PAGE_HTML</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">username</span><span class="p">,</span> <span class="n">products</span><span class="o">=</span><span class="n">product_html</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">html</span>
</pre></div>
</div>
<p>This works, but we have a mess on our hands. The HTML is in multiple
string constants embedded in our application code. The logic of the page
is hard to see because the static text is broken into separate pieces.
The details of how data is formatted is lost in the Python code. In
order to modify the HTML page, our front-end designer would need to be
able to edit Python code to make HTML changes. Imagine what the code
would look like if the page were ten (or one hundred) times more
complicated; it would quickly become unworkable.</p>
<p class="rubric" id="templates">Templates</p>
<p>The better way to produce HTML pages is with <em>templates</em>. The HTML page
is authored as a template, meaning that the file is mostly static HTML,
with dynamic pieces embedded in it using special notation. Our toy page
above could look like this as a template:</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span>&lt;p&gt;Welcome, {{user_name}}!&lt;/p&gt;
&lt;p&gt;Products:&lt;/p&gt;
&lt;ul&gt;
{% for product in product_list %}
    &lt;li&gt;{{ product.name }}:
        {{ product.price|format_price }}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</pre></div>
</div>
<p>Here the focus is on the HTML text, with logic embedded in the HTML.
Contrast this document-centric approach with our logic-centric code
above. Our earlier program was mostly Python code, with HTML embedded in
the Python logic. Here our program is mostly static HTML markup.</p>
<p>The mostly-static style used in templates is the opposite of how most
programming languages work. For example, with Python, most of the source
file is executable code, and if you need literal static text, you embed
it in a string literal:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hello, world!&quot;</span><span class="p">)</span>

<span class="n">hello</span><span class="p">()</span>
</pre></div>
</div>
<p>When Python reads this source file, it interprets text like
<code class="docutils literal"><span class="pre">def</span> <span class="pre">hello():</span></code> as instructions to be executed. The double quote
character in <code class="docutils literal"><span class="pre">print(&quot;Hello,</span> <span class="pre">world!&quot;)</span></code> indicates that the following
text is meant literally, until the closing double quote. This is how
most programming languages work: mostly dynamic, with some static pieces
embedded in the instructions. The static pieces are indicated by the
double-quote notation.</p>
<p>A template language flips this around: the template file is mostly
static literal text, with special notation to indicate the executable
dynamic parts.</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span>&lt;p&gt;Welcome, {{user_name}}!&lt;/p&gt;
</pre></div>
</div>
<p>Here the text is meant to appear literally in the resulting HTML page,
until the '<code class="docutils literal"><span class="pre">{{</span></code>' indicates a switch into dynamic mode, where the
<code class="docutils literal"><span class="pre">user_name</span></code> variable will be substituted into the output.</p>
<p>String formatting functions such as Python's
<code class="docutils literal"><span class="pre">&quot;foo</span> <span class="pre">=</span> <span class="pre">{foo}!&quot;.format(foo=17)</span></code> are examples of mini-languages used to
create text from a string literal and the data to be inserted. Templates
extend this idea to include constructs like conditionals and loops, but
the difference is only of degree.</p>
<p>These files are called templates because they are used to produce many
pages with similar structure but differing details.</p>
<p>To use HTML templates in our programs, we need a <em>template engine</em>: a
function that takes a static template describing the structure and
static content of the page, and a dynamic <em>context</em> that provides the
dynamic data to plug into the template. The template engine combines the
template and the context to produce a complete string of HTML. The job
of a template engine is to interpret the template, replacing the dynamic
pieces with real data.</p>
<p>By the way, there's often nothing particular about HTML in a template
engine, it could be used to produce any textual result. For example,
they are also used to produce plain-text email messages. But usually
they are used for HTML, and occasionally have HTML-specific features,
such as escaping, which makes it possible to insert values into the HTML
without worrying about which characters are special in HTML.</p>
<p class="rubric" id="supported-syntax">Supported Syntax</p>
<p>Template engines vary in the syntax they support. Our template syntax is
based on Django, a popular web framework. Since we are implementing our
engine in Python, some Python concepts will appear in our syntax. We've
already seen some of this syntax in our toy example at the top of the
chapter, but this is a quick summary of all of the syntax we'll
implement.</p>
<p>Data from the context is inserted using double curly braces:</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span>&lt;p&gt;Welcome, {{user_name}}!&lt;/p&gt;
</pre></div>
</div>
<p>The data available to the template is provided in the context when the
template is rendered. More on that later.</p>
<p>Template engines usually provide access to elements within data using a
simplified and relaxed syntax. In Python, these expressions all have
different effects:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>
<span class="n">obj</span><span class="o">.</span><span class="n">attr</span>
<span class="n">obj</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
</pre></div>
</div>
<p>In our template syntax, all of these operations are expressed with a
dot:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="o">.</span><span class="n">key</span>
<span class="n">obj</span><span class="o">.</span><span class="n">attr</span>
<span class="n">obj</span><span class="o">.</span><span class="n">method</span>
</pre></div>
</div>
<p>The dot will access object attributes or dictionary values, and if the
resulting value is callable, it's automatically called. This is
different than the Python code, where you need to use different syntax
for those operations. This results in simpler template syntax:</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">price</span> <span class="ow">is</span><span class="p">:</span> <span class="p">{{</span><span class="n">product</span><span class="o">.</span><span class="n">price</span><span class="p">}},</span> <span class="k">with</span> <span class="n">a</span> <span class="p">{{</span><span class="n">product</span><span class="o">.</span><span class="n">discount</span><span class="p">}}</span><span class="o">%</span> <span class="n">discount</span><span class="o">.&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>You can use functions called <em>filters</em> to modify values. Filters are
invoked with a pipe character:</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Short</span> <span class="n">name</span><span class="p">:</span> <span class="p">{{</span><span class="n">story</span><span class="o">.</span><span class="n">subject</span><span class="o">|</span><span class="n">slugify</span><span class="o">|</span><span class="n">lower</span><span class="p">}}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Building interesting pages usually requires at least a small amount of
decision-making, so conditionals are available:</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span>{% if user.is_logged_in %}
    &lt;p&gt;Welcome, {{ user.name }}!&lt;/p&gt;
{% endif %}
</pre></div>
</div>
<p>Looping lets us include collections of data in our pages:</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Products</span><span class="p">:</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="p">{</span><span class="o">%</span> <span class="k">for</span> <span class="n">product</span> <span class="ow">in</span> <span class="n">product_list</span> <span class="o">%</span><span class="p">}</span>
    <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">{{</span> <span class="n">product</span><span class="o">.</span><span class="n">name</span> <span class="p">}}:</span> <span class="p">{{</span> <span class="n">product</span><span class="o">.</span><span class="n">price</span><span class="o">|</span><span class="n">format_price</span> <span class="p">}}</span><span class="o">&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
<span class="p">{</span><span class="o">%</span> <span class="n">endfor</span> <span class="o">%</span><span class="p">}</span>
<span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>As with other programming languages, conditionals and loops can be
nested to build complex logical structures.</p>
<p>Lastly, so that we can document our templates, comments appear between
brace-hashes:</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="c1"># This is the best template ever! #}</span>
</pre></div>
</div>
<p class="rubric" id="implementation-approaches">Implementation Approaches</p>
<p>In broad strokes, the template engine will have two main phases:
<em>parsing</em> the template, and then <em>rendering</em> the template.</p>
<p>Rendering the template specifically involves:</p>
<ul class="simple">
<li>Managing the dynamic context, the source of the data</li>
<li>Executing the logic elements</li>
<li>Implementing dot access and filter execution</li>
</ul>
<p>The question of what to pass from the parsing phase to the rendering
phase is key. What does parsing produce that can be rendered? There are
two main options; we'll call them <em>interpretation</em> and <em>compilation</em>,
using the terms loosely from other language implementations.</p>
<p>In an interpretation model, parsing produces a data structure
representing the structure of the template. The rendering phase walks
that data structure, assembling the result text based on the
instructions it finds. For a real-world example, the Django template
engine uses this approach.</p>
<p>In a compilation model, parsing produces some form of directly
executable code. The rendering phase executes that code, producing the
result. Jinja2 and Mako are two examples of template engines that use
the compilation approach.</p>
<p>Our implementation of the engine uses compilation: we compile the
template into Python code. When run, the Python code assembles the
result.</p>
<p>The template engine described here was originally written as part of
coverage.py, to produce HTML reports. In coverage.py, there are only a
few templates, and they are used over and over to produce many files
from the same template. Overall, the program ran faster if the templates
were compiled to Python code, because even though the compilation
process was a bit more complicated, it only had to run once, while the
execution of the compiled code ran many times, and was faster than
interpreting a data structure many times.</p>
<p>It's a bit more complicated to compile the template to Python, but it's
not as bad as you might think. And besides, as any developer can tell
you, it's more fun to write a program to write a program than it is to
write a program!</p>
<p>Our template compiler is a small example of a general technique called
code generation. Code generation underlies many powerful and flexible
tools, including programming language compilers. Code generation can get
complex, but is a useful technique to have in your toolbox.</p>
<p>Another application of templates might prefer the interpreted approach,
if templates will be used only a few times each. Then the effort to
compile to Python won't pay off in the long run, and a simpler
interpretation process might perform better overall.</p>
<p class="rubric" id="compiling-to-python">Compiling to Python</p>
<p>Before we get to the code of the template engine, let's look at the code
it produces. The parsing phase will convert a template into a Python
function. Here is our small template again:</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span>&lt;p&gt;Welcome, {{user_name}}!&lt;/p&gt;
&lt;p&gt;Products:&lt;/p&gt;
&lt;ul&gt;
{% for product in product_list %}
    &lt;li&gt;{{ product.name }}:
        {{ product.price|format_price }}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</pre></div>
</div>
<p>Our engine will compile this template to Python code. The resulting
Python code looks unusual, because we've chosen some shortcuts that
produce slightly faster code. Here is the Python (slightly reformatted
for readability):</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">render_function</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">do_dots</span><span class="p">):</span>
    <span class="n">c_user_name</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s1">&#39;user_name&#39;</span><span class="p">]</span>
    <span class="n">c_product_list</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s1">&#39;product_list&#39;</span><span class="p">]</span>
    <span class="n">c_format_price</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s1">&#39;format_price&#39;</span><span class="p">]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">append_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span>
    <span class="n">extend_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">extend</span>
    <span class="n">to_str</span> <span class="o">=</span> <span class="nb">str</span>

    <span class="n">extend_result</span><span class="p">([</span>
        <span class="s1">&#39;&lt;p&gt;Welcome, &#39;</span><span class="p">,</span>
        <span class="n">to_str</span><span class="p">(</span><span class="n">c_user_name</span><span class="p">),</span>
        <span class="s1">&#39;!&lt;/p&gt;</span><span class="se">\n</span><span class="s1">&lt;p&gt;Products:&lt;/p&gt;</span><span class="se">\n</span><span class="s1">&lt;ul&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="p">])</span>
    <span class="k">for</span> <span class="n">c_product</span> <span class="ow">in</span> <span class="n">c_product_list</span><span class="p">:</span>
        <span class="n">extend_result</span><span class="p">([</span>
            <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">    &lt;li&gt;&#39;</span><span class="p">,</span>
            <span class="n">to_str</span><span class="p">(</span><span class="n">do_dots</span><span class="p">(</span><span class="n">c_product</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)),</span>
            <span class="s1">&#39;:</span><span class="se">\n</span><span class="s1">        &#39;</span><span class="p">,</span>
            <span class="n">to_str</span><span class="p">(</span><span class="n">c_format_price</span><span class="p">(</span><span class="n">do_dots</span><span class="p">(</span><span class="n">c_product</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">))),</span>
            <span class="s1">&#39;&lt;/li&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="p">])</span>
    <span class="n">append_result</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&lt;/ul&gt;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Each template is converted into a <code class="docutils literal"><span class="pre">render_function</span></code> function that
takes a dictionary of data called the context. The body of the function
starts by unpacking the data from the context into local names, because
they are faster for repeated use. All the context data goes into locals
with a <code class="docutils literal"><span class="pre">c_</span></code> prefix so that we can use other local names without fear
of collisions.</p>
<p>The result of the template will be a string. The fastest way to build a
string from parts is to create a list of strings, and join them together
at the end. <code class="docutils literal"><span class="pre">result</span></code> will be the list of strings. Because we're going
to add strings to this list, we capture its <code class="docutils literal"><span class="pre">append</span></code> and <code class="docutils literal"><span class="pre">extend</span></code>
methods in the local names <code class="docutils literal"><span class="pre">result_append</span></code> and <code class="docutils literal"><span class="pre">result_extend</span></code>. The
last local we create is a <code class="docutils literal"><span class="pre">to_str</span></code> shorthand for the <code class="docutils literal"><span class="pre">str</span></code> built-in.</p>
<p>These kinds of shortcuts are unusual. Let's look at them more closely.
In Python, a method call on an object like <code class="docutils literal"><span class="pre">result.append(&quot;hello&quot;)</span></code> is
executed in two steps. First, the append attribute is fetched from the
result object: <code class="docutils literal"><span class="pre">result.append</span></code>. Then the value fetched is invoked as a
function, passing it the argument <code class="docutils literal"><span class="pre">&quot;hello&quot;</span></code>. Although we're used to
seeing those steps performed together, they really are separate. If you
save the result of the first step, you can perform the second step on
the saved value. So these two Python snippets do the same thing:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># The way we&#39;re used to seeing it:</span>
<span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>

<span class="c1"># But this works the same:</span>
<span class="n">append_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span>
<span class="n">append_result</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the template engine code, we've split it out this way so that we only
do the first step once, no matter how many times we do the second step.
This saves us a small amount of time, because we avoid taking the time
to look up the append attribute.</p>
<p>This is an example of a micro-optimization: an unusual coding technique
that gains us tiny improvements in speed. Micro-optimizations can be
less readable, or more confusing, so they are only justified for code
that is a proven performance bottleneck. Developers disagree on how much
micro-optimization is justified, and some beginners overdo it. The
optimizations here were added only after timing experiments showed that
they improved performance, even if only a little bit.
Micro-optimizations can be instructive, as they make use of some exotic
aspects of Python, but don't over-use them in your own code.</p>
<p>The shortcut for <code class="docutils literal"><span class="pre">str</span></code> is also a micro-optimization. Names in Python
can be local to a function, global to a module, or built-in to Python.
Looking up a local name is faster than looking up a global or a
built-in. We're used to the fact that <code class="docutils literal"><span class="pre">str</span></code> is a builtin that is
always available, but Python still has to look up the name <code class="docutils literal"><span class="pre">str</span></code> each
time it is used. Putting it in a local saves us another small slice of
time because locals are faster than builtins.</p>
<p>Once those shortcuts are defined, we're ready for the Python lines
created from our particular template. Strings will be added to the
result list using the <code class="docutils literal"><span class="pre">append_result</span></code> or <code class="docutils literal"><span class="pre">extend_result</span></code> shorthands,
depending on whether we have one string to add, or more than one.
Literal text in the template becomes a simple string literal.</p>
<p>Having both append and extend adds complexity, but remember we're aiming
for the fastest execution of the template, and using extend for one item
means making a new list of one item so that we can pass it to extend.</p>
<p>Expressions in <code class="docutils literal"><span class="pre">{{</span> <span class="pre">...</span> <span class="pre">}}</span></code> are computed, converted to strings, and
added to the result. Dots in the expression are handled by the
<code class="docutils literal"><span class="pre">do_dots</span></code> function passed into our function, because the meaning of
the dotted expressions depends on the data in the context: it could be
attribute access or item access, and it could be a callable.</p>
<p>The logical structures <code class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">...</span> <span class="pre">%}</span></code> and <code class="docutils literal"><span class="pre">{%</span> <span class="pre">for</span> <span class="pre">...</span> <span class="pre">%}</span></code> are
converted into Python conditionals and loops. The expression in the
<code class="docutils literal"><span class="pre">{%</span> <span class="pre">if/for</span> <span class="pre">...</span> <span class="pre">%}</span></code> tag will become the expression in the <code class="docutils literal"><span class="pre">if</span></code> or
<code class="docutils literal"><span class="pre">for</span></code> statement, and the contents up until the <code class="docutils literal"><span class="pre">{%</span> <span class="pre">end...</span> <span class="pre">%}</span></code> tag
will become the body of the statement.</p>
<p class="rubric" id="writing-the-engine">Writing the Engine</p>
<p>Now that we understand what the engine will do, let's walk through the
implementation.</p>
<p class="rubric" id="the-templite-class">The Templite class</p>
<p>The heart of the template engine is the Templite class. (Get it? It's a
template, but it's lite!)</p>
<p>The Templite class has a small interface. You construct a Templite
object with the text of the template, then later you can use the
<code class="docutils literal"><span class="pre">render</span></code> method on it to render a particular context, the dictionary
of data, through the template:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Make a Templite object.</span>
<span class="n">templite</span> <span class="o">=</span> <span class="n">Templite</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    &lt;h1&gt;Hello {{name|upper}}!&lt;/h1&gt;</span>
<span class="s1">    {</span><span class="si">% f</span><span class="s1">or topic in topics %}</span>
<span class="s1">        &lt;p&gt;You are interested in {{topic}}.&lt;/p&gt;</span>
<span class="s1">    {</span><span class="si">% e</span><span class="s1">ndfor %}</span>
<span class="s1">    &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="p">{</span><span class="s1">&#39;upper&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">upper</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1"># Later, use it to render some data.</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">templite</span><span class="o">.</span><span class="n">render</span><span class="p">({</span>
    <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s2">&quot;Ned&quot;</span><span class="p">,</span>
    <span class="s1">&#39;topics&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Python&#39;</span><span class="p">,</span> <span class="s1">&#39;Geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;Juggling&#39;</span><span class="p">],</span>
<span class="p">})</span>
</pre></div>
</div>
<p>We pass the text of the template when the object is created so that we
can do the compile step just once, and later call <code class="docutils literal"><span class="pre">render</span></code> many times
to reuse the compiled results.</p>
<p>The constructor also accepts a dictionary of values, an initial context.
These are stored in the Templite object, and will be available when the
template is later rendered. These are good for defining functions or
constants we want to be available everywhere, like <code class="docutils literal"><span class="pre">upper</span></code> in the
previous example.</p>
<p>Before we discuss the implementation of Templite, we have a helper to
define first: CodeBuilder.</p>
<p class="rubric" id="codebuilder">CodeBuilder</p>
<p>The bulk of the work in our engine is parsing the template and producing
the necessary Python code. To help with producing the Python, we have
the CodeBuilder class, which handles the bookkeeping for us as we
construct the Python code. It adds lines of code, manages indentation,
and finally gives us values from the compiled Python.</p>
<p>One CodeBuilder object is responsible for a complete chunk of Python
code. As used by our template engine, the chunk of Python is always a
single complete function definition. But the CodeBuilder class makes no
assumption that it will only be one function. This keeps the CodeBuilder
code more general, and less coupled to the rest of the template engine
code.</p>
<p>As we'll see, we also use nested CodeBuilders to make it possible to put
code at the beginning of the function even though we don't know what it
will be until we are nearly done.</p>
<p>A CodeBuilder object keeps a list of strings that will together be the
final Python code. The only other state it needs is the current
indentation level:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CodeBuilder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Build source code conveniently.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indent_level</span> <span class="o">=</span> <span class="n">indent</span>
</pre></div>
</div>
<p>CodeBuilder doesn't do much. <code class="docutils literal"><span class="pre">add_line</span></code> adds a new line of code, which
automatically indents the text to the current indentation level, and
supplies a newline:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add a line of source to the code.</span>

<span class="sd">    Indentation and newline will be added for you, don&#39;t provide them.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent_level</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">indent</span></code> and <code class="docutils literal"><span class="pre">dedent</span></code> increase or decrease the indentation level:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">INDENT_STEP</span> <span class="o">=</span> <span class="mi">4</span>      <span class="c1"># PEP8 says so!</span>

<span class="k">def</span> <span class="nf">indent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Increase the current indent for following lines.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">indent_level</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">INDENT_STEP</span>

<span class="k">def</span> <span class="nf">dedent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decrease the current indent for following lines.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">indent_level</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">INDENT_STEP</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">add_section</span></code> is managed by another CodeBuilder object. This lets us
keep a reference to a place in the code, and add text to it later. The
<code class="docutils literal"><span class="pre">self.code</span></code> list is mostly a list of strings, but will also hold
references to these sections:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_section</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add a section, a sub-CodeBuilder.&quot;&quot;&quot;</span>
    <span class="n">section</span> <span class="o">=</span> <span class="n">CodeBuilder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indent_level</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">section</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">__str__</span></code> produces a single string with all the code. This simply
joins together all the strings in <code class="docutils literal"><span class="pre">self.code</span></code>. Note that because
<code class="docutils literal"><span class="pre">self.code</span></code> can contain sections, this might call other
<code class="docutils literal"><span class="pre">CodeBuilder</span></code> objects recursively:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">get_globals</span></code> yields the final values by executing the code. This
stringifies the object, executes it to get its definitions, and returns
the resulting values:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_globals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Execute the code, and return a dict of globals it defines.&quot;&quot;&quot;</span>
    <span class="c1"># A check that the caller really finished all the blocks they started.</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent_level</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="c1"># Get the Python source as a single string.</span>
    <span class="n">python_source</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="c1"># Execute the source, defining globals, and return them.</span>
    <span class="n">global_namespace</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">exec</span><span class="p">(</span><span class="n">python_source</span><span class="p">,</span> <span class="n">global_namespace</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">global_namespace</span>
</pre></div>
</div>
<p>This last method uses some exotic features of Python. The <code class="docutils literal"><span class="pre">exec</span></code>
function executes a string containing Python code. The second argument
to <code class="docutils literal"><span class="pre">exec</span></code> is a dictionary that will collect up the globals defined by
the code. So for example, if we do this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">python_source</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">SEVENTEEN = 17</span>

<span class="s2">def three():</span>
<span class="s2">    return 3</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">global_namespace</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">exec</span><span class="p">(</span><span class="n">python_source</span><span class="p">,</span> <span class="n">global_namespace</span><span class="p">)</span>
</pre></div>
</div>
<p>then <code class="docutils literal"><span class="pre">global_namespace['SEVENTEEN']</span></code> is 17, and
<code class="docutils literal"><span class="pre">global_namespace['three']</span></code> is an actual function named <code class="docutils literal"><span class="pre">three</span></code>.</p>
<p>Although we only use CodeBuilder to produce one function, there's
nothing here that limits it to that use. This makes the class simpler to
implement, and easier to understand.</p>
<p>CodeBuilder lets us create a chunk of Python source code, and has no
specific knowledge about our template engine at all. We could use it in
such a way that three different functions would be defined in the
Python, and then <code class="docutils literal"><span class="pre">get_globals</span></code> would return a dict of three values,
the three functions. As it happens, our template engine only needs to
define one function. But it's better software design to keep that
implementation detail in the template engine code, and out of our
CodeBuilder class.</p>
<p>Even as we're actually using it—to define a single function—having
<code class="docutils literal"><span class="pre">get_globals</span></code> return the dictionary keeps the code more modular
because it doesn't need to know the name of the function we've defined.
Whatever function name we define in our Python source, we can retrieve
that name from the dict returned by <code class="docutils literal"><span class="pre">get_globals</span></code>.</p>
<p>Now we can get into the implementation of the Templite class itself, and
see how and where CodeBuilder is used.</p>
<p class="rubric" id="the-templite-class-implementation">The Templite class implementation</p>
<p>Most of our code is in the Templite class. As we've discussed, it has
both a compilation and a rendering phase.</p>
<p class="rubric" id="compiling">Compiling</p>
<p>All of the work to compile the template into a Python function happens
in the Templite constructor. First the contexts are saved away:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="o">*</span><span class="n">contexts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct a Templite with the given `text`.</span>

<span class="sd">    `contexts` are dictionaries of values to use for future renderings.</span>
<span class="sd">    These are good for filters and global values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">context</span> <span class="ow">in</span> <span class="n">contexts</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice we used <code class="docutils literal"><span class="pre">*contexts</span></code> as the parameter. The asterisk denotes that
any number of positional arguments will be packed into a tuple and
passed in as <code class="docutils literal"><span class="pre">contexts</span></code>. This is called argument unpacking, and means
that the caller can provide a number of different context dictionaries.
Now any of these calls are valid:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Templite</span><span class="p">(</span><span class="n">template_text</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Templite</span><span class="p">(</span><span class="n">template_text</span><span class="p">,</span> <span class="n">context1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Templite</span><span class="p">(</span><span class="n">template_text</span><span class="p">,</span> <span class="n">context1</span><span class="p">,</span> <span class="n">context2</span><span class="p">)</span>
</pre></div>
</div>
<p>The context arguments (if any) are supplied to the constructor as a
tuple of contexts. We can then iterate over the <code class="docutils literal"><span class="pre">contexts</span></code> tuple,
dealing with each of them in turn. We simply create one combined
dictionary called <code class="docutils literal"><span class="pre">self.context</span></code> which has the contents of all of the
supplied contexts. If duplicate names are provided in the contexts, the
last one wins.</p>
<p>To make our compiled function as fast as possible, we extract context
variables into Python locals. We'll get those names by keeping a set of
variable names we encounter, but we also need to track the names of
variables defined in the template, the loop variables:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">all_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">loop_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</pre></div>
</div>
<p>Later we'll see how these get used to help construct the prologue of our
function. First, we'll use the CodeBuilder class we wrote earlier to
start to build our compiled function:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">code</span> <span class="o">=</span> <span class="n">CodeBuilder</span><span class="p">()</span>

<span class="n">code</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;def render_function(context, do_dots):&quot;</span><span class="p">)</span>
<span class="n">code</span><span class="o">.</span><span class="n">indent</span><span class="p">()</span>
<span class="n">vars_code</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">add_section</span><span class="p">()</span>
<span class="n">code</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;result = []&quot;</span><span class="p">)</span>
<span class="n">code</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;append_result = result.append&quot;</span><span class="p">)</span>
<span class="n">code</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;extend_result = result.extend&quot;</span><span class="p">)</span>
<span class="n">code</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;to_str = str&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we construct our CodeBuilder object, and start writing lines into
it. Our Python function will be called <code class="docutils literal"><span class="pre">render_function</span></code>, and will
take two arguments: <code class="docutils literal"><span class="pre">context</span></code> is the data dictionary it should use,
and <code class="docutils literal"><span class="pre">do_dots</span></code> is a function implementing dot attribute access.</p>
<p>The context here is the combination of the data context passed to the
Templite constructor, and the data context passed to the render
function. It's the complete set of data available to the template that
we made in the Templite constructor.</p>
<p>Notice that CodeBuilder is very simple: it doesn't &quot;know&quot; about function
definitions, just lines of code. This keeps CodeBuilder simple, both in
its implementation, and in its use. We can read our generated code here
without having to mentally interpolate too many specialized CodeBuilder.</p>
<p>We create a section called <code class="docutils literal"><span class="pre">vars_code</span></code>. Later we'll write the variable
extraction lines into that section. The <code class="docutils literal"><span class="pre">vars_code</span></code> object lets us
save a place in the function that can be filled in later when we have
the information we need.</p>
<p>Then four fixed lines are written, defining a result list, shortcuts for
the methods to append to or extend that list, and a shortcut for the
<code class="docutils literal"><span class="pre">str()</span></code> builtin. As we discussed earlier, this odd step squeezes just
a little bit more performance out of our rendering function.</p>
<p>The reason we have both the <code class="docutils literal"><span class="pre">append</span></code> and the <code class="docutils literal"><span class="pre">extend</span></code> shortcut is so
we can use the most effective method, depending on whether we have one
line to add to our result, or more than one.</p>
<p>Next we define an inner function to help us with buffering output
strings:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">buffered</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">flush_output</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Force `buffered` to the code builder.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">buffered</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">code</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;append_result(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">buffered</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">buffered</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">code</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;extend_result([</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">buffered</span><span class="p">))</span>
    <span class="k">del</span> <span class="n">buffered</span><span class="p">[:]</span>
</pre></div>
</div>
<p>As we create chunks of output that need to go into our compiled
function, we need to turn them into function calls that append to our
result. We'd like to combine repeated append calls into one extend call.
This is another micro-optimization. To make this possible, we buffer the
chunks.</p>
<p>The <code class="docutils literal"><span class="pre">buffered</span></code> list holds strings that are yet to be written to our
function source code. As our template compilation proceeds, we'll append
strings to <code class="docutils literal"><span class="pre">buffered</span></code>, and flush them to the function source when we
reach control flow points, like if statements, or the beginning or ends
of loops.</p>
<p>The <code class="docutils literal"><span class="pre">flush_output</span></code> function is a <em>closure</em>, which is a fancy word for
a function that refers to variables outside of itself. Here
<code class="docutils literal"><span class="pre">flush_output</span></code> refers to <code class="docutils literal"><span class="pre">buffered</span></code> and <code class="docutils literal"><span class="pre">code</span></code>. This simplifies
our calls to the function: we don't have to tell <code class="docutils literal"><span class="pre">flush_output</span></code> what
buffer to flush, or where to flush it; it knows all that implicitly.</p>
<p>If only one string has been buffered, then the <code class="docutils literal"><span class="pre">append_result</span></code>
shortcut is used to append it to the result. If more than one is
buffered, then the <code class="docutils literal"><span class="pre">extend_result</span></code> shortcut is used, with all of them,
to add them to the result. Then the buffered list is cleared so more
strings can be buffered.</p>
<p>The rest of the compiling code will add lines to the function by
appending them to <code class="docutils literal"><span class="pre">buffered</span></code>, and eventually call <code class="docutils literal"><span class="pre">flush_output</span></code> to
write them to the CodeBuilder.</p>
<p>With this function in place, we can have a line of code in our compiler
like this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">buffered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&#39;hello&#39;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>which will mean that our compiled Python function will have this line:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">append_result</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>which will add the string <code class="docutils literal"><span class="pre">hello</span></code> to the rendered output of the
template. We have multiple levels of abstraction here which can be
difficult to keep straight. The compiler uses
<code class="docutils literal"><span class="pre">buffered.append(&quot;'hello'&quot;)</span></code>, which creates <code class="docutils literal"><span class="pre">append_result('hello')</span></code>
in the compiled Python function, which when run, appends <code class="docutils literal"><span class="pre">hello</span></code> to
the template result.</p>
<p>Back to our Templite class. As we parse control structures, we want to
check that they are properly nested. The <code class="docutils literal"><span class="pre">ops_stack</span></code> list is a stack
of strings:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">ops_stack</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>When we encounter an <code class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">..</span> <span class="pre">%}</span></code> tag (for example), we'll push
<code class="docutils literal"><span class="pre">'if'</span></code> onto the stack. When we find an <code class="docutils literal"><span class="pre">{%</span> <span class="pre">endif</span> <span class="pre">%}</span></code> tag, we can pop
the stack and report an error if there was no <code class="docutils literal"><span class="pre">'if'</span></code> at the top of the
stack.</p>
<p>Now the real parsing begins. We split the template text into a number of
tokens using a regular expression, or <em>regex</em>. Regexes can be daunting:
they are a very compact notation for complex pattern matching. They are
also very efficient, since the complexity of matching the pattern is
implemented in C in the regular expression engine, rather than in your
own Python code. Here's our regex:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">tokens</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">r&quot;(?s)({{.*?}}|{%.*?%}|{#.*?#})&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>This looks complicated; let's break it down.</p>
<p>The <code class="docutils literal"><span class="pre">re.split</span></code> function will split a string using a regex. Our pattern
is parenthesized, so the matches will be used to split the string, and
will also be returned as pieces in the split list. Our pattern will
match our tag syntaxes, but we've parenthesized it so that the string
will be split at the tags, and the tags will also be returned.</p>
<p>The <code class="docutils literal"><span class="pre">(?s)</span></code> flag in the regex means that a dot should match even a
newline. Next we have our parenthesized group of three alternatives:
<code class="docutils literal"><span class="pre">{{.*?}}</span></code> matches an expression, <code class="docutils literal"><span class="pre">{%.*?%}</span></code> matches a tag, and
<code class="docutils literal"><span class="pre">{#.*?#}</span></code> matches a comment. In all of these, we use <code class="docutils literal"><span class="pre">.*?</span></code> to match
any number of characters, but the shortest sequence that matches.</p>
<p>The result of <code class="docutils literal"><span class="pre">re.split</span></code> is a list of strings. For example, this
template text:</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Topics</span> <span class="k">for</span> <span class="p">{{</span><span class="n">name</span><span class="p">}}:</span> <span class="p">{</span><span class="o">%</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">topics</span> <span class="o">%</span><span class="p">}{{</span><span class="n">t</span><span class="p">}},</span> <span class="p">{</span><span class="o">%</span> <span class="n">endfor</span> <span class="o">%</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>would be split into these pieces:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span>
    <span class="s1">&#39;&lt;p&gt;Topics for &#39;</span><span class="p">,</span>               <span class="c1"># literal</span>
    <span class="s1">&#39;{{name}}&#39;</span><span class="p">,</span>                     <span class="c1"># expression</span>
    <span class="s1">&#39;: &#39;</span><span class="p">,</span>                           <span class="c1"># literal</span>
    <span class="s1">&#39;{</span><span class="si">% f</span><span class="s1">or t in topics %}&#39;</span><span class="p">,</span>        <span class="c1"># tag</span>
    <span class="s1">&#39;&#39;</span><span class="p">,</span>                             <span class="c1"># literal (empty)</span>
    <span class="s1">&#39;{{t}}&#39;</span><span class="p">,</span>                        <span class="c1"># expression</span>
    <span class="s1">&#39;, &#39;</span><span class="p">,</span>                           <span class="c1"># literal</span>
    <span class="s1">&#39;{</span><span class="si">% e</span><span class="s1">ndfor %}&#39;</span><span class="p">,</span>                 <span class="c1"># tag</span>
    <span class="s1">&#39;&lt;/p&gt;&#39;</span>                          <span class="c1"># literal</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Once the text is split into tokens like this, we can loop over the
tokens, and deal with each in turn. By splitting them according to their
type, we can handle each type separately.</p>
<p>The compilation code is a loop over these tokens:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
</pre></div>
</div>
<p>Each token is examined to see which of the four cases it is. Just
looking at the first two characters is enough. The first case is a
comment, which is easy to handle: just ignore it and move on to the next
token:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;{#&#39;</span><span class="p">):</span>
    <span class="c1"># Comment: ignore it and move on.</span>
    <span class="k">continue</span>
</pre></div>
</div>
<p>For the case of <code class="docutils literal"><span class="pre">{{...}}</span></code> expressions, we cut off the two braces at
the front and back, strip off the white space, and pass the entire
expression to <code class="docutils literal"><span class="pre">_expr_code</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;{{&#39;</span><span class="p">):</span>
    <span class="c1"># An expression to evaluate.</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr_code</span><span class="p">(</span><span class="n">token</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
    <span class="n">buffered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;to_str(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">_expr_code</span></code> method will compile the template expression into a
Python expression. We'll see that function later. We use the <code class="docutils literal"><span class="pre">to_str</span></code>
function to force the expression's value to be a string, and add that to
our result.</p>
<p>The third case is the big one: <code class="docutils literal"><span class="pre">{%</span> <span class="pre">...</span> <span class="pre">%}</span></code> tags. These are control
structures that will become Python control structures. First we have to
flush our buffered output lines, then we extract a list of words from
the tag:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">elif</span> <span class="n">token</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;{%&#39;</span><span class="p">):</span>
    <span class="c1"># Action tag: split into words and parse further.</span>
    <span class="n">flush_output</span><span class="p">()</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">token</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
</pre></div>
</div>
<p>Now we have three sub-cases, based on the first word in the tag: <code class="docutils literal"><span class="pre">if</span></code>,
<code class="docutils literal"><span class="pre">for</span></code>, or <code class="docutils literal"><span class="pre">end</span></code>. The <code class="docutils literal"><span class="pre">if</span></code> case shows our simple error handling and
code generation:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;if&#39;</span><span class="p">:</span>
    <span class="c1"># An if statement: evaluate the expression to determine if.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_syntax_error</span><span class="p">(</span><span class="s2">&quot;Don&#39;t understand if&quot;</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
    <span class="n">ops_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;if&#39;</span><span class="p">)</span>
    <span class="n">code</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;if </span><span class="si">%s</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr_code</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">code</span><span class="o">.</span><span class="n">indent</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">if</span></code> tag should have a single expression, so the <code class="docutils literal"><span class="pre">words</span></code> list
should have only two elements in it. If it doesn't, we use the
<code class="docutils literal"><span class="pre">_syntax_error</span></code> helper method to raise a syntax error exception. We
push <code class="docutils literal"><span class="pre">'if'</span></code> onto <code class="docutils literal"><span class="pre">ops_stack</span></code> so that we can check the <code class="docutils literal"><span class="pre">endif</span></code> tag.
The expression part of the <code class="docutils literal"><span class="pre">if</span></code> tag is compiled to a Python expression
with <code class="docutils literal"><span class="pre">_expr_code</span></code>, and is used as the conditional expression in a
Python <code class="docutils literal"><span class="pre">if</span></code> statement.</p>
<p>The second tag type is <code class="docutils literal"><span class="pre">for</span></code>, which will be compiled to a Python
<code class="docutils literal"><span class="pre">for</span></code> statement:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">elif</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;for&#39;</span><span class="p">:</span>
    <span class="c1"># A loop: iterate over expression result.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;in&#39;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_syntax_error</span><span class="p">(</span><span class="s2">&quot;Don&#39;t understand for&quot;</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
    <span class="n">ops_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;for&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_vars</span><span class="p">)</span>
    <span class="n">code</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span>
        <span class="s2">&quot;for c_</span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_expr_code</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">code</span><span class="o">.</span><span class="n">indent</span><span class="p">()</span>
</pre></div>
</div>
<p>We do a check of the syntax and push <code class="docutils literal"><span class="pre">'for'</span></code> onto the stack. The
<code class="docutils literal"><span class="pre">_variable</span></code> method checks the syntax of the variable, and adds it to
the set we provide. This is how we collect up the names of all the
variables during compilation. Later we'll need to write the prologue of
our function, where we'll unpack all the variable names we get from the
context. To do that correctly, we need to know the names of all the
variables we encountered, <code class="docutils literal"><span class="pre">self.all_vars</span></code>, and the names of all the
variables defined by loops, <code class="docutils literal"><span class="pre">self.loop_vars</span></code>.</p>
<p>We add one line to our function source, a <code class="docutils literal"><span class="pre">for</span></code> statement. All of our
template variables are turned into Python variables by prepending <code class="docutils literal"><span class="pre">c_</span></code>
to them, so that we know they won't collide with other names we're using
in our Python function. We use <code class="docutils literal"><span class="pre">_expr_code</span></code> to compile the iteration
expression from the template into an iteration expression in Python.</p>
<p>The last kind of tag we handle is an <code class="docutils literal"><span class="pre">end</span></code> tag; either <code class="docutils literal"><span class="pre">{%</span> <span class="pre">endif</span> <span class="pre">%}</span></code>
or <code class="docutils literal"><span class="pre">{%</span> <span class="pre">endfor</span> <span class="pre">%}</span></code>. The effect on our compiled function source is the
same: simply unindent to end the <code class="docutils literal"><span class="pre">if</span></code> or <code class="docutils literal"><span class="pre">for</span></code> statement that was
started earlier:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">elif</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">):</span>
    <span class="c1"># Endsomething.  Pop the ops stack.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_syntax_error</span><span class="p">(</span><span class="s2">&quot;Don&#39;t understand end&quot;</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
    <span class="n">end_what</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ops_stack</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_syntax_error</span><span class="p">(</span><span class="s2">&quot;Too many ends&quot;</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
    <span class="n">start_what</span> <span class="o">=</span> <span class="n">ops_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">start_what</span> <span class="o">!=</span> <span class="n">end_what</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_syntax_error</span><span class="p">(</span><span class="s2">&quot;Mismatched end tag&quot;</span><span class="p">,</span> <span class="n">end_what</span><span class="p">)</span>
    <span class="n">code</span><span class="o">.</span><span class="n">dedent</span><span class="p">()</span>
</pre></div>
</div>
<p>Notice here that the actual work needed for the end tag is one line:
unindent the function source. The rest of this clause is all error
checking to make sure that the template is properly formed. This isn't
unusual in program translation code.</p>
<p>Speaking of error handling, if the tag isn't an <code class="docutils literal"><span class="pre">if</span></code>, a <code class="docutils literal"><span class="pre">for</span></code>, or an
<code class="docutils literal"><span class="pre">end</span></code>, then we don't know what it is, so raise a syntax error:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">else</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_syntax_error</span><span class="p">(</span><span class="s2">&quot;Don&#39;t understand tag&quot;</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>We're done with the three different special syntaxes (<code class="docutils literal"><span class="pre">{{...}}</span></code>,
<code class="docutils literal"><span class="pre">{#...#}</span></code>, and <code class="docutils literal"><span class="pre">{%...%}</span></code>). What's left is literal content. We'll add
the literal string to the buffered output, using the <code class="docutils literal"><span class="pre">repr</span></code> built-in
function to produce a Python string literal for the token:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">else</span><span class="p">:</span>
    <span class="c1"># Literal content.  If it isn&#39;t empty, output it.</span>
    <span class="k">if</span> <span class="n">token</span><span class="p">:</span>
        <span class="n">buffered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
</pre></div>
</div>
<p>If we didn't use <code class="docutils literal"><span class="pre">repr</span></code>, then we'd end up with lines like this in our
compiled function:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">append_result</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span>      <span class="c1"># Error! abc isn&#39;t defined</span>
</pre></div>
</div>
<p>We need the value to be quoted like this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">append_result</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">repr</span></code> function supplies the quotes around the string for us, and
also provides backslashes where needed:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">append_result</span><span class="p">(</span><span class="s1">&#39;&quot;Don</span><span class="se">\&#39;</span><span class="s1">t you like my hat?&quot; he asked.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that we first check if the token is an empty string with
<code class="docutils literal"><span class="pre">if</span> <span class="pre">token:</span></code>, since there's no point adding an empty string to the
output. Because our regex is splitting on tag syntax, adjacent tags will
have an empty token between them. The check here is an easy way to avoid
putting useless <code class="docutils literal"><span class="pre">append_result(&quot;&quot;)</span></code> statements into our compiled
function.</p>
<p>That completes the loop over all the tokens in the template. When the
loop is done, all of the template has been processed. We have one last
check to make: if <code class="docutils literal"><span class="pre">ops_stack</span></code> isn't empty, then we must be missing an
end tag. Then we flush the buffered output to the function source:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">ops_stack</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_syntax_error</span><span class="p">(</span><span class="s2">&quot;Unmatched action tag&quot;</span><span class="p">,</span> <span class="n">ops_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="n">flush_output</span><span class="p">()</span>
</pre></div>
</div>
<p>We had created a section at the beginning of the function. Its role was
to unpack template variables from the context into Python locals. Now
that we've processed the entire template, we know the names of all the
variables, so we can write the lines in this prologue.</p>
<p>We have to do a little work to know what names we need to define.
Looking at our sample template:</p>
<div class="code html highlight-default"><div class="highlight"><pre><span></span>&lt;p&gt;Welcome, {{user_name}}!&lt;/p&gt;
&lt;p&gt;Products:&lt;/p&gt;
&lt;ul&gt;
{% for product in product_list %}
    &lt;li&gt;{{ product.name }}:
        {{ product.price|format_price }}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</pre></div>
</div>
<p>There are two variables used here, <code class="docutils literal"><span class="pre">user_name</span></code> and <code class="docutils literal"><span class="pre">product</span></code>. The
<code class="docutils literal"><span class="pre">all_vars</span></code> set will have both of those names, because both are used in
<code class="docutils literal"><span class="pre">{{...}}</span></code> expressions. But only <code class="docutils literal"><span class="pre">user_name</span></code> needs to be extracted
from the context in the prologue, because <code class="docutils literal"><span class="pre">product</span></code> is defined by the
loop.</p>
<p>All the variables used in the template are in the set <code class="docutils literal"><span class="pre">all_vars</span></code>, and
all the variables defined in the template are in <code class="docutils literal"><span class="pre">loop_vars</span></code>. All of
the names in <code class="docutils literal"><span class="pre">loop_vars</span></code> have already been defined in the code because
they are used in loops. So we need to unpack any name in <code class="docutils literal"><span class="pre">all_vars</span></code>
that isn't in <code class="docutils literal"><span class="pre">loop_vars</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_vars</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_vars</span><span class="p">:</span>
    <span class="n">vars_code</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;c_</span><span class="si">%s</span><span class="s2"> = context[</span><span class="si">%r</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">))</span>
</pre></div>
</div>
<p>Each name becomes a line in the function's prologue, unpacking the
context variable into a suitably named local variable.</p>
<p>We're almost done compiling the template into a Python function. Our
function has been appending strings to <code class="docutils literal"><span class="pre">result</span></code>, so the last line of
the function is simply to join them all together and return them:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;return &#39;&#39;.join(result)&quot;</span><span class="p">)</span>
<span class="n">code</span><span class="o">.</span><span class="n">dedent</span><span class="p">()</span>
</pre></div>
</div>
<p>Now that we've finished writing the source for our compiled Python
function, we need to get the function itself from our CodeBuilder
object. The <code class="docutils literal"><span class="pre">get_globals</span></code> method executes the Python code we've been
assembling. Remember that our code is a function definition (starting
with <code class="docutils literal"><span class="pre">def</span> <span class="pre">render_function(..):</span></code>), so executing the code will define
<code class="docutils literal"><span class="pre">render_function</span></code>, but not execute the body of <code class="docutils literal"><span class="pre">render_function</span></code>.</p>
<p>The result of <code class="docutils literal"><span class="pre">get_globals</span></code> is the dictionary of values defined in the
code. We grab the <code class="docutils literal"><span class="pre">render_function</span></code> value from it, and save it as an
attribute in our Templite object:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">_render_function</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">get_globals</span><span class="p">()[</span><span class="s1">&#39;render_function&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Now <code class="docutils literal"><span class="pre">self._render_function</span></code> is a callable Python function. We'll use
it later, during the rendering phase.</p>
<p class="rubric" id="compiling-expressions">Compiling Expressions</p>
<p>We haven't yet seen a significant piece of the compiling process: the
<code class="docutils literal"><span class="pre">_expr_code</span></code> method that compiles a template expression into a Python
expression. Our template expressions can be as simple as a single name:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{{</span><span class="n">user_name</span><span class="p">}}</span>
</pre></div>
</div>
<p>or can be a complex sequence of attribute accesses and filters:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{{</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">localized</span><span class="o">|</span><span class="n">upper</span><span class="o">|</span><span class="n">escape</span><span class="p">}}</span>
</pre></div>
</div>
<p>Our <code class="docutils literal"><span class="pre">_expr_code</span></code> method will handle all of these possibilities. As
with expressions in any language, ours are built recursively: big
expressions are composed of smaller expressions. A full expression is
pipe-separated, where the first piece is dot-separated, and so on. So
our function naturally takes a recursive form:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_expr_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a Python expression for `expr`.&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>The first case to consider is that our expression has pipes in it. If it
does, then we split it into a list of pipe-pieces. The first pipe-piece
is passed recursively to <code class="docutils literal"><span class="pre">_expr_code</span></code> to convert it into a Python
expression.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="s2">&quot;|&quot;</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
    <span class="n">pipes</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>
    <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr_code</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">pipes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_vars</span><span class="p">)</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s2">&quot;c_</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
<p>Each of the remaining pipe pieces is the name of a function. The value
is passed through the function to produce the final value. Each function
name is a variable that gets added to <code class="docutils literal"><span class="pre">all_vars</span></code> so that we can
extract it properly in the prologue.</p>
<p>If there were no pipes, there might be dots. If so, split on the dots.
The first part is passed recursively to <code class="docutils literal"><span class="pre">_expr_code</span></code> to turn it into a
Python expression, then each dot name is handled in turn:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">elif</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
    <span class="n">dots</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
    <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr_code</span><span class="p">(</span><span class="n">dots</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dots</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">code</span> <span class="o">=</span> <span class="s2">&quot;do_dots(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>To understand how dots get compiled, remember that <code class="docutils literal"><span class="pre">x.y</span></code> in the
template could mean either <code class="docutils literal"><span class="pre">x['y']</span></code> or <code class="docutils literal"><span class="pre">x.y</span></code> in Python, depending on
which works; if the result is callable, it's called. This uncertainty
means that we have to try those possibilities at run time, not compile
time. So we compile <code class="docutils literal"><span class="pre">x.y.z</span></code> into a function call,
<code class="docutils literal"><span class="pre">do_dots(x,</span> <span class="pre">'y',</span> <span class="pre">'z')</span></code>. The dot function will try the various access
methods and return the value that succeeded.</p>
<p>The <code class="docutils literal"><span class="pre">do_dots</span></code> function is passed into our compiled Python function at
run time. We'll see its implementation in just a bit.</p>
<p>The last clause in the <code class="docutils literal"><span class="pre">_expr_code</span></code> function handles the case that
there was no pipe or dot in the input expression. In that case, it's
just a name. We record it in <code class="docutils literal"><span class="pre">all_vars</span></code>, and access the variable using
its prefixed Python name:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">else</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_vars</span><span class="p">)</span>
    <span class="n">code</span> <span class="o">=</span> <span class="s2">&quot;c_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">expr</span>
<span class="k">return</span> <span class="n">code</span>
</pre></div>
</div>
<p class="rubric" id="helper-functions">Helper Functions</p>
<p>During compilation, we used a few helper functions. The
<code class="docutils literal"><span class="pre">_syntax_error</span></code> method simply puts together a nice error message and
raises the exception:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_syntax_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">thing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise a syntax error using `msg`, and showing `thing`.&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="n">TempliteSyntaxError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">thing</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">_variable</span></code> method helps us with validating variable names and
adding them to the sets of names we collected during compilation. We use
a regex to check that the name is a valid Python identifier, then add
the name to the set:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">vars_set</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Track that `name` is used as a variable.</span>

<span class="sd">    Adds the name to `vars_set`, a set of variable names.</span>

<span class="sd">    Raises an syntax error if `name` is not a valid name.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">r&quot;[_a-zA-Z][_a-zA-Z0-9]*$&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_syntax_error</span><span class="p">(</span><span class="s2">&quot;Not a valid name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">vars_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>With that, the compilation code is done!</p>
<p class="rubric" id="rendering">Rendering</p>
<p>All that's left is to write the rendering code. Since we've compiled our
template to a Python function, the rendering code doesn't have much to
do. It has to get the data context ready, and then call the compiled
Python code:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Render this template by applying it to `context`.</span>

<span class="sd">    `context` is a dictionary of values to use in this rendering.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make the complete context we&#39;ll use.</span>
    <span class="n">render_context</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">context</span><span class="p">:</span>
        <span class="n">render_context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_render_function</span><span class="p">(</span><span class="n">render_context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_dots</span><span class="p">)</span>
</pre></div>
</div>
<p>Remember that when we constructed the <code class="docutils literal"><span class="pre">Templite</span></code> object, we started
with a data context. Here we copy it, and merge in whatever data has
been passed in for this rendering. The copying is so that successive
rendering calls won't see each others' data, and the merging is so that
we have a single dictionary to use for data lookups. This is how we
build one unified data context from the contexts provided when the
template was constructed, with the data provided now at render time.</p>
<p>Notice that the data passed to <code class="docutils literal"><span class="pre">render</span></code> could overwrite data passed to
the Templite constructor. That tends not to happen, because the context
passed to the constructor has global-ish things like filter definitions
and constants, and the context passed to <code class="docutils literal"><span class="pre">render</span></code> has specific data
for that one rendering.</p>
<p>Then we simply call our compiled <code class="docutils literal"><span class="pre">render_function</span></code>. The first argument
is the complete data context, and the second argument is the function
that will implement the dot semantics. We use the same implementation
every time: our own <code class="docutils literal"><span class="pre">_do_dots</span></code> method.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_do_dots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">dots</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluate dotted expressions at runtime.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">dot</span> <span class="ow">in</span> <span class="n">dots</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dot</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">dot</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">value</span>
</pre></div>
</div>
<p>During compilation, a template expression like <code class="docutils literal"><span class="pre">x.y.z</span></code> gets turned
into <code class="docutils literal"><span class="pre">do_dots(x,</span> <span class="pre">'y',</span> <span class="pre">'z')</span></code>. This function loops over the dot-names,
and for each one tries it as an attribute, and if that fails, tries it
as a key. This is what gives our single template syntax the flexibility
to act as either <code class="docutils literal"><span class="pre">x.y</span></code> or <code class="docutils literal"><span class="pre">x['y']</span></code>. At each step, we also check if
the new value is callable, and if it is, we call it. Once we're done
with all the dot-names, the value in hand is the value we want.</p>
<p>Here we used Python argument unpacking again (<code class="docutils literal"><span class="pre">*dots</span></code>) so that
<code class="docutils literal"><span class="pre">_do_dots</span></code> could take any number of dot names. This gives us a
flexible function that will work for any dotted expression we encounter
in the template.</p>
<p>Note that when calling <code class="docutils literal"><span class="pre">self._render_function</span></code>, we pass in a function
to use for evaluating dot expressions, but we always pass in the same
one. We could have made that code part of the compiled template, but
it's the same eight lines for every template, and those eight lines are
part of the definition of how templates work, not part of the details of
a particular template. It feels cleaner to implement it like this than
to have that code be part of the compiled template.</p>
<p class="rubric" id="testing">Testing</p>
<p>Provided with the template engine is a suite of tests that cover all of
the behavior and edge cases. I'm actually a little bit over my 500-line
limit: the template engine is 252 lines, and the tests are 275 lines.
This is typical of well-tested code: you have more code in your tests
than in your product.</p>
<p class="rubric" id="whats-left-out">What's Left Out</p>
<p>Full-featured template engines provide much more than we've implemented
here. To keep this code small, we're leaving out interesting ideas like:</p>
<ul class="simple">
<li>Template inheritance and inclusion</li>
<li>Custom tags</li>
<li>Automatic escaping</li>
<li>Arguments to filters</li>
<li>Complex conditional logic like else and elif</li>
<li>Loops with more than one loop variable</li>
<li>Whitespace control</li>
</ul>
<p>Even so, our simple template engine is useful. In fact, it is the
template engine used in coverage.py to produce its HTML reports.</p>
<p class="rubric" id="summing-up">Summing up</p>
<p>In 252 lines, we've got a simple yet capable template engine. Real
template engines have many more features, but this code lays out the
basic ideas of the process: compile the template to a Python function,
then execute the function to produce the text result.</p>
</div></div></div></div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Learn-Computer-and-Math-again</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="blockcode-a-visual-programming-toolkit.html">500 Lines or Less | Blockcode: A visual programming toolkit</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, timger.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/chapters/a-template-engine.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>