
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>500 Lines or Less | DBDB: Dog Bed Database &#8212; Learn-Computer-and-Math-again 0.0.1 文档</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lines-or-less-dbdb-dog-bed-database">
<h1>500 Lines or Less | DBDB: Dog Bed Database<a class="headerlink" href="#lines-or-less-dbdb-dog-bed-database" title="永久链接至标题">¶</a></h1>
<div class="container"><div class="row"><div class="hero-unit"><p><a href="#id1"><span class="problematic" id="id2">``</span></a>_
.. rubric:: DBDB: Dog Bed Database</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">dbdb-dog-bed-database</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p class="author rubric" id="taavi-burns">Taavi Burns</p>
</div></div><div class="row"><div id="content" class="span10 offset1"><p><em>As the newest bass (and sometimes tenor) in `Countermeasure`_, Taavi
strives to break the mould... sometimes just by ignoring its existence.
This is certainly true through the diversity of workplaces in his
career: IBM (doing C and Perl), FreshBooks (all the things), Points.com
(doing Python), and now at PagerDuty (doing Scala). Aside from that—when
not gliding along on his Brompton folding bike—you might find him
playing Minecraft with his son or engaging in parkour (or rock climbing,
or other adventures) with his wife. He knits continental.</em></p>
<p class="rubric" id="introduction">Introduction</p>
<p>DBDB (Dog Bed Database) is a Python library that implements a simple
key/value database. It lets you associate a key with a value, and store
that association on disk for later retrieval.</p>
<p>DBDB aims to preserve data in the face of computer crashes and error
conditions. It also avoids holding all data in RAM at once so you can
store more data than you have RAM.</p>
<p class="rubric" id="memory">Memory</p>
<p>I remember the first time I was really stuck on a bug. When I finished
typing in my BASIC program and ran it, weird sparkly pixels showed up on
the screen, and the program aborted early. When I went back to look at
the code, the last few lines of the program were gone.</p>
<p>One of my mom's friends knew how to program, so we set up a call. Within
a few minutes of speaking with her, I found the problem: the program was
too big, and had encroached onto video memory. Clearing the screen
truncated the program, and the sparkles were artifacts of Applesoft
BASIC's behaviour of storing program state in RAM just beyond the end of
the program.</p>
<p>From that moment onwards, I cared about memory allocation. I learned
about pointers and how to allocate memory with malloc. I learned how my
data structures were laid out in memory. And I learned to be very, very
careful about how I changed them.</p>
<p>Some years later, while reading about a process-oriented language called
Erlang, I learned that it didn't actually have to copy data to send
messages between processes, because everything was immutable. I then
discovered immutable data structures in Clojure, and it really began to
sink in.</p>
<p>When I read about CouchDB in 2013, I just smiled and nodded, recognising
the structures and mechanisms for managing complex data as it changes.</p>
<p>I learned that you can design systems built around immutable data.</p>
<p>Then I agreed to write a book chapter.</p>
<p>I thought that describing the core data storage concepts of CouchDB (as
I understood them) would be fun.</p>
<p>While trying to write a binary tree algorithm that mutated the tree in
place, I got frustrated with how complicated things were getting. The
number of edge cases and trying to reason about how changes in one part
of the tree affected others was making my head hurt. I had no idea how I
was going to explain all of this.</p>
<p>Remembering lessons learned, I took a peek at a recursive algorithm for
updating immutable binary trees and it turned out to be relatively
straightforward.</p>
<p>I learned, once again, that it's easier to reason about things that
don't change.</p>
<p>So starts the story.</p>
<p class="rubric" id="why-is-it-interesting">Why Is it Interesting?</p>
<p>Most projects require a database of some kind. You really shouldn't
write your own; there are many edge cases that will bite you, even if
you're just writing JSON to disk:</p>
<ul class="simple">
<li>What happens if your filesystem runs out of space?</li>
<li>What happens if your laptop battery dies while saving?</li>
<li>What if your data size exceeds available memory? (Unlikely for most
applications on modern desktop computers… but not unlikely for a
mobile device or server-side web application.)</li>
</ul>
<p>However, if you want to <em>understand</em> how a database handles all of these
problems, writing one for yourself can be a good idea.</p>
<p>The techniques and concepts we discuss here should be applicable to any
problem that needs to have rational, predictable behaviour when faced
with failure.</p>
<p>Speaking of failure...</p>
<p class="rubric" id="characterizing-failure">Characterizing Failure</p>
<p>Databases are often characterized by how closely they adhere to the ACID
properties: atomicity, consistency, isolation, and durability.</p>
<p>Updates in DBDB are atomic and durable, two attributes which are
described later in the chapter. DBDB provides no consistency guarantees
as there are no constraints on the data stored. Isolation is likewise
not implemented.</p>
<p>Application code can, of course, impose its own consistency guarantees,
but proper isolation requires a transaction manager. We won't attempt
that here; however, you can learn more about transaction management in
the <a class="reference external" href="http://aosabook.org/en/500L/an-archaeology-inspired-database.html">CircleDB chapter</a>.</p>
<p>We also have other system-maintenance problems to think about. Stale
data is not reclaimed in this implementation, so repeated updates (even
to the same key) will eventually consume all disk space. (You will
shortly discover why this is the case.) <a class="reference external" href="http://www.postgresql.org/">PostgreSQL</a> calls this
reclamation &quot;vacuuming&quot; (which makes old row space available for
re-use), and <a class="reference external" href="http://couchdb.apache.org/">CouchDB</a> calls it &quot;compaction&quot; (by rewriting the &quot;live&quot;
parts of the data into a new file, and atomically moving it over the old
one).</p>
<p>DBDB could be enhanced to add a compaction feature, but it is left as an
exercise for the reader<a class="reference external" href="#fn1">:sup:`1`</a>.</p>
<p class="rubric" id="the-architecture-of-dbdb">The Architecture of DBDB</p>
<p>DBDB separates the concerns of &quot;put this on disk somewhere&quot; (how data
are laid out in a file; the physical layer) from the logical structure
of the data (a binary tree in this example; the logical layer) from the
contents of the key/value store (the association of key <code class="docutils literal"><span class="pre">a</span></code> to value
<code class="docutils literal"><span class="pre">foo</span></code>; the public API).</p>
<p>Many databases separate the logical and physical aspects as it is is
often useful to provide alternative implementations of each to get
different performance characteristics, e.g. DB2's SMS (files in a
filesystem) versus DMS (raw block device) tablespaces, or MySQL's
<a class="reference external" href="http://dev.mysql.com/doc/refman/5.7/en/storage-engines.html">alternative engine implementations</a>.</p>
<p class="rubric" id="discovering-the-design">Discovering the Design</p>
<p>Most of the chapters in this book describe how a program was built from
inception to completion. However, that is not how most of us interact
with the code we're working on. We most often discover code that was
written by others, and figure out how to modify or extend it to do
something different.</p>
<p>In this chapter, we'll assume that DBDB is a completed project, and walk
through it to learn how it works. Let's explore the structure of the
entire project first.</p>
<p class="rubric" id="organisational-units">Organisational Units</p>
<p>Units are ordered here by distance from the end user; that is, the first
module is the one that a user of this program would likely need to know
the most about, while the last is something they should have very little
interaction with.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">tool.py</span></code> defines a command-line tool for exploring a database from
a terminal window.</li>
<li><code class="docutils literal"><span class="pre">interface.py</span></code> defines a class (<code class="docutils literal"><span class="pre">DBDB</span></code>) which implements the
Python dictionary API using the concrete <code class="docutils literal"><span class="pre">BinaryTree</span></code>
implementation. This is how you'd use DBDB inside a Python program.</li>
<li><code class="docutils literal"><span class="pre">logical.py</span></code> defines the logical layer. It's an abstract interface
to a key/value store.<ul>
<li><code class="docutils literal"><span class="pre">LogicalBase</span></code> provides the API for logical updates (like get,
set, and commit) and defers to a concrete subclass to implement
the updates themselves. It also manages storage locking and
dereferencing internal nodes.</li>
<li><code class="docutils literal"><span class="pre">ValueRef</span></code> is a Python object that refers to a binary blob
stored in the database. The indirection lets us avoid loading the
entire data store into memory all at once.</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">binary_tree.py</span></code> defines a concrete binary tree algorithm
underneath the logical interface.<ul>
<li><code class="docutils literal"><span class="pre">BinaryTree</span></code> provides a concrete implementation of a binary
tree, with methods for getting, inserting, and deleting key/value
pairs. <code class="docutils literal"><span class="pre">BinaryTree</span></code> represents an immutable tree; updates are
performed by returning a new tree which shares common structure
with the old one.</li>
<li><code class="docutils literal"><span class="pre">BinaryNode</span></code> implements a node in the binary tree.</li>
<li><code class="docutils literal"><span class="pre">BinaryNodeRef</span></code> is a specialised <code class="docutils literal"><span class="pre">ValueRef</span></code> which knows how to
serialise and deserialise a <code class="docutils literal"><span class="pre">BinaryNode</span></code>.</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">physical.py</span></code> defines the physical layer. The <code class="docutils literal"><span class="pre">Storage</span></code> class
provides persistent, (mostly) append-only record storage.</li>
</ul>
<p>These modules grew from attempting to give each class a single
responsibility. In other words, each class should have only one reason
to change.</p>
<p class="rubric" id="reading-a-value">Reading a Value</p>
<p>We'll start with the simplest case: reading a value from the database.
Let's see what happens when we try to get the value associated with key
<code class="docutils literal"><span class="pre">foo</span></code> in <code class="docutils literal"><span class="pre">example.db</span></code>:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span>$ python -m dbdb.tool example.db get foo
</pre></div>
</div>
<p>This runs the <code class="docutils literal"><span class="pre">main()</span></code> function from module <code class="docutils literal"><span class="pre">dbdb.tool</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/tool.py</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">argv</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">):</span>
        <span class="n">usage</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BAD_ARGS</span>
    <span class="n">dbname</span><span class="p">,</span> <span class="n">verb</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="kc">None</span><span class="p">])[:</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verb</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;get&#39;</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">}:</span>
        <span class="n">usage</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BAD_VERB</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">dbdb</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">dbname</span><span class="p">)</span>          <span class="c1"># CONNECT</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verb</span> <span class="o">==</span> <span class="s1">&#39;get&#39;</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">db</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>  <span class="c1"># GET VALUE</span>
        <span class="k">elif</span> <span class="n">verb</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span><span class="p">:</span>
            <span class="n">db</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">db</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">db</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">db</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Key not found&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BAD_KEY</span>
    <span class="k">return</span> <span class="n">OK</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">connect()</span></code> function opens the database file (possibly creating
it, but never overwriting it) and returns an instance of <code class="docutils literal"><span class="pre">DBDB</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/__init__.py</span>
<span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">dbname</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">dbname</span><span class="p">,</span> <span class="s1">&#39;r+b&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dbname</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">O_CREAT</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fdopen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s1">&#39;r+b&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DBDB</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/interface.py</span>
<span class="k">class</span> <span class="nc">DBDB</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span> <span class="o">=</span> <span class="n">Storage</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">)</span>
</pre></div>
</div>
<p>We see right away that <code class="docutils literal"><span class="pre">DBDB</span></code> has a reference to an instance of
<code class="docutils literal"><span class="pre">Storage</span></code>, but it also shares that reference with <code class="docutils literal"><span class="pre">self._tree</span></code>. Why?
Can't <code class="docutils literal"><span class="pre">self._tree</span></code> manage access to the storage by itself?</p>
<p>The question of which objects &quot;own&quot; a resource is often an important one
in a design, because it gives us hints about what changes might be
unsafe. Let's keep that question in mind as we move on.</p>
<p>Once we have a DBDB instance, getting the value at <code class="docutils literal"><span class="pre">key</span></code> is done via a
dictionary lookup (<code class="docutils literal"><span class="pre">db[key]</span></code>), which causes the Python interpreter to
call <code class="docutils literal"><span class="pre">DBDB.__getitem__()</span></code>.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/interface.py</span>
<span class="k">class</span> <span class="nc">DBDB</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_not_closed</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_not_closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Database closed.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">__getitem__()</span></code> ensures that the database is still open by calling
<code class="docutils literal"><span class="pre">_assert_not_closed</span></code>. Aha! Here we see at least one reason why
<code class="docutils literal"><span class="pre">DBDB</span></code> needs direct access to our <code class="docutils literal"><span class="pre">Storage</span></code> instance: so it can
enforce preconditions. (Do you agree with this design? Can you think of
a different way that we could do this?)</p>
<p>DBDB then retrieves the value associated with <code class="docutils literal"><span class="pre">key</span></code> on the internal
<code class="docutils literal"><span class="pre">_tree</span></code> by calling <code class="docutils literal"><span class="pre">_tree.get()</span></code>, which is provided by
<code class="docutils literal"><span class="pre">LogicalBase</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/logical.py</span>
<span class="k">class</span> <span class="nc">LogicalBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="o">.</span><span class="n">locked</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_tree_ref</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_follow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_ref</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">get()</span></code> checks if we have the storage locked. We're not 100% sure
<em>why</em> there might be a lock here, but we can guess that it probably
exists to allow writers to serialize access to the data. What happens if
the storage isn't locked?</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/logical.py</span>
<span class="k">class</span> <span class="nc">LogicalBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1"># ...</span>
<span class="k">def</span> <span class="nf">_refresh_tree_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_ref_class</span><span class="p">(</span>
            <span class="n">address</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="o">.</span><span class="n">get_root_address</span><span class="p">())</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">_refresh_tree_ref</span></code> resets the tree's &quot;view&quot; of the data with what is
currently on disk, allowing us to perform a completely up-to-date read.</p>
<p>What if storage <em>is</em> locked when we attempt a read? This means that some
other process is probably changing the data we want to read right now;
our read is not likely to be up-to-date with the current state of the
data. This is generally known as a &quot;dirty read&quot;. This pattern allows
many readers to access data without ever worrying about blocking, at the
expense of being slightly out-of-date.</p>
<p>For now, let's take a look at how we actually retrieve the data:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/binary_tree.py</span>
<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">(</span><span class="n">LogicalBase</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_follow</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left_ref</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_follow</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right_ref</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_follow</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value_ref</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">KeyError</span>
</pre></div>
</div>
<p>This is a standard binary tree search, following refs to their nodes. We
know from reading the <code class="docutils literal"><span class="pre">BinaryTree</span></code> documentation that <code class="docutils literal"><span class="pre">Node</span></code>s and
<code class="docutils literal"><span class="pre">NodeRef</span></code>s are value objects: they are immutable and their contents
never change. <code class="docutils literal"><span class="pre">Node</span></code>s are created with an associated key and value,
and left and right children. Those associations also never change. The
content of the whole <code class="docutils literal"><span class="pre">BinaryTree</span></code> only visibly changes when the root
node is replaced. This means that we don't need to worry about the
contents of our tree being changed while we are performing the search.</p>
<p>Once the associated value is found, it is written to <code class="docutils literal"><span class="pre">stdout</span></code> by
<code class="docutils literal"><span class="pre">main()</span></code> without adding any extra newlines, to preserve the user's
data exactly.</p>
<p class="rubric" id="inserting-and-updating">Inserting and Updating</p>
<p>Now we'll set key <code class="docutils literal"><span class="pre">foo</span></code> to value <code class="docutils literal"><span class="pre">bar</span></code> in <code class="docutils literal"><span class="pre">example.db</span></code>:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span>$ python -m dbdb.tool example.db set foo bar
</pre></div>
</div>
<p>Again, this runs the <code class="docutils literal"><span class="pre">main()</span></code> function from module <code class="docutils literal"><span class="pre">dbdb.tool</span></code>.
Since we've seen this code before, we'll just highlight the important
parts:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/tool.py</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">argv</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">dbdb</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">dbname</span><span class="p">)</span>          <span class="c1"># CONNECT</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">elif</span> <span class="n">verb</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span><span class="p">:</span>
            <span class="n">db</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>            <span class="c1"># SET VALUE</span>
            <span class="n">db</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>                <span class="c1"># COMMIT</span>
        <span class="o">...</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>This time we set the value with <code class="docutils literal"><span class="pre">db[key]</span> <span class="pre">=</span> <span class="pre">value</span></code> which calls
<code class="docutils literal"><span class="pre">DBDB.__setitem__()</span></code>.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/interface.py</span>
<span class="k">class</span> <span class="nc">DBDB</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_not_closed</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">__setitem__</span></code> ensures that the database is still open and then stores
the association from <code class="docutils literal"><span class="pre">key</span></code> to <code class="docutils literal"><span class="pre">value</span></code> on the internal <code class="docutils literal"><span class="pre">_tree</span></code> by
calling <code class="docutils literal"><span class="pre">_tree.set()</span></code>.</p>
<p><code class="docutils literal"><span class="pre">_tree.set()</span></code> is provided by <code class="docutils literal"><span class="pre">LogicalBase</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/logical.py</span>
<span class="k">class</span> <span class="nc">LogicalBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="o">.</span><span class="n">lock</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_tree_ref</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_follow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_ref</span><span class="p">),</span> <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_ref_class</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">set()</span></code> first checks the storage lock:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/storage.py</span>
<span class="k">class</span> <span class="nc">Storage</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">lock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">locked</span><span class="p">:</span>
            <span class="n">portalocker</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">portalocker</span><span class="o">.</span><span class="n">LOCK_EX</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locked</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<p>There are two important things to note here:</p>
<ul class="simple">
<li>Our lock is provided by a 3rd-party file-locking library called
<a class="reference external" href="https://pypi.python.org/pypi/portalocker">portalocker</a>.</li>
<li><code class="docutils literal"><span class="pre">lock()</span></code> returns <code class="docutils literal"><span class="pre">False</span></code> if the database was already locked, and
<code class="docutils literal"><span class="pre">True</span></code> otherwise.</li>
</ul>
<p>Returning to <code class="docutils literal"><span class="pre">_tree.set()</span></code>, we can now understand why it checked the
return value of <code class="docutils literal"><span class="pre">lock()</span></code> in the first place: it lets us call
<code class="docutils literal"><span class="pre">_refresh_tree_ref</span></code> for the most recent root node reference so we
don't lose updates that another process may have made since we last
refreshed the tree from disk. Then it replaces the root tree node with a
new tree containing the inserted (or updated) key/value.</p>
<p>Inserting or updating the tree doesn't mutate any nodes, because
<code class="docutils literal"><span class="pre">_insert()</span></code> returns a new tree. The new tree shares unchanged parts
with the previous tree to save on memory and execution time. It's
natural to implement this recursively:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/binary_tree.py</span>
<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">(</span><span class="n">LogicalBase</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value_ref</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">BinaryNode</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_ref_class</span><span class="p">(),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_ref_class</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">BinaryNode</span><span class="o">.</span><span class="n">from_node</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">left_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_follow</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left_ref</span><span class="p">),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value_ref</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">BinaryNode</span><span class="o">.</span><span class="n">from_node</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">right_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_follow</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right_ref</span><span class="p">),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">BinaryNode</span><span class="o">.</span><span class="n">from_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value_ref</span><span class="o">=</span><span class="n">value_ref</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_ref_class</span><span class="p">(</span><span class="n">referent</span><span class="o">=</span><span class="n">new_node</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice how we always return a new node (wrapped in a <code class="docutils literal"><span class="pre">NodeRef</span></code>).
Instead of updating a node to point to a new subtree, we make a new node
which shares the unchanged subtree. This is what makes this binary tree
an immutable data structure.</p>
<p>You may have noticed something strange here: we haven't made any changes
to anything on disk yet. All we've done is manipulate our view of the
on-disk data by moving tree nodes around.</p>
<p>In order to actually write these changes to disk, we need an explicit
call to <code class="docutils literal"><span class="pre">commit()</span></code>, which we saw as the second part of our <code class="docutils literal"><span class="pre">set</span></code>
operation in <code class="docutils literal"><span class="pre">tool.py</span></code> at the beginning of this section.</p>
<p>Committing involves writing out all of the dirty state in memory, and
then saving the disk address of the tree's new root node.</p>
<p>Starting from the API:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/interface.py</span>
<span class="k">class</span> <span class="nc">DBDB</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_not_closed</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
</div>
<p>The implementation of <code class="docutils literal"><span class="pre">_tree.commit()</span></code> comes from <code class="docutils literal"><span class="pre">LogicalBase</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/logical.py</span>
<span class="k">class</span> <span class="nc">LogicalBase</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_ref</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="o">.</span><span class="n">commit_root_address</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_ref</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
</pre></div>
</div>
<p>All <code class="docutils literal"><span class="pre">NodeRef</span></code>s know how to serialise themselves to disk by first
asking their children to serialise via <code class="docutils literal"><span class="pre">prepare_to_store()</span></code>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/logical.py</span>
<span class="k">class</span> <span class="nc">ValueRef</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">storage</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_referent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_address</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_to_store</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_address</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">referent_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_referent</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">self._tree_ref</span></code> in <code class="docutils literal"><span class="pre">LogicalBase</span></code> is actually a <code class="docutils literal"><span class="pre">BinaryNodeRef</span></code> (a
subclass of <code class="docutils literal"><span class="pre">ValueRef</span></code>) in this case, so the concrete implementation
of <code class="docutils literal"><span class="pre">prepare_to_store()</span></code> is:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/binary_tree.py</span>
<span class="k">class</span> <span class="nc">BinaryNodeRef</span><span class="p">(</span><span class="n">ValueRef</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">prepare_to_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">storage</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_referent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_referent</span><span class="o">.</span><span class="n">store_refs</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">BinaryNode</span></code> in question, <code class="docutils literal"><span class="pre">_referent</span></code>, asks its refs to store
themselves:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/binary_tree.py</span>
<span class="k">class</span> <span class="nc">BinaryNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">store_refs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">storage</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value_ref</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_ref</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right_ref</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span>
</pre></div>
</div>
<p>This recurses all the way down for any <code class="docutils literal"><span class="pre">NodeRef</span></code> which has unwritten
changes (i.e., no <code class="docutils literal"><span class="pre">_address</span></code>).</p>
<p>Now we're back up the stack in <code class="docutils literal"><span class="pre">ValueRef</span></code>'s <code class="docutils literal"><span class="pre">store</span></code> method again.
The last step of <code class="docutils literal"><span class="pre">store()</span></code> is to serialise this node and save its
storage address:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/logical.py</span>
<span class="k">class</span> <span class="nc">ValueRef</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">storage</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_referent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_address</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_to_store</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_address</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">referent_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_referent</span><span class="p">))</span>
</pre></div>
</div>
<p>At this point the <code class="docutils literal"><span class="pre">NodeRef</span></code>'s <code class="docutils literal"><span class="pre">_referent</span></code> is guaranteed to have
addresses available for all of its own refs, so we serialise it by
creating a bytestring representing this node:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/binary_tree.py</span>
<span class="k">class</span> <span class="nc">BinaryNodeRef</span><span class="p">(</span><span class="n">ValueRef</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">referent_to_string</span><span class="p">(</span><span class="n">referent</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="n">referent</span><span class="o">.</span><span class="n">left_ref</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
            <span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="n">referent</span><span class="o">.</span><span class="n">key</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">referent</span><span class="o">.</span><span class="n">value_ref</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="n">referent</span><span class="o">.</span><span class="n">right_ref</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
            <span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="n">referent</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
        <span class="p">})</span>
</pre></div>
</div>
<p>Updating the address in the <code class="docutils literal"><span class="pre">store()</span></code> method is technically a mutation
of the <code class="docutils literal"><span class="pre">ValueRef</span></code>. Because it has no effect on the user-visible value,
we can consider it to be immutable.</p>
<p>Once <code class="docutils literal"><span class="pre">store()</span></code> on the root <code class="docutils literal"><span class="pre">_tree_ref</span></code> is complete (in
<code class="docutils literal"><span class="pre">LogicalBase.commit()</span></code>), we know that all of the data are written to
disk. We can now commit the root address by calling:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># dbdb/physical.py</span>
<span class="k">class</span> <span class="nc">Storage</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">commit_root_address</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_address</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seek_superblock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_integer</span><span class="p">(</span><span class="n">root_address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unlock</span><span class="p">()</span>
</pre></div>
</div>
<p>We ensure that the file handle is flushed (so that the OS knows we want
all the data saved to stable storage like an SSD) and write out the
address of the root node. We know this last write is atomic because we
store the disk address on a sector boundary. It's the very first thing
in the file, so this is true regardless of sector size, and
single-sector disk writes are guaranteed to be atomic by the disk
hardware.</p>
<p>Because the root node address has either the old or new value (never a
bit of old and a bit of new), other processes can read from the database
without getting a lock. An external process might see the old or the new
tree, but never a mix of the two. In this way, commits are atomic.</p>
<p>Because we write the new data to disk and call the <code class="docutils literal"><span class="pre">fsync</span></code>
syscall<a class="reference external" href="#fn2">:sup:`2`</a> before we write the root node address, uncommitted
data are unreachable. Conversely, once the root node address has been
updated, we know that all the data it references are also on disk. In
this way, commits are also durable.</p>
<p>We're done!</p>
<p class="rubric" id="how-noderefs-save-memory">How NodeRefs Save Memory</p>
<p>To avoid keeping the entire tree structure in memory at the same time,
when a logical node is read in from disk the disk address of its left
and right children (as well as its value) are loaded into memory.
Accessing children and their values requires one extra function call to
<code class="docutils literal"><span class="pre">NodeRef.get()</span></code> to dereference (&quot;really get&quot;) the data.</p>
<p>All we need to construct a <code class="docutils literal"><span class="pre">NodeRef</span></code> is an address:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">+---------+</span>
<span class="o">|</span> <span class="n">NodeRef</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">-------</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">addr</span><span class="o">=</span><span class="mi">3</span>  <span class="o">|</span>
<span class="o">|</span> <span class="n">get</span><span class="p">()</span>   <span class="o">|</span>
<span class="o">+---------+</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal"><span class="pre">get()</span></code> on it will return the concrete node, along with that
node's references as <code class="docutils literal"><span class="pre">NodeRef</span></code>s:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">+---------+</span>     <span class="o">+---------+</span>     <span class="o">+---------+</span>
<span class="o">|</span> <span class="n">NodeRef</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Node</span>    <span class="o">|</span>     <span class="o">|</span> <span class="n">NodeRef</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">-------</span> <span class="o">|</span>     <span class="o">|</span> <span class="o">-------</span> <span class="o">|</span> <span class="o">+-&gt;</span> <span class="o">|</span> <span class="o">-------</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">addr</span><span class="o">=</span><span class="mi">3</span>  <span class="o">|</span>     <span class="o">|</span> <span class="n">key</span><span class="o">=</span><span class="n">A</span>   <span class="o">|</span> <span class="o">|</span>   <span class="o">|</span> <span class="n">addr</span><span class="o">=</span><span class="mi">1</span>  <span class="o">|</span>
<span class="o">|</span> <span class="n">get</span><span class="p">()</span> <span class="o">------&gt;</span> <span class="o">|</span> <span class="n">value</span><span class="o">=</span><span class="n">B</span> <span class="o">|</span> <span class="o">|</span>   <span class="o">+---------+</span>
<span class="o">+---------+</span>     <span class="o">|</span> <span class="n">left</span>  <span class="o">----+</span>
                <span class="o">|</span> <span class="n">right</span> <span class="o">----+</span>   <span class="o">+---------+</span>
                <span class="o">+---------+</span> <span class="o">|</span>   <span class="o">|</span> <span class="n">NodeRef</span> <span class="o">|</span>
                            <span class="o">+-&gt;</span> <span class="o">|</span> <span class="o">-------</span> <span class="o">|</span>
                                <span class="o">|</span> <span class="n">addr</span><span class="o">=</span><span class="mi">2</span>  <span class="o">|</span>
                                <span class="o">+---------+</span>
</pre></div>
</div>
<p>When changes to the tree are not committed, they exist in memory with
references from the root down to the changed leaves. The changes aren't
saved to disk yet, so the changed nodes contain concrete keys and values
and no disk addresses. The process doing the writing can see uncommitted
changes and can make more changes before issuing a commit, because
<code class="docutils literal"><span class="pre">NodeRef.get()</span></code> will return the uncommitted value if it has one; there
is no difference between committed and uncommitted data when accessed
through the API. All the updates will appear atomically to other readers
because changes aren't visible until the new root node address is
written to disk. Concurrent updates are blocked by a lockfile on disk.
The lock is acquired on first update, and released after commit.</p>
<p class="rubric" id="exercises-for-the-reader">Exercises for the Reader</p>
<p>DBDB allows many processes to read the same database at once without
blocking; the tradeoff is that readers can sometimes retrieve stale
data. What if we needed to be able to read some data consistently? A
common use case is reading a value and then updating it based on that
value. How would you write a method on <code class="docutils literal"><span class="pre">DBDB</span></code> to do this? What
tradeoffs would you have to incur to provide this functionality?</p>
<p>The algorithm used to update the data store can be completely changed
out by replacing the string <code class="docutils literal"><span class="pre">BinaryTree</span></code> in <code class="docutils literal"><span class="pre">interface.py</span></code>. Data
stores tend to use more complex types of search trees such as B-trees,
B+ trees, and others to improve the performance. While a balanced binary
tree (and this one isn't) needs to do \(O(log_2(n))\) random node
reads to find a value, a B+ tree needs many fewer, for example
\(O(log_{32}(n))\) because each node splits 32 ways instead of just
2. This makes a huge different in practice, since looking through 4
billion entries would go from \(log_2(2^{32}) = 32\) to
\(log_{32}(2^{32}) \approx 6.4\) lookups. Each lookup is a random
access, which is incredibly expensive for hard disks with spinning
platters. SSDs help with the latency, but the savings in I/O still
stand.</p>
<p>By default, values are stored by <code class="docutils literal"><span class="pre">ValueRef</span></code> which expects bytes as
values (to be passed directly to <code class="docutils literal"><span class="pre">Storage</span></code>). The binary tree nodes
themselves are just a sublcass of <code class="docutils literal"><span class="pre">ValueRef</span></code>. Storing richer data via
<a class="reference external" href="http://json.org">json</a> or <a class="reference external" href="http://msgpack.org">msgpack</a> is a matter of writing your own and setting it as
the <code class="docutils literal"><span class="pre">value_ref_class</span></code>. <code class="docutils literal"><span class="pre">BinaryNodeRef</span></code> is an example of using
<a class="reference external" href="https://docs.python.org/3.4/library/pickle.html">pickle</a> to serialise data.</p>
<p>Database compaction is another interesting exercise. Compacting can be
done via an infix-of-median traversal of the tree writing things out as
you go. It's probably best if the tree nodes all go together, since
they're what's traversed to find any piece of data. Packing as many
intermediate nodes as possible into a disk sector should improve read
performance, at least right after compaction. There are some subtleties
here (for example, memory usage) if you try to implement this yourself.
And remember: always benchmark performance enhancements before and
after! You'll often be surprised by the results.</p>
<p class="rubric" id="patterns-and-principles">Patterns and Principles</p>
<p>Test interfaces, not implementation. As part of developing DBDB, I wrote
a number of tests that described how I wanted to be able to use it. The
first tests ran against an in-memory version of the database, then I
extended DBDB to persist to disk, and even later added the concept of
NodeRefs. Most of the tests didn't have to change, which gave me
confidence that things were still working.</p>
<p>Respect the Single Responsibility Principle. Classes should have at most
one reason to change. That's not strictly the case with DBDB, but there
are multiple avenues of extension with only localised changes required.
Refactoring as I added features was a pleasure!</p>
<p class="rubric" id="summary">Summary</p>
<p>DBDB is a simple database that makes simple guarantees, and yet things
still became complicated in a hurry. The most important thing I did to
manage this complexity was to implement an ostensibly mutable object
with an immutable data structure. I encourage you to consider this
technique the next time you find yourself in the middle of a tricky
problem that seems to have more edge cases than you can keep track of.</p>
<div class="footnotes"><hr class="docutils" />
<ol class="arabic">
<li><div class="first"><div id="fn1"></div></div><p>Bonus feature: Can you guarantee that the compacted tree structure is
balanced? This helps maintain performance over time.<a class="reference external" href="#fnref1">↩</a></p>
</li>
<li><div class="first"><div id="fn2"></div></div><p>Calling <code class="docutils literal"><span class="pre">fsync</span></code> on a file descriptor asks the operating system and
hard drive (or SSD) to write all buffered data immediately. Operating
systems and drives don't usually write everything immediately in
order to improve performance.<a class="reference external" href="#fnref2">↩</a></p>
</li>
</ol>
</div></div></div></div></div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Learn-Computer-and-Math-again</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="blockcode-a-visual-programming-toolkit.html">500 Lines or Less | Blockcode: A visual programming toolkit</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, timger.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/chapters/dbdb-dog-bed-database.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>