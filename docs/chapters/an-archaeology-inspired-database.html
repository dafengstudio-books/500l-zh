
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>500 Lines or Less | An Archaeology-Inspired Database &#8212; Learn-Computer-and-Math-again 0.0.1 文档</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lines-or-less-an-archaeology-inspired-database">
<h1>500 Lines or Less | An Archaeology-Inspired Database<a class="headerlink" href="#lines-or-less-an-archaeology-inspired-database" title="永久链接至标题">¶</a></h1>
<div class="container"><div class="row"><div class="hero-unit"><p><a href="#id1"><span class="problematic" id="id2">``</span></a>_
.. rubric:: An Archaeology-Inspired Database</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">an-archaeology-inspired-database</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p class="author rubric" id="yoav-rubin">Yoav Rubin</p>
</div></div><div class="row"><div id="content" class="span10 offset1"><p><em>Yoav Rubin is a Senior Software Engineer at Microsoft, and prior to
that was a Research Staff Member and a Master Inventor at IBM Research.
He works now in the domain of data security in the cloud, and in the
past his work focused on developing cloud or web based development
environments. Yoav holds an M.Sc. in Medical Research in the field of
Neuroscience and B.Sc in Information Systems Engineering. He goes by
`&#64;yoavrubin`_ on Twitter, and occasionally blogs at
http://yoavrubin.blogspot.com.</em></p>
<p class="rubric" id="introduction">Introduction</p>
<p>Software development is often viewed as a rigorous process, where the
inputs are requirements and the output is the working product. However,
software developers are people, with their own perspectives and biases
which color the outcome of their work.</p>
<p>In this chapter, we will explore how a change in a common perspective
affects the design and implementation of a well-studied type of
software: a database.</p>
<p>Database systems are designed to store and query data. This is something
that all information workers do; however, the systems themselves were
designed by computer scientists. As a result, modern database systems
are highly influenced by computer scientists’ definition of what data
is, and what can be done with it.</p>
<p>For example, most modern databases implement updates by overwriting old
data in-place instead of appending the new data and keeping the old.
This mechanism, nicknamed &quot;place-oriented programming&quot; by <a class="reference external" href="http://www.infoq.com/presentations/Value-Values">Rich
Hickey</a>, saves storage space but makes it impossible to retrieve the
entire history of a particular record. This design decision reflects the
computer scientist’s perspective that &quot;history&quot; is less important than
the price of its storage.</p>
<p>If you were to instead ask an archaeologist where the old data can be
found, the answer would be &quot;hopefully, it's just buried underneath&quot;.</p>
<p>(Disclaimer: My understanding of the views of a typical archaeologist is
based on visiting a few museums, reading several Wikipedia articles, and
watching the entire Indiana Jones series.)</p>
<p class="rubric" id="designing-a-database-like-an-archaeologist">Designing a Database Like an Archaeologist</p>
<p>If we were to ask our friendly archaeologist to design a database, we
might expect the requirements to reflect what would be found at an
excavation site:</p>
<ul class="simple">
<li>All data is found and catalogued at the site.</li>
<li>Digging deeper will expose the state of things in times past.</li>
<li>Artifacts found at the same layer are from the same period.</li>
<li>Each artifact will consist of state that it accumulated in different
periods.</li>
</ul>
<p>For example, a wall may have Roman symbols on it on one layer, and in a
lower layer there may be Greek symbols. Both these observations are
recorded as part of the wall's state.</p>
<p>This analogy is visualized in <a class="reference external" href="#figure-10.1">Figure 10.1</a>:</p>
<ul class="simple">
<li>The entire circle is the excavation site.</li>
<li>Each ring is a <em>layer</em> (here numbered from 0 to 4).</li>
<li>Each slice is a labeled artifact (‘A’ through ‘E’).</li>
<li>Each artifact has a ‘symbol’ attribute (where a blank means that no
update was made).</li>
<li>Solid arrows denote a change in symbol between layers</li>
<li>Dotted arrows are arbitrary relationships of interest between
artifacts (e.g., from ‘E’ to ‘A’).</li>
</ul>
<div class="center figure"><p><img alt="Figure 10.1 - The Excavation Site" src="chapters/functionalDB-images/image_0.png" /></p>
</div><p>Figure 10.1 - The Excavation Site</p>
<p>If we translate the archaeologist's language into terms a database
designer would use:</p>
<ul class="simple">
<li>The excavation site is a <em>database</em>.</li>
<li>Each artifact is an <em>entity</em> with a corresponding <em>ID</em>.</li>
<li>Each entity has a set of <em>attributes</em>, which may change over time.</li>
<li>Each attribute has a specific <em>value</em> at a specific time.</li>
</ul>
<p>This may look very different from the kinds of databases you are used to
working with. This design is sometimes referred to as &quot;functional
database&quot;, since it uses ideas from the domain of functional
programming. The rest of the chapter describes how to implement such a
database.</p>
<p>Since we are building a functional database, we will be using a
functional programming language called Clojure.</p>
<p>Clojure has several qualities that make it a good implementation
language for a functional database, such as out-of-the-box immutability,
higher order functions, and metaprogramming facilities. But ultimately,
the reason Clojure was chosen was its emphasis on clean, rigorous
design, which few programming languages possess.</p>
<p class="rubric" id="laying-the-foundation">Laying the Foundation</p>
<p>Let’s start by declaring the core constructs that make up our database.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defrecord</span> <span class="n">Database</span> <span class="p">[</span><span class="n">layers</span> <span class="n">top</span><span class="o">-</span><span class="nb">id</span> <span class="n">curr</span><span class="o">-</span><span class="n">time</span><span class="p">])</span>
</pre></div>
</div>
<p>A database consists of:</p>
<ol class="arabic simple">
<li>Layers of entities, each with its own unique timestamp (the rings in
Figure 1).</li>
<li>A top-id value which is the next available unique ID.</li>
<li>The time at which the database was last updated.</li>
</ol>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defrecord</span> <span class="n">Layer</span> <span class="p">[</span><span class="n">storage</span> <span class="n">VAET</span> <span class="n">AVET</span> <span class="n">VEAT</span> <span class="n">EAVT</span><span class="p">])</span>
</pre></div>
</div>
<p>Each layer consists of:</p>
<ol class="arabic simple">
<li>A data store for entities.</li>
<li>Indexes that are used to speed up queries to the database. (These
indexes and the meaning of their names will be explained later.)</li>
</ol>
<p>In our design, a single conceptual ‘database’ may consist of many
<code class="docutils literal"><span class="pre">Database</span></code> instances, each of which represents a snapshot of the
database at <code class="docutils literal"><span class="pre">curr-time</span></code>. A <code class="docutils literal"><span class="pre">Layer</span></code> may share the exact same entity
with another <code class="docutils literal"><span class="pre">Layer</span></code> if the entity’s state hasn’t changed between the
times that they represent.</p>
<p class="rubric" id="entities">Entities</p>
<p>Our database wouldn't be of any use without entities to store, so we
define those next. As discussed before, an entity has an ID and a list
of attributes; we create them using the <code class="docutils literal"><span class="pre">make-entity</span></code> function.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defrecord</span> <span class="n">Entity</span> <span class="p">[</span><span class="nb">id</span> <span class="n">attrs</span><span class="p">])</span>

<span class="p">(</span><span class="n">defn</span> <span class="n">make</span><span class="o">-</span><span class="n">entity</span>
   <span class="p">([]</span> <span class="p">(</span><span class="n">make</span><span class="o">-</span><span class="n">entity</span> <span class="p">:</span><span class="n">db</span><span class="o">/</span><span class="n">no</span><span class="o">-</span><span class="nb">id</span><span class="o">-</span><span class="n">yet</span><span class="p">))</span>
   <span class="p">([</span><span class="nb">id</span><span class="p">]</span> <span class="p">(</span><span class="n">Entity</span><span class="o">.</span>  <span class="nb">id</span> <span class="p">{})))</span>
</pre></div>
</div>
<p>Note that if no ID is given, the entity’s ID is set to be
<code class="docutils literal"><span class="pre">:db/no-id-yet</span></code>, which means that something else is responsible for
giving it an ID. We’ll see how that works later.</p>
<p class="rubric" id="attributes">Attributes</p>
<p>Each attribute consists of its name, value, and the timestamps of its
most recent update as well as the one before that. Each attribute also
has two fields that describe its <code class="docutils literal"><span class="pre">type</span></code> and <code class="docutils literal"><span class="pre">cardinality</span></code>.</p>
<p>In the case that an attribute is used to represent a relationship to
another entity, its <code class="docutils literal"><span class="pre">type</span></code> will be <code class="docutils literal"><span class="pre">:db/ref</span></code> and its value will be
the ID of the related entity. This simple type system also acts as an
extension point. Users are free to define their own types and leverage
them to provide additional semantics for their data.</p>
<p>An attribute's <code class="docutils literal"><span class="pre">cardinality</span></code> specifies whether the attribute
represents a single value or a set of values. We use this field to
determine the set of operations that are permitted on this attribute.</p>
<p>Creating an attribute is done using the <code class="docutils literal"><span class="pre">make-attr</span></code> function.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(defrecord Attr [name value ts prev-ts])

(defn make-attr
   ([name value type ; these ones are required
       &amp; {:keys [cardinality] :or {cardinality :db/single}} ]
     {:pre [(contains? #{:db/single :db/multiple} cardinality)]}
    (with-meta (Attr. name value -1 -1) {:type type :cardinality cardinality})))
</pre></div>
</div>
<p>There are a couple of interesting patterns used in this constructor
function:</p>
<ul class="simple">
<li>We use Clojure’s <em>Design by Contract</em> pattern to validate that the
cardinality parameter is a permissible value.</li>
<li>We use Clojure’s destructuring mechanism to provide a default value
of <code class="docutils literal"><span class="pre">:db/single</span></code> if one is not given.</li>
<li>We use Clojure’s metadata capabilities to distinguish between an
attribute's data (name, value and timestamps) and its metadata (type
and cardinality). In Clojure, metadata handling is done using the
functions <code class="docutils literal"><span class="pre">with-meta</span></code> (to set) and <code class="docutils literal"><span class="pre">meta</span></code> (to read).</li>
</ul>
<p>Attributes only have meaning if they are part of an entity. We make this
connection with the <code class="docutils literal"><span class="pre">add-attr</span></code> function, which adds a given attribute
to an entity's attribute map (called <code class="docutils literal"><span class="pre">:attrs</span></code>).</p>
<p>Note that instead of using the attribute’s name directly, we first
convert it into a keyword to adhere to Clojure’s idiomatic usage of
maps.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">add</span><span class="o">-</span><span class="n">attr</span> <span class="p">[</span><span class="n">ent</span> <span class="n">attr</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">attr</span><span class="o">-</span><span class="nb">id</span> <span class="p">(</span><span class="n">keyword</span> <span class="p">(:</span><span class="n">name</span> <span class="n">attr</span><span class="p">))]</span>
      <span class="p">(</span><span class="n">assoc</span><span class="o">-</span><span class="ow">in</span> <span class="n">ent</span> <span class="p">[:</span><span class="n">attrs</span> <span class="n">attr</span><span class="o">-</span><span class="nb">id</span><span class="p">]</span> <span class="n">attr</span><span class="p">)))</span>
</pre></div>
</div>
<p class="rubric" id="storage">Storage</p>
<p>So far we have talked a lot about <em>what</em> we are going to store, without
thinking about <em>where</em> we are going to store it. In this chapter, we
resort to the simplest storage mechanism: storing the data in memory.
This is certainly not reliable, but it simplifies development and
debugging and allows us to focus on more interesting parts of the
program.</p>
<p>We will access the storage via a simple <em>protocol</em>, which will make it
possible to define additional storage providers for a database owner to
select from.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defprotocol</span> <span class="n">Storage</span>
   <span class="p">(</span><span class="n">get</span><span class="o">-</span><span class="n">entity</span> <span class="p">[</span><span class="n">storage</span> <span class="n">e</span><span class="o">-</span><span class="nb">id</span><span class="p">]</span> <span class="p">)</span>
   <span class="p">(</span><span class="n">write</span><span class="o">-</span><span class="n">entity</span> <span class="p">[</span><span class="n">storage</span> <span class="n">entity</span><span class="p">])</span>
   <span class="p">(</span><span class="n">drop</span><span class="o">-</span><span class="n">entity</span> <span class="p">[</span><span class="n">storage</span> <span class="n">entity</span><span class="p">]))</span>
</pre></div>
</div>
<p>And here's our in-memory implementation of the protocol, which uses a
map as the store:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defrecord</span> <span class="n">InMemory</span> <span class="p">[]</span> <span class="n">Storage</span>
   <span class="p">(</span><span class="n">get</span><span class="o">-</span><span class="n">entity</span> <span class="p">[</span><span class="n">storage</span> <span class="n">e</span><span class="o">-</span><span class="nb">id</span><span class="p">]</span> <span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="nb">id</span> <span class="n">storage</span><span class="p">))</span>
   <span class="p">(</span><span class="n">write</span><span class="o">-</span><span class="n">entity</span> <span class="p">[</span><span class="n">storage</span> <span class="n">entity</span><span class="p">]</span> <span class="p">(</span><span class="n">assoc</span> <span class="n">storage</span> <span class="p">(:</span><span class="nb">id</span> <span class="n">entity</span><span class="p">)</span> <span class="n">entity</span><span class="p">))</span>
   <span class="p">(</span><span class="n">drop</span><span class="o">-</span><span class="n">entity</span> <span class="p">[</span><span class="n">storage</span> <span class="n">entity</span><span class="p">]</span> <span class="p">(</span><span class="n">dissoc</span> <span class="n">storage</span> <span class="p">(:</span><span class="nb">id</span> <span class="n">entity</span><span class="p">))))</span>
</pre></div>
</div>
<p class="rubric" id="indexing-the-data">Indexing the Data</p>
<p>Now that we've defined the basic elements of our database, we can start
thinking about how we're going to query it. By virtue of how we've
structured our data, any query is necessarily going to be interested in
at least one of an entity's ID, and the name and value of some of its
attributes. This triplet of
<code class="docutils literal"><span class="pre">(entity-id,</span> <span class="pre">attribute-name,</span> <span class="pre">attribute-value)</span></code> is important enough to
our query process that we give it an explicit name: a <em>datom</em>.</p>
<p>Datoms are important because they represent facts, and our database
accumulates facts.</p>
<p>If you've used a database system before, you are probably already
familiar with the concept of an <em>index</em>, which is a supporting data
structure that consumes extra space in order to decrease the average
query time. In our database, an index is a three-leveled structure which
stores the components of a datom in a specific order. Each index derives
its name from the order it stores the datom's components in.</p>
<p>For example, let’s look at at the index sketched in <a class="reference external" href="#figure-10.2">Figure 10.2</a>:</p>
<ul class="simple">
<li>The first level stores entity-IDs</li>
<li>The second level stores the related attribute-names</li>
<li>The third level stores the related value</li>
</ul>
<p>This index is named EAVT, as the top level map holds Entity IDs, the
second level holds Attribute names, and the leaves hold Values. The &quot;T&quot;
comes from the fact that each layer in the database has its own indexes,
hence the index itself is relevant for a specific Time.</p>
<div class="center figure"><p><img alt="Figure 10.2 - EAVT" src="chapters/functionalDB-images/image_1.png" /></p>
</div><p>Figure 10.2 - EAVT</p>
<p><a class="reference external" href="#figure-10.3">Figure 10.3</a> shows an index that would be called AVET since:</p>
<ul class="simple">
<li>The first level map holds attribute-name.</li>
<li>The second level map holds the values (of the attributes).</li>
<li>The third level set holds the entity-IDs (of the entities whose
attribute is at the first level).</li>
</ul>
<div class="center figure"><p><img alt="Figure 10.3 - AVET" src="chapters/functionalDB-images/image_2.png" /></p>
</div><p>Figure 10.3 - AVET</p>
<p>Our indexes are implemented as a map of maps, where the keys of the root
map act as the first level, each such key points to a map whose keys act
as the index’s second-level and the values are the index’s third level.
Each element in the third level is a set, holding the leaves of the
index.</p>
<p>Each index stores the components of a datom as some permutation of its
canonical 'EAV' ordering (entity_id, attribute-name, attribute-value).
However, when we are working with datoms <em>outside</em> of the index, we
expect them to be in canonical format. We thus provide each index with
functions <code class="docutils literal"><span class="pre">from-eav</span></code> and <code class="docutils literal"><span class="pre">to-eav</span></code> to convert to and from these
orderings.</p>
<p>In most database systems, indexes are an optional component; for
example, in an RDBMS (Relational Database Management System) like
PostgreSQL or MySQL, you will choose to add indexes only to certain
columns in a table. We provide each index with a <code class="docutils literal"><span class="pre">usage-pred</span></code> function
that determines for an attribute whether it should be included in this
index or not.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">make</span><span class="o">-</span><span class="n">index</span> <span class="p">[</span><span class="n">from</span><span class="o">-</span><span class="n">eav</span> <span class="n">to</span><span class="o">-</span><span class="n">eav</span> <span class="n">usage</span><span class="o">-</span><span class="n">pred</span><span class="p">]</span>
    <span class="p">(</span><span class="k">with</span><span class="o">-</span><span class="n">meta</span> <span class="p">{}</span> <span class="p">{:</span><span class="n">from</span><span class="o">-</span><span class="n">eav</span> <span class="n">from</span><span class="o">-</span><span class="n">eav</span> <span class="p">:</span><span class="n">to</span><span class="o">-</span><span class="n">eav</span> <span class="n">to</span><span class="o">-</span><span class="n">eav</span> <span class="p">:</span><span class="n">usage</span><span class="o">-</span><span class="n">pred</span> <span class="n">usage</span><span class="o">-</span><span class="n">pred</span><span class="p">}))</span>

 <span class="p">(</span><span class="n">defn</span> <span class="n">from</span><span class="o">-</span><span class="n">eav</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">(:</span><span class="n">from</span><span class="o">-</span><span class="n">eav</span> <span class="p">(</span><span class="n">meta</span> <span class="n">index</span><span class="p">)))</span>
 <span class="p">(</span><span class="n">defn</span> <span class="n">to</span><span class="o">-</span><span class="n">eav</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">(:</span><span class="n">to</span><span class="o">-</span><span class="n">eav</span> <span class="p">(</span><span class="n">meta</span> <span class="n">index</span><span class="p">)))</span>
 <span class="p">(</span><span class="n">defn</span> <span class="n">usage</span><span class="o">-</span><span class="n">pred</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">(:</span><span class="n">usage</span><span class="o">-</span><span class="n">pred</span> <span class="p">(</span><span class="n">meta</span> <span class="n">index</span><span class="p">)))</span>
</pre></div>
</div>
<p>In our database there are four indexes: EAVT (see <a class="reference external" href="#figure-10.2">Figure 10.2</a>), AVET
(see <a class="reference external" href="#figure-10.3">Figure 10.3</a>), VEAT and VAET. We can access these as a vector of
values returned from the <code class="docutils literal"><span class="pre">indexes</span></code> function.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">indexes</span><span class="p">[]</span> <span class="p">[:</span><span class="n">VAET</span> <span class="p">:</span><span class="n">AVET</span> <span class="p">:</span><span class="n">VEAT</span> <span class="p">:</span><span class="n">EAVT</span><span class="p">])</span>
</pre></div>
</div>
<p>To demonstrate how all of this comes together, the result of indexing
the following five entities is visualized in Table 10.1.</p>
<ol class="arabic simple">
<li>Julius Caesar (also known as JC) lives in Rome</li>
<li>Brutus (also known as B) lives in Rome</li>
<li>Cleopatra (also known as Cleo) lives in Egypt</li>
<li>Rome’s river is the Tiber</li>
<li>Egypt’s river is the Nile</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>EAVT index</td>
<td>AVET index</td>
</tr>
<tr class="row-even"><td><ul class="first last simple">
<li>JC ⇒ {lives-in ⇒ {Rome}}</li>
<li>B ⇒ {lives-in ⇒ {Rome}}</li>
<li>Cleo ⇒ {lives-in ⇒ {Egypt}}</li>
<li>Rome ⇒ {river ⇒ {Tiber}}</li>
<li>Egypt ⇒ {river ⇒ {Nile}}</li>
</ul>
</td>
<td><ul class="first last simple">
<li>lives-in ⇒ {Rome ⇒ {JC, B}}
{Egypt ⇒ {Cleo}}</li>
<li>river ⇒ {Rome ⇒ {Tiber}} {Egypt ⇒
{Nile}}</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>VEAT index</td>
<td>VAET index</td>
</tr>
<tr class="row-even"><td><ul class="first last simple">
<li>Rome ⇒ {JC ⇒ {lives-in}}
{B ⇒ {lives-in}}</li>
<li>Egypt ⇒ {Cleo ⇒ {lives-in}}</li>
<li>Tiber ⇒ {Rome ⇒ {river}}</li>
<li>Nile ⇒ {Egypt ⇒ {river}}</li>
</ul>
</td>
<td><ul class="first last simple">
<li>Rome ⇒ {lives-in ⇒ {JC, B}}</li>
<li>Egypt ⇒ {lives-in ⇒ {Cleo}}</li>
<li>Tiber ⇒ {river ⇒ {Rome}}</li>
<li>Nile ⇒ {river ⇒ {Egypt}}</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>: <strong>Table 10.1</strong> - Indexes</p>
<p class="rubric" id="database">Database</p>
<p>We now have all the components we need to construct our database.
Initializing our database means:</p>
<ul class="simple">
<li>creating an initial empty layer with no data</li>
<li>creating a set of empty indexes</li>
<li>setting its <code class="docutils literal"><span class="pre">top-id</span></code> and <code class="docutils literal"><span class="pre">curr-time</span></code> to be 0</li>
</ul>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(defn ref? [attr] (= :db/ref (:type (meta attr))))

(defn always[&amp; more] true)

(defn make-db []
   (atom
       (Database. [(Layer.
                   (fdb.storage.InMemory.) ; storage
                   (make-index #(vector %3 %2 %1) #(vector %3 %2 %1) #(ref? %));VAET
                   (make-index #(vector %2 %3 %1) #(vector %3 %1 %2) always);AVET
                   (make-index #(vector %3 %1 %2) #(vector %2 %3 %1) always);VEAT
                   (make-index #(vector %1 %2 %3) #(vector %1 %2 %3) always);EAVT
                  )] 0 0)))
</pre></div>
</div>
<p>There is one snag, though: all collections in Clojure are immutable.
Since write operations are pretty critical in a database, we define our
structure to be an <em>Atom</em>, which is a Clojure reference type that
provides the capability of atomic writes.</p>
<p>You may be wondering why we use the <code class="docutils literal"><span class="pre">always</span></code> function for the AVET,
VEAT and EAVT indexes, and the <code class="docutils literal"><span class="pre">ref?</span></code> predicate for the VAET index.
This is because these indexes are used in different scenarios, which
we’ll see later when we explore queries in depth.</p>
<p class="rubric" id="basic-accessors">Basic Accessors</p>
<p>Before we can build complex querying facilities for our database, we
need to provide a lower-level API that different parts of the system can
use to retrieve the components we've built by their associated
identifiers from any point in time. Consumers of the database can also
use this API; however, it is more likely that they will be using the
more fully-featured components built on top of it.</p>
<p>This lower-level API is composed of the following four accessor
functions:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">entity</span><span class="o">-</span><span class="n">at</span>
   <span class="p">([</span><span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span><span class="p">]</span> <span class="p">(</span><span class="n">entity</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="p">(:</span><span class="n">curr</span><span class="o">-</span><span class="n">time</span> <span class="n">db</span><span class="p">)</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span><span class="p">))</span>
   <span class="p">([</span><span class="n">db</span> <span class="n">ts</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span><span class="p">]</span> <span class="p">(</span><span class="n">get</span><span class="o">-</span><span class="n">entity</span> <span class="p">(</span><span class="n">get</span><span class="o">-</span><span class="ow">in</span> <span class="n">db</span> <span class="p">[:</span><span class="n">layers</span> <span class="n">ts</span> <span class="p">:</span><span class="n">storage</span><span class="p">])</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span><span class="p">)))</span>

<span class="p">(</span><span class="n">defn</span> <span class="n">attr</span><span class="o">-</span><span class="n">at</span>
   <span class="p">([</span><span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span><span class="p">]</span> <span class="p">(</span><span class="n">attr</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span> <span class="p">(:</span><span class="n">curr</span><span class="o">-</span><span class="n">time</span> <span class="n">db</span><span class="p">)))</span>
   <span class="p">([</span><span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span> <span class="n">ts</span><span class="p">]</span> <span class="p">(</span><span class="n">get</span><span class="o">-</span><span class="ow">in</span> <span class="p">(</span><span class="n">entity</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="n">ts</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span><span class="p">)</span> <span class="p">[:</span><span class="n">attrs</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span><span class="p">])))</span>

<span class="p">(</span><span class="n">defn</span> <span class="n">value</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">at</span>
   <span class="p">([</span><span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span><span class="p">]</span>  <span class="p">(:</span><span class="n">value</span> <span class="p">(</span><span class="n">attr</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span><span class="p">)))</span>
   <span class="p">([</span><span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span> <span class="n">ts</span><span class="p">]</span> <span class="p">(:</span><span class="n">value</span> <span class="p">(</span><span class="n">attr</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span> <span class="n">ts</span><span class="p">))))</span>

<span class="p">(</span><span class="n">defn</span> <span class="n">indx</span><span class="o">-</span><span class="n">at</span>
   <span class="p">([</span><span class="n">db</span> <span class="n">kind</span><span class="p">]</span> <span class="p">(</span><span class="n">indx</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="n">kind</span> <span class="p">(:</span><span class="n">curr</span><span class="o">-</span><span class="n">time</span> <span class="n">db</span><span class="p">)))</span>
   <span class="p">([</span><span class="n">db</span> <span class="n">kind</span> <span class="n">ts</span><span class="p">]</span> <span class="p">(</span><span class="n">kind</span> <span class="p">((:</span><span class="n">layers</span> <span class="n">db</span><span class="p">)</span> <span class="n">ts</span><span class="p">))))</span>
</pre></div>
</div>
<p>Since we treat our database just like any other value, each of these
functions take a database as an argument. Each element is retrieved by
its associated identifier, and optionally the timestamp of interest.
This timestamp is used to find the corresponding layer that our lookup
should be applied to.</p>
<p class="rubric" id="evolution">Evolution</p>
<p>A first usage of the basic accessors is to provide a
&quot;read-into-the-past&quot; API. This is possible as, in our database, an
update operation is done by appending a new layer (as opposed to
overwriting). Therefore we can use the <code class="docutils literal"><span class="pre">prev-ts</span></code> property to look at
the attribute at that layer, and continue looking deeper into history to
observe how the attribute’s value evolved throughout time.</p>
<p>The function <code class="docutils literal"><span class="pre">evolution-of</span></code> does exactly that. It returns a sequence
of pairs, each consisting of the timestamp and value of an attribute’s
update.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">evolution</span><span class="o">-</span><span class="n">of</span> <span class="p">[</span><span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span><span class="p">]</span>
   <span class="p">(</span><span class="n">loop</span> <span class="p">[</span><span class="n">res</span> <span class="p">[]</span> <span class="n">ts</span> <span class="p">(:</span><span class="n">curr</span><span class="o">-</span><span class="n">time</span> <span class="n">db</span><span class="p">)]</span>
     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">reverse</span> <span class="n">res</span><span class="p">)</span>
         <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">attr</span> <span class="p">(</span><span class="n">attr</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span> <span class="n">ts</span><span class="p">)]</span>
           <span class="p">(</span><span class="n">recur</span> <span class="p">(</span><span class="n">conj</span> <span class="n">res</span> <span class="p">{(:</span><span class="n">ts</span> <span class="n">attr</span><span class="p">)</span> <span class="p">(:</span><span class="n">value</span> <span class="n">attr</span><span class="p">)})</span>  <span class="p">(:</span><span class="n">prev</span><span class="o">-</span><span class="n">ts</span> <span class="n">attr</span><span class="p">))))))</span>
</pre></div>
</div>
<p class="rubric" id="data-behavior-and-life-cycle">Data Behavior and Life Cycle</p>
<p>So far, our discussion has focused on the structure of our data: what
the core components are and how they are aggregated together. It's time
to explore the dynamics of our system: how data is changed over time
through the add--update--remove <em>data lifecycle</em>.</p>
<p>As we've already discussed, data in an archaeologist's world never
actually changes. Once it is created, it exists forever and can only be
hidden from the world by data in a newer layer. The term &quot;hidden&quot; is
crucial here. Older data does not &quot;disappear&quot;—it is buried, and can be
revealed again by exposing an older layer. Conversely, updating data
means obscuring the old by adding a new layer on top of it with
something else. We can thus &quot;delete&quot; data by adding a layer of &quot;nothing&quot;
on top of it.</p>
<p>This means that when we talk about data lifecycle, we are really talking
about adding layers to our data over time.</p>
<p class="rubric" id="the-bare-necessities">The Bare Necessities</p>
<p>The data lifecycle consists of three basic operations:</p>
<ul class="simple">
<li>adding an entity with the <code class="docutils literal"><span class="pre">add-entity</span></code> function</li>
<li>removing an entity with the <code class="docutils literal"><span class="pre">remove-entity</span></code> function</li>
<li>updating an entity with the <code class="docutils literal"><span class="pre">update-entity</span></code> function</li>
</ul>
<p>Remember that, even though these functions provide the illusion of
mutability, all that we are really doing in each case is adding another
layer to the data. Also, since we are using Clojure's persistent data
structures, from the caller's perspective we pay the same price for
these operations as for an &quot;in-place&quot; change (i.e., negligible
performance overhead), while maintaining immutability for all other
users of the data structure.</p>
<p class="rubric" id="adding-an-entity">Adding an Entity</p>
<p>Adding an entity requires us to do three things:</p>
<ul class="simple">
<li>prepare the entity for addition (by giving it an ID and a timestamp)</li>
<li>place the entity in storage</li>
<li>update indexes as necessary</li>
</ul>
<p>These steps are performed in the <code class="docutils literal"><span class="pre">add-entity</span></code> function.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">add</span><span class="o">-</span><span class="n">entity</span> <span class="p">[</span><span class="n">db</span> <span class="n">ent</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[[</span><span class="n">fixed</span><span class="o">-</span><span class="n">ent</span> <span class="nb">next</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="nb">id</span><span class="p">]</span> <span class="p">(</span><span class="n">fix</span><span class="o">-</span><span class="n">new</span><span class="o">-</span><span class="n">entity</span> <span class="n">db</span> <span class="n">ent</span><span class="p">)</span>
         <span class="n">layer</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">updated</span><span class="o">-</span><span class="n">storage</span> <span class="p">(</span><span class="n">update</span><span class="o">-</span><span class="ow">in</span>
                            <span class="p">(</span><span class="n">last</span> <span class="p">(:</span><span class="n">layers</span> <span class="n">db</span><span class="p">))</span> <span class="p">[:</span><span class="n">storage</span><span class="p">]</span> <span class="n">write</span><span class="o">-</span><span class="n">entity</span> <span class="n">fixed</span><span class="o">-</span><span class="n">ent</span><span class="p">)</span>
         <span class="n">add</span><span class="o">-</span><span class="n">fn</span> <span class="p">(</span><span class="n">partial</span> <span class="n">add</span><span class="o">-</span><span class="n">entity</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">index</span> <span class="n">fixed</span><span class="o">-</span><span class="n">ent</span><span class="p">)</span>
         <span class="n">new</span><span class="o">-</span><span class="n">layer</span> <span class="p">(</span><span class="n">reduce</span> <span class="n">add</span><span class="o">-</span><span class="n">fn</span> <span class="n">layer</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">updated</span><span class="o">-</span><span class="n">storage</span> <span class="p">(</span><span class="n">indexes</span><span class="p">))]</span>
    <span class="p">(</span><span class="n">assoc</span> <span class="n">db</span> <span class="p">:</span><span class="n">layers</span> <span class="p">(</span><span class="n">conj</span> <span class="p">(:</span><span class="n">layers</span> <span class="n">db</span><span class="p">)</span> <span class="n">new</span><span class="o">-</span><span class="n">layer</span><span class="p">)</span> <span class="p">:</span><span class="n">top</span><span class="o">-</span><span class="nb">id</span> <span class="nb">next</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="nb">id</span><span class="p">)))</span>
</pre></div>
</div>
<p>Preparing an entity is done by calling the <code class="docutils literal"><span class="pre">fix-new-entity</span></code> function
and its auxiliary functions <code class="docutils literal"><span class="pre">next-id</span></code>, <code class="docutils literal"><span class="pre">next-ts</span></code> and
<code class="docutils literal"><span class="pre">update-creation-ts</span></code>. These latter two helper functions are
responsible for finding the next timestamp of the database (done by
<code class="docutils literal"><span class="pre">next-ts</span></code>), and updating the creation timestamp of the given entity
(done by <code class="docutils literal"><span class="pre">update-creation-ts</span></code>). Updating the creation timestamp of an
entity means going over the attributes of the entity and updating their
<code class="docutils literal"><span class="pre">:ts</span></code> fields.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span><span class="o">-</span> <span class="nb">next</span><span class="o">-</span><span class="n">ts</span> <span class="p">[</span><span class="n">db</span><span class="p">]</span> <span class="p">(</span><span class="n">inc</span> <span class="p">(:</span><span class="n">curr</span><span class="o">-</span><span class="n">time</span> <span class="n">db</span><span class="p">)))</span>

<span class="p">(</span><span class="n">defn</span><span class="o">-</span> <span class="n">update</span><span class="o">-</span><span class="n">creation</span><span class="o">-</span><span class="n">ts</span> <span class="p">[</span><span class="n">ent</span> <span class="n">ts</span><span class="o">-</span><span class="n">val</span><span class="p">]</span>
   <span class="p">(</span><span class="n">reduce</span> <span class="c1">#(assoc-in %1 [:attrs %2 :ts ] ts-val) ent (keys (:attrs ent))))</span>

<span class="p">(</span><span class="n">defn</span><span class="o">-</span> <span class="nb">next</span><span class="o">-</span><span class="nb">id</span> <span class="p">[</span><span class="n">db</span> <span class="n">ent</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">top</span><span class="o">-</span><span class="nb">id</span> <span class="p">(:</span><span class="n">top</span><span class="o">-</span><span class="nb">id</span> <span class="n">db</span><span class="p">)</span>
         <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="p">(:</span><span class="nb">id</span> <span class="n">ent</span><span class="p">)</span>
         <span class="n">increased</span><span class="o">-</span><span class="nb">id</span> <span class="p">(</span><span class="n">inc</span> <span class="n">top</span><span class="o">-</span><span class="nb">id</span><span class="p">)]</span>
         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="o">=</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="p">:</span><span class="n">db</span><span class="o">/</span><span class="n">no</span><span class="o">-</span><span class="nb">id</span><span class="o">-</span><span class="n">yet</span><span class="p">)</span>
             <span class="p">[(</span><span class="n">keyword</span> <span class="p">(</span><span class="nb">str</span> <span class="n">increased</span><span class="o">-</span><span class="nb">id</span><span class="p">))</span> <span class="n">increased</span><span class="o">-</span><span class="nb">id</span><span class="p">]</span>
             <span class="p">[</span><span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">top</span><span class="o">-</span><span class="nb">id</span><span class="p">])))</span>

<span class="p">(</span><span class="n">defn</span><span class="o">-</span> <span class="n">fix</span><span class="o">-</span><span class="n">new</span><span class="o">-</span><span class="n">entity</span> <span class="p">[</span><span class="n">db</span> <span class="n">ent</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[[</span><span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="nb">next</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="nb">id</span><span class="p">]</span> <span class="p">(</span><span class="nb">next</span><span class="o">-</span><span class="nb">id</span> <span class="n">db</span> <span class="n">ent</span><span class="p">)</span>
         <span class="n">new</span><span class="o">-</span><span class="n">ts</span>               <span class="p">(</span><span class="nb">next</span><span class="o">-</span><span class="n">ts</span> <span class="n">db</span><span class="p">)]</span>
       <span class="p">[(</span><span class="n">update</span><span class="o">-</span><span class="n">creation</span><span class="o">-</span><span class="n">ts</span> <span class="p">(</span><span class="n">assoc</span> <span class="n">ent</span> <span class="p">:</span><span class="nb">id</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span><span class="p">)</span> <span class="n">new</span><span class="o">-</span><span class="n">ts</span><span class="p">)</span> <span class="nb">next</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="nb">id</span><span class="p">]))</span>
</pre></div>
</div>
<p>To add the entity to storage, we locate the most recent layer in the
database and update the storage in that layer with a new layer, the
results of which are stored in <code class="docutils literal"><span class="pre">layer-with-updated-storage</span></code>.</p>
<p>Finally, we must update the indexes. This means, for each of the indexes
(done by the combination of <code class="docutils literal"><span class="pre">reduce</span></code> and the <code class="docutils literal"><span class="pre">partial</span></code>-ed
<code class="docutils literal"><span class="pre">add-entity-to-index</span></code> at the <code class="docutils literal"><span class="pre">add-entity</span></code> function):</p>
<ul class="simple">
<li>Find the attributes that should be indexed (see the combination of
<code class="docutils literal"><span class="pre">filter</span></code> with the index’s <code class="docutils literal"><span class="pre">usage-pred</span></code> that operates on the
attributes in <code class="docutils literal"><span class="pre">add-entity-to-index</span></code>)</li>
<li>Build an index-path from the the entity’s ID (see the combination of
the <code class="docutils literal"><span class="pre">partial</span></code>-ed <code class="docutils literal"><span class="pre">update-entry-in-index</span></code> with <code class="docutils literal"><span class="pre">from-eav</span></code> at the
<code class="docutils literal"><span class="pre">update-attr-in-index</span></code> function)</li>
<li>Add that path to the index (see the <code class="docutils literal"><span class="pre">update-entry-in-index</span></code>
function)</li>
</ul>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span><span class="o">-</span> <span class="n">add</span><span class="o">-</span><span class="n">entity</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">index</span> <span class="p">[</span><span class="n">ent</span> <span class="n">layer</span> <span class="n">ind</span><span class="o">-</span><span class="n">name</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="p">(:</span><span class="nb">id</span> <span class="n">ent</span><span class="p">)</span>
         <span class="n">index</span> <span class="p">(</span><span class="n">ind</span><span class="o">-</span><span class="n">name</span> <span class="n">layer</span><span class="p">)</span>
         <span class="nb">all</span><span class="o">-</span><span class="n">attrs</span>  <span class="p">(</span><span class="n">vals</span> <span class="p">(:</span><span class="n">attrs</span> <span class="n">ent</span><span class="p">))</span>
         <span class="n">relevant</span><span class="o">-</span><span class="n">attrs</span> <span class="p">(</span><span class="nb">filter</span> <span class="c1">#((usage-pred index) %) all-attrs)</span>
         <span class="n">add</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">index</span><span class="o">-</span><span class="n">fn</span> <span class="p">(</span><span class="n">fn</span> <span class="p">[</span><span class="n">ind</span> <span class="n">attr</span><span class="p">]</span>
                                 <span class="p">(</span><span class="n">update</span><span class="o">-</span><span class="n">attr</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">index</span> <span class="n">ind</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="p">(:</span><span class="n">name</span> <span class="n">attr</span><span class="p">)</span>
                                                                  <span class="p">(:</span><span class="n">value</span> <span class="n">attr</span><span class="p">)</span>
                                                                  <span class="p">:</span><span class="n">db</span><span class="o">/</span><span class="n">add</span><span class="p">))]</span>
        <span class="p">(</span><span class="n">assoc</span> <span class="n">layer</span> <span class="n">ind</span><span class="o">-</span><span class="n">name</span>  <span class="p">(</span><span class="n">reduce</span> <span class="n">add</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">index</span><span class="o">-</span><span class="n">fn</span> <span class="n">index</span> <span class="n">relevant</span><span class="o">-</span><span class="n">attrs</span><span class="p">))))</span>

<span class="p">(</span><span class="n">defn</span><span class="o">-</span> <span class="n">update</span><span class="o">-</span><span class="n">attr</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">index</span> <span class="p">[</span><span class="n">index</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span> <span class="n">target</span><span class="o">-</span><span class="n">val</span> <span class="n">operation</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">colled</span><span class="o">-</span><span class="n">target</span><span class="o">-</span><span class="n">val</span> <span class="p">(</span><span class="n">collify</span> <span class="n">target</span><span class="o">-</span><span class="n">val</span><span class="p">)</span>
         <span class="n">update</span><span class="o">-</span><span class="n">entry</span><span class="o">-</span><span class="n">fn</span> <span class="p">(</span><span class="n">fn</span> <span class="p">[</span><span class="n">ind</span> <span class="n">vl</span><span class="p">]</span>
                             <span class="p">(</span><span class="n">update</span><span class="o">-</span><span class="n">entry</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">index</span>
                                <span class="n">ind</span>
                                <span class="p">((</span><span class="n">from</span><span class="o">-</span><span class="n">eav</span> <span class="n">index</span><span class="p">)</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span> <span class="n">vl</span><span class="p">)</span>
                                <span class="n">operation</span><span class="p">))]</span>
     <span class="p">(</span><span class="n">reduce</span> <span class="n">update</span><span class="o">-</span><span class="n">entry</span><span class="o">-</span><span class="n">fn</span> <span class="n">index</span> <span class="n">colled</span><span class="o">-</span><span class="n">target</span><span class="o">-</span><span class="n">val</span><span class="p">)))</span>

<span class="p">(</span><span class="n">defn</span><span class="o">-</span> <span class="n">update</span><span class="o">-</span><span class="n">entry</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">index</span> <span class="p">[</span><span class="n">index</span> <span class="n">path</span> <span class="n">operation</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">update</span><span class="o">-</span><span class="n">path</span> <span class="p">(</span><span class="n">butlast</span> <span class="n">path</span><span class="p">)</span>
         <span class="n">update</span><span class="o">-</span><span class="n">value</span> <span class="p">(</span><span class="n">last</span> <span class="n">path</span><span class="p">)</span>
         <span class="n">to</span><span class="o">-</span><span class="n">be</span><span class="o">-</span><span class="n">updated</span><span class="o">-</span><span class="nb">set</span> <span class="p">(</span><span class="n">get</span><span class="o">-</span><span class="ow">in</span> <span class="n">index</span> <span class="n">update</span><span class="o">-</span><span class="n">path</span> <span class="c1">#{})]</span>
     <span class="p">(</span><span class="n">assoc</span><span class="o">-</span><span class="ow">in</span> <span class="n">index</span> <span class="n">update</span><span class="o">-</span><span class="n">path</span> <span class="p">(</span><span class="n">conj</span> <span class="n">to</span><span class="o">-</span><span class="n">be</span><span class="o">-</span><span class="n">updated</span><span class="o">-</span><span class="nb">set</span> <span class="n">update</span><span class="o">-</span><span class="n">value</span><span class="p">))))</span>
</pre></div>
</div>
<p>All of these components are added as a new layer to the given database.
All that’s left is to update the database’s timestamp and <code class="docutils literal"><span class="pre">top-id</span></code>
fields. That last step occurs on the last line of <code class="docutils literal"><span class="pre">add-entity</span></code>, which
also returns the updated database.</p>
<p>We also provide an <code class="docutils literal"><span class="pre">add-entities</span></code> convenience function that adds
multiple entities to the database in one call by iteratively applying
<code class="docutils literal"><span class="pre">add-entity</span></code>.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">add</span><span class="o">-</span><span class="n">entities</span> <span class="p">[</span><span class="n">db</span> <span class="n">ents</span><span class="o">-</span><span class="n">seq</span><span class="p">]</span> <span class="p">(</span><span class="n">reduce</span> <span class="n">add</span><span class="o">-</span><span class="n">entity</span> <span class="n">db</span> <span class="n">ents</span><span class="o">-</span><span class="n">seq</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric" id="removing-an-entity">Removing an Entity</p>
<p>Removing an entity from our database means adding a layer in which it
does not exist. To do this, we need to:</p>
<ul class="simple">
<li>Remove the entity itself</li>
<li>Update any attributes of other entities that reference it</li>
<li>Clear the entity from our indexes</li>
</ul>
<p>This &quot;construct-without&quot; process is executed by the <code class="docutils literal"><span class="pre">remove-entity</span></code>
function, which looks very similar to <code class="docutils literal"><span class="pre">add-entity</span></code>:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">remove</span><span class="o">-</span><span class="n">entity</span> <span class="p">[</span><span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">ent</span> <span class="p">(</span><span class="n">entity</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span><span class="p">)</span>
         <span class="n">layer</span> <span class="p">(</span><span class="n">remove</span><span class="o">-</span><span class="n">back</span><span class="o">-</span><span class="n">refs</span> <span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="p">(</span><span class="n">last</span> <span class="p">(:</span><span class="n">layers</span> <span class="n">db</span><span class="p">)))</span>
         <span class="n">no</span><span class="o">-</span><span class="n">ref</span><span class="o">-</span><span class="n">layer</span> <span class="p">(</span><span class="n">update</span><span class="o">-</span><span class="ow">in</span> <span class="n">layer</span> <span class="p">[:</span><span class="n">VAET</span><span class="p">]</span> <span class="n">dissoc</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span><span class="p">)</span>
         <span class="n">no</span><span class="o">-</span><span class="n">ent</span><span class="o">-</span><span class="n">layer</span> <span class="p">(</span><span class="n">assoc</span> <span class="n">no</span><span class="o">-</span><span class="n">ref</span><span class="o">-</span><span class="n">layer</span> <span class="p">:</span><span class="n">storage</span>
                                   <span class="p">(</span><span class="n">drop</span><span class="o">-</span><span class="n">entity</span>
                                          <span class="p">(:</span><span class="n">storage</span> <span class="n">no</span><span class="o">-</span><span class="n">ref</span><span class="o">-</span><span class="n">layer</span><span class="p">)</span> <span class="n">ent</span><span class="p">))</span>
         <span class="n">new</span><span class="o">-</span><span class="n">layer</span> <span class="p">(</span><span class="n">reduce</span> <span class="p">(</span><span class="n">partial</span> <span class="n">remove</span><span class="o">-</span><span class="n">entity</span><span class="o">-</span><span class="n">from</span><span class="o">-</span><span class="n">index</span> <span class="n">ent</span><span class="p">)</span>
                                 <span class="n">no</span><span class="o">-</span><span class="n">ent</span><span class="o">-</span><span class="n">layer</span> <span class="p">(</span><span class="n">indexes</span><span class="p">))]</span>
     <span class="p">(</span><span class="n">assoc</span> <span class="n">db</span> <span class="p">:</span><span class="n">layers</span> <span class="p">(</span><span class="n">conj</span>  <span class="p">(:</span><span class="n">layers</span> <span class="n">db</span><span class="p">)</span> <span class="n">new</span><span class="o">-</span><span class="n">layer</span><span class="p">))))</span>
</pre></div>
</div>
<p>Reference removal is done by the <code class="docutils literal"><span class="pre">remove-back-refs</span></code> function:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span><span class="o">-</span> <span class="n">remove</span><span class="o">-</span><span class="n">back</span><span class="o">-</span><span class="n">refs</span> <span class="p">[</span><span class="n">db</span> <span class="n">e</span><span class="o">-</span><span class="nb">id</span> <span class="n">layer</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">reffing</span><span class="o">-</span><span class="n">datoms</span> <span class="p">(</span><span class="n">reffing</span><span class="o">-</span><span class="n">to</span> <span class="n">e</span><span class="o">-</span><span class="nb">id</span> <span class="n">layer</span><span class="p">)</span>
         <span class="n">remove</span><span class="o">-</span><span class="n">fn</span> <span class="p">(</span><span class="n">fn</span><span class="p">[</span><span class="n">d</span> <span class="p">[</span><span class="n">e</span> <span class="n">a</span><span class="p">]]</span> <span class="p">(</span><span class="n">update</span><span class="o">-</span><span class="n">entity</span> <span class="n">db</span> <span class="n">e</span> <span class="n">a</span> <span class="n">e</span><span class="o">-</span><span class="nb">id</span> <span class="p">:</span><span class="n">db</span><span class="o">/</span><span class="n">remove</span><span class="p">))</span>
         <span class="n">clean</span><span class="o">-</span><span class="n">db</span> <span class="p">(</span><span class="n">reduce</span> <span class="n">remove</span><span class="o">-</span><span class="n">fn</span> <span class="n">db</span> <span class="n">reffing</span><span class="o">-</span><span class="n">datoms</span><span class="p">)]</span>
     <span class="p">(</span><span class="n">last</span> <span class="p">(:</span><span class="n">layers</span> <span class="n">clean</span><span class="o">-</span><span class="n">db</span><span class="p">))))</span>
</pre></div>
</div>
<p>We begin by using <code class="docutils literal"><span class="pre">reffing-datoms-to</span></code> to find all entities that
reference ours in the given layer; it returns a sequence of triplets
that contain the ID of the referencing entity, as well as the attribute
name and the ID of the removed entity.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span><span class="o">-</span> <span class="n">reffing</span><span class="o">-</span><span class="n">to</span> <span class="p">[</span><span class="n">e</span><span class="o">-</span><span class="nb">id</span> <span class="n">layer</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">vaet</span> <span class="p">(:</span><span class="n">VAET</span> <span class="n">layer</span><span class="p">)]</span>
         <span class="p">(</span><span class="k">for</span> <span class="p">[[</span><span class="n">attr</span><span class="o">-</span><span class="n">name</span> <span class="n">reffing</span><span class="o">-</span><span class="nb">set</span><span class="p">]</span> <span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="nb">id</span> <span class="n">vaet</span><span class="p">)</span>
               <span class="n">reffing</span> <span class="n">reffing</span><span class="o">-</span><span class="nb">set</span><span class="p">]</span>
              <span class="p">[</span><span class="n">reffing</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span><span class="p">])))</span>
</pre></div>
</div>
<p>We then apply <code class="docutils literal"><span class="pre">update-entity</span></code> to each triplet to update the attributes
that reference our removed entity. (We'll explore how <code class="docutils literal"><span class="pre">update-entity</span></code>
works in the next section.)</p>
<p>The last step of <code class="docutils literal"><span class="pre">remove-back-refs</span></code> is to clear the reference itself
from our indexes, and more specifically from the VAET index, since it is
the only index that stores reference information.</p>
<p class="rubric" id="updating-an-entity">Updating an Entity</p>
<p>At its essence, an update is the modification of an entity’s attribute’s
value. The modification process itself depends on the cardinality of the
attribute: an attribute with cardinality <code class="docutils literal"><span class="pre">:db/multiple</span></code> holds a set of
values, so we must allow items to be added to or removed from this set,
or the set to be replaced entirely. An attribute with cardinality
<code class="docutils literal"><span class="pre">:db/single</span></code> holds a single value, and thus only allows replacement.</p>
<p>Since we also have indexes that provide lookups directly on attributes
and their values, these will also have to be updated.</p>
<p>As with <code class="docutils literal"><span class="pre">add-entity</span></code> and <code class="docutils literal"><span class="pre">remove-entity</span></code>, we won't actually be
modifying our entity in place, but will instead add a new layer which
contains the updated entity.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">update</span><span class="o">-</span><span class="n">entity</span>
   <span class="p">([</span><span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span> <span class="n">new</span><span class="o">-</span><span class="n">val</span><span class="p">]</span>
    <span class="p">(</span><span class="n">update</span><span class="o">-</span><span class="n">entity</span> <span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span> <span class="n">new</span><span class="o">-</span><span class="n">val</span> <span class="p">:</span><span class="n">db</span><span class="o">/</span><span class="n">reset</span><span class="o">-</span><span class="n">to</span><span class="p">))</span>
   <span class="p">([</span><span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span> <span class="n">new</span><span class="o">-</span><span class="n">val</span> <span class="n">operation</span><span class="p">]</span>
      <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">update</span><span class="o">-</span><span class="n">ts</span> <span class="p">(</span><span class="nb">next</span><span class="o">-</span><span class="n">ts</span> <span class="n">db</span><span class="p">)</span>
            <span class="n">layer</span> <span class="p">(</span><span class="n">last</span> <span class="p">(:</span><span class="n">layers</span> <span class="n">db</span><span class="p">))</span>
            <span class="n">attr</span> <span class="p">(</span><span class="n">attr</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="n">attr</span><span class="o">-</span><span class="n">name</span><span class="p">)</span>
            <span class="n">updated</span><span class="o">-</span><span class="n">attr</span> <span class="p">(</span><span class="n">update</span><span class="o">-</span><span class="n">attr</span> <span class="n">attr</span> <span class="n">new</span><span class="o">-</span><span class="n">val</span> <span class="n">update</span><span class="o">-</span><span class="n">ts</span> <span class="n">operation</span><span class="p">)</span>
            <span class="n">fully</span><span class="o">-</span><span class="n">updated</span><span class="o">-</span><span class="n">layer</span> <span class="p">(</span><span class="n">update</span><span class="o">-</span><span class="n">layer</span> <span class="n">layer</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span>
                                              <span class="n">attr</span> <span class="n">updated</span><span class="o">-</span><span class="n">attr</span>
                                              <span class="n">new</span><span class="o">-</span><span class="n">val</span> <span class="n">operation</span><span class="p">)]</span>
        <span class="p">(</span><span class="n">update</span><span class="o">-</span><span class="ow">in</span> <span class="n">db</span> <span class="p">[:</span><span class="n">layers</span><span class="p">]</span> <span class="n">conj</span> <span class="n">fully</span><span class="o">-</span><span class="n">updated</span><span class="o">-</span><span class="n">layer</span><span class="p">))))</span>
</pre></div>
</div>
<p>To update an attribute, we locate it with <code class="docutils literal"><span class="pre">attr-at</span></code> and then use
<code class="docutils literal"><span class="pre">update-attr</span></code> to perform the actual update.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(defn- update-attr [attr new-val new-ts operation]
    {:pre  [(if (single? attr)
            (contains? #{:db/reset-to :db/remove} operation)
            (contains? #{:db/reset-to :db/add :db/remove} operation))]}
    (-&gt; attr
       (update-attr-modification-time new-ts)
       (update-attr-value new-val operation)))
</pre></div>
</div>
<p>We use two helper functions to perform the update.
<code class="docutils literal"><span class="pre">update-attr-modification-time</span></code> updates timestamps to reflect the
creation of the black arrows in Figure 1:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span><span class="o">-</span> <span class="n">update</span><span class="o">-</span><span class="n">attr</span><span class="o">-</span><span class="n">modification</span><span class="o">-</span><span class="n">time</span>
  <span class="p">[</span><span class="n">attr</span> <span class="n">new</span><span class="o">-</span><span class="n">ts</span><span class="p">]</span>
       <span class="p">(</span><span class="n">assoc</span> <span class="n">attr</span> <span class="p">:</span><span class="n">ts</span> <span class="n">new</span><span class="o">-</span><span class="n">ts</span> <span class="p">:</span><span class="n">prev</span><span class="o">-</span><span class="n">ts</span> <span class="p">(:</span><span class="n">ts</span> <span class="n">attr</span><span class="p">)))</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">update-attr-value</span></code> actually updates the value:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(defn- update-attr-value [attr value operation]
   (cond
      (single? attr)    (assoc attr :value #{value})
      ; now we&#39;re talking about an attribute of multiple values
      (= :db/reset-to operation)
        (assoc attr :value value)
      (= :db/add operation)
        (assoc attr :value (CS/union (:value attr) value))
      (= :db/remove operation)
        (assoc attr :value (CS/difference (:value attr) value))))
</pre></div>
</div>
<p>All that remains is to remove the old value from the indexes and add the
new one to them, and then construct the new layer with all of our
updated components. Luckily, we can leverage the code we wrote for
adding and removing entities to do this.</p>
<p class="rubric" id="transactions">Transactions</p>
<p>Each of the operations in our low-level API acts on a single entity.
However, nearly all databases have a way for users to do multiple
operations as a single <em>transaction</em>. This means:</p>
<ul class="simple">
<li>The batch of operations is viewed as a single atomic operation, so
all of the operations either succeed together or fail together.</li>
<li>The database is in a valid state before and after the transaction.</li>
<li>The batch update appears to be <em>isolated</em>; other queries should never
see a database state in which only some of the operations have been
applied.</li>
</ul>
<p>We can fulfill these requirements through an interface that consumes a
database and a set of operations to be performed, and produces a
database whose state reflects the given changes. All of the changes
submitted in the batch should be applied through the addition of a
<em>single</em> layer. However, we have a problem: All of the functions we
wrote in our low-level API add a new layer to the database. If we were
to perform a batch with <em>n</em> operations, we would thus see <em>n</em> new layers
added, when what we would really like is to have exactly one new layer.</p>
<p>The key here is that the layer we want is the <em>top</em> layer that would be
produced by performing those updates in sequence. Therefore, the
solution is to execute the user’s operations one after another, each
creating a new layer. When the last layer is created, we take only that
top layer and place it on the initial database (leaving all the
intermediate layers to pine for the fjords). Only after we've done all
this will we update the database's timestamp.</p>
<p>All this is done in the <code class="docutils literal"><span class="pre">transact-on-db</span></code> function, which receives the
initial value of the database and the batch of operations to perform,
and returns its updated value.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">transact</span><span class="o">-</span><span class="n">on</span><span class="o">-</span><span class="n">db</span> <span class="p">[</span><span class="n">initial</span><span class="o">-</span><span class="n">db</span> <span class="n">ops</span><span class="p">]</span>
    <span class="p">(</span><span class="n">loop</span> <span class="p">[[</span><span class="n">op</span> <span class="o">&amp;</span> <span class="n">rst</span><span class="o">-</span><span class="n">ops</span><span class="p">]</span> <span class="n">ops</span> <span class="n">transacted</span> <span class="n">initial</span><span class="o">-</span><span class="n">db</span><span class="p">]</span>
      <span class="p">(</span><span class="k">if</span> <span class="n">op</span>
          <span class="p">(</span><span class="n">recur</span> <span class="n">rst</span><span class="o">-</span><span class="n">ops</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="n">first</span> <span class="n">op</span><span class="p">)</span> <span class="n">transacted</span> <span class="p">(</span><span class="n">rest</span> <span class="n">op</span><span class="p">)))</span>
          <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">initial</span><span class="o">-</span><span class="n">layer</span>  <span class="p">(:</span><span class="n">layers</span> <span class="n">initial</span><span class="o">-</span><span class="n">db</span><span class="p">)</span>
                <span class="n">new</span><span class="o">-</span><span class="n">layer</span> <span class="p">(</span><span class="n">last</span> <span class="p">(:</span><span class="n">layers</span> <span class="n">transacted</span><span class="p">))]</span>
            <span class="p">(</span><span class="n">assoc</span> <span class="n">initial</span><span class="o">-</span><span class="n">db</span> <span class="p">:</span><span class="n">layers</span> <span class="p">(</span><span class="n">conj</span> <span class="n">initial</span><span class="o">-</span><span class="n">layer</span> <span class="n">new</span><span class="o">-</span><span class="n">layer</span><span class="p">)</span>
                              <span class="p">:</span><span class="n">curr</span><span class="o">-</span><span class="n">time</span> <span class="p">(</span><span class="nb">next</span><span class="o">-</span><span class="n">ts</span> <span class="n">initial</span><span class="o">-</span><span class="n">db</span><span class="p">)</span>
                              <span class="p">:</span><span class="n">top</span><span class="o">-</span><span class="nb">id</span> <span class="p">(:</span><span class="n">top</span><span class="o">-</span><span class="nb">id</span> <span class="n">transacted</span><span class="p">))))))</span>
</pre></div>
</div>
<p>Note here that we used the term <em>value</em>, meaning that only the caller to
this function is exposed to the updated state; all other users of the
database are unaware of this change (as a database is a value, and
therefore cannot change). In order to have a system where users can be
exposed to state changes performed by others, users do not interact
directly with the database, but rather refer to it using another level
of indirection. This additional level is implemented using Clojure's
<code class="docutils literal"><span class="pre">Atom</span></code>, a reference type. Here we leverage the main three key features
of an <code class="docutils literal"><span class="pre">Atom</span></code>, which are:</p>
<ol class="arabic simple">
<li>It references a value.</li>
<li>It is possible to update the referencing of the <code class="docutils literal"><span class="pre">Atom</span></code> to another
value by executing a transaction (using Clojure's Software
Transaction Memory capabilities). The transaction accepts an <code class="docutils literal"><span class="pre">Atom</span></code>
and a function. That function operates on the value of the <code class="docutils literal"><span class="pre">Atom</span></code>
and returns a new value. After the execution of the transaction, the
<code class="docutils literal"><span class="pre">Atom</span></code> references the value that was returned from the function.</li>
<li>Getting to the value that is referenced by the <code class="docutils literal"><span class="pre">Atom</span></code> is done by
dereferencing it, which returns the state of that <code class="docutils literal"><span class="pre">Atom</span></code> at that
time.</li>
</ol>
<p>In between Clojure's <code class="docutils literal"><span class="pre">Atom</span></code> and the work done in <code class="docutils literal"><span class="pre">transact-on-db</span></code>,
there's still a gap to be bridged; namely, to invoke the transaction
with the right inputs.</p>
<p>To have the simplest and clearest APIs, we would like users to just
provide the <code class="docutils literal"><span class="pre">Atom</span></code> and the list of operations, and have the database
transform the user input into a proper transaction.</p>
<p>That transformation occurs in the following transaction call chain:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>transact →  _transact → swap! → transact-on-db
</pre></div>
</div>
<p>Users call <code class="docutils literal"><span class="pre">transact</span></code> with the <code class="docutils literal"><span class="pre">Atom</span></code> (i.e., the connection) and the
operations to perform, which relays its input to <code class="docutils literal"><span class="pre">_transact</span></code>, adding
to it the name of the function that updates the <code class="docutils literal"><span class="pre">Atom</span></code> (<code class="docutils literal"><span class="pre">swap!</span></code>).</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(defmacro transact [db-conn &amp; txs]  `(_transact ~db-conn swap! ~@txs))
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">_transact</span></code> prepares the call to <code class="docutils literal"><span class="pre">swap!</span></code>. It does so by creating a
list that begins with <code class="docutils literal"><span class="pre">swap!</span></code>, followed by the <code class="docutils literal"><span class="pre">Atom</span></code>, then the
<code class="docutils literal"><span class="pre">transact-on-db</span></code> symbol and the batch of operations.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defmacro</span>  <span class="n">_transact</span> <span class="p">[</span><span class="n">db</span> <span class="n">op</span> <span class="o">&amp;</span> <span class="n">txs</span><span class="p">]</span>
   <span class="p">(</span><span class="n">when</span> <span class="n">txs</span>
     <span class="p">(</span><span class="n">loop</span> <span class="p">[[</span><span class="n">frst</span><span class="o">-</span><span class="n">tx</span><span class="c1"># &amp; rst-tx#] txs  res#  [op db `transact-on-db]  accum-txs# []]</span>
       <span class="p">(</span><span class="k">if</span> <span class="n">frst</span><span class="o">-</span><span class="n">tx</span><span class="c1">#</span>
           <span class="p">(</span><span class="n">recur</span> <span class="n">rst</span><span class="o">-</span><span class="n">tx</span><span class="c1"># res#  (conj  accum-txs#  (vec frst-tx#)))</span>
           <span class="p">(</span><span class="nb">list</span><span class="o">*</span> <span class="p">(</span><span class="n">conj</span> <span class="n">res</span><span class="c1">#  accum-txs#))))))</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">swap!</span></code> invokes <code class="docutils literal"><span class="pre">transact-on-db</span></code> within a transaction (with the
previously prepared arguments), and <code class="docutils literal"><span class="pre">transact-on-db</span></code> creates the new
state of the database and returns it.</p>
<p>At this point we can see that with few minor tweaks, we can also provide
a way to ask &quot;what if&quot; questions. This can be done by replacing
<code class="docutils literal"><span class="pre">swap!</span></code> with a function that would not make any change to the system.
This scenario is implemented with the <code class="docutils literal"><span class="pre">what-if</span></code> call chain:</p>
<p><code class="docutils literal"><span class="pre">what-if</span></code> \(\to\) <code class="docutils literal"><span class="pre">_transact</span></code> \(\to\) <code class="docutils literal"><span class="pre">_what-if</span></code> \(\to\)
<code class="docutils literal"><span class="pre">transact-on-db</span></code></p>
<p>The user calls <code class="docutils literal"><span class="pre">what-if</span></code> with the database value and the operations to
perform. It then relays these inputs to <code class="docutils literal"><span class="pre">_transact</span></code>, adding to them a
function that mimics <code class="docutils literal"><span class="pre">swap!</span></code>'s APIs, without its effect (callled
<code class="docutils literal"><span class="pre">_what-if</span></code>).</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(defmacro what-if [db &amp; ops]  `(_transact ~db _what-if  ~@ops))
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">_transact</span></code> prepares the call to <code class="docutils literal"><span class="pre">_what-if</span></code>. It does so by creating
a list that begins with <code class="docutils literal"><span class="pre">_what-if</span></code>, followed by the database, then the
<code class="docutils literal"><span class="pre">transact-on-db</span></code> symbol and the batch of operations. <code class="docutils literal"><span class="pre">_what-if</span></code>
invokes <code class="docutils literal"><span class="pre">transact-on-db</span></code>, just like <code class="docutils literal"><span class="pre">swap!</span></code> does in the transaction
scenario, but does not inflict any change on the system.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span><span class="o">-</span> <span class="n">_what</span><span class="o">-</span><span class="k">if</span> <span class="p">[</span><span class="n">db</span> <span class="n">f</span> <span class="n">txs</span><span class="p">]</span>  <span class="p">(</span><span class="n">f</span> <span class="n">db</span> <span class="n">txs</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that we are not using functions, but macros. The reason for using
macros here is that arguments to macros do not get evaluated as the call
happens; this allows us to offer a cleaner API design where the user
provides the operations structured in the same way that any function
call is structured in Clojure.</p>
<p>The above process can be seen in the following examples. For
Transaction, the user call:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">transact</span> <span class="n">db</span><span class="o">-</span><span class="n">conn</span>  <span class="p">(</span><span class="n">add</span><span class="o">-</span><span class="n">entity</span> <span class="n">e1</span><span class="p">)</span> <span class="p">(</span><span class="n">update</span><span class="o">-</span><span class="n">entity</span> <span class="n">e2</span> <span class="n">atr2</span> <span class="n">val2</span> <span class="p">:</span><span class="n">db</span><span class="o">/</span><span class="n">add</span><span class="p">))</span>
</pre></div>
</div>
<p>changes into:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(_transact db-conn swap! (add-entity e1) (update-entity e2 atr2 val2 :db/add))
</pre></div>
</div>
<p>which becomes:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(swap! db-conn transact-on-db [[add-entity e1][update-entity e2 atr2 val2 :db/add]])
</pre></div>
</div>
<p>For what-if, the user call:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">what</span><span class="o">-</span><span class="k">if</span> <span class="n">my</span><span class="o">-</span><span class="n">db</span> <span class="p">(</span><span class="n">add</span><span class="o">-</span><span class="n">entity</span> <span class="n">e3</span><span class="p">)</span> <span class="p">(</span><span class="n">remove</span><span class="o">-</span><span class="n">entity</span> <span class="n">e4</span><span class="p">))</span>
</pre></div>
</div>
<p>changes into:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">_transact</span> <span class="n">my</span><span class="o">-</span><span class="n">db</span> <span class="n">_what</span><span class="o">-</span><span class="k">if</span> <span class="p">(</span><span class="n">add</span><span class="o">-</span><span class="n">entity</span> <span class="n">e3</span><span class="p">)</span> <span class="p">(</span><span class="n">remove</span><span class="o">-</span><span class="n">entity</span> <span class="n">e4</span><span class="p">))</span>
</pre></div>
</div>
<p>then:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">_what</span><span class="o">-</span><span class="k">if</span> <span class="n">my</span><span class="o">-</span><span class="n">db</span> <span class="n">transact</span><span class="o">-</span><span class="n">on</span><span class="o">-</span><span class="n">db</span> <span class="p">[[</span><span class="n">add</span><span class="o">-</span><span class="n">entity</span> <span class="n">e3</span><span class="p">]</span> <span class="p">[</span><span class="n">remove</span><span class="o">-</span><span class="n">entity</span> <span class="n">e4</span><span class="p">]])</span>
</pre></div>
</div>
<p>and eventually:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">transact</span><span class="o">-</span><span class="n">on</span><span class="o">-</span><span class="n">db</span> <span class="n">my</span><span class="o">-</span><span class="n">db</span>  <span class="p">[[</span><span class="n">add</span><span class="o">-</span><span class="n">entity</span> <span class="n">e3</span><span class="p">]</span> <span class="p">[</span><span class="n">remove</span><span class="o">-</span><span class="n">entity</span> <span class="n">e4</span><span class="p">]])</span>
</pre></div>
</div>
<p class="rubric" id="insight-extraction-as-libraries">Insight Extraction as Libraries</p>
<p>At this point we have the core functionality of the database in place,
and it is time to add its <em>raison d'être</em>: insights extraction. The
architecture approach we used here is to allow adding these capabilities
as libraries, as different usages of the database would need different
such mechanisms.</p>
<p class="rubric" id="graph-traversal">Graph Traversal</p>
<div class="line-block">
<div class="line">A reference connection between entities is created when an entity’s
attribute’s type is <code class="docutils literal"><span class="pre">:db/ref</span></code>, which means that the value of that
attribute is an ID of another entity. When a referring entity is added
to the database, the reference is indexed at the VAET index.</div>
<div class="line">The information found in the VAET index can be leveraged to extract
all the incoming links to an entity. This is done in the
<code class="docutils literal"><span class="pre">incoming-refs</span></code> function, which collects all the leaves that are
reachable from the entity at that index:</div>
</div>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">incoming</span><span class="o">-</span><span class="n">refs</span> <span class="p">[</span><span class="n">db</span> <span class="n">ts</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span> <span class="o">&amp;</span> <span class="n">ref</span><span class="o">-</span><span class="n">names</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">vaet</span> <span class="p">(</span><span class="n">indx</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="p">:</span><span class="n">VAET</span> <span class="n">ts</span><span class="p">)</span>
         <span class="nb">all</span><span class="o">-</span><span class="n">attr</span><span class="o">-</span><span class="nb">map</span> <span class="p">(</span><span class="n">vaet</span> <span class="n">ent</span><span class="o">-</span><span class="nb">id</span><span class="p">)</span>
         <span class="n">filtered</span><span class="o">-</span><span class="nb">map</span> <span class="p">(</span><span class="k">if</span> <span class="n">ref</span><span class="o">-</span><span class="n">names</span>
                          <span class="p">(</span><span class="n">select</span><span class="o">-</span><span class="n">keys</span> <span class="n">ref</span><span class="o">-</span><span class="n">names</span> <span class="nb">all</span><span class="o">-</span><span class="n">attr</span><span class="o">-</span><span class="nb">map</span><span class="p">)</span>
                          <span class="nb">all</span><span class="o">-</span><span class="n">attr</span><span class="o">-</span><span class="nb">map</span><span class="p">)]</span>
      <span class="p">(</span><span class="n">reduce</span> <span class="n">into</span> <span class="c1">#{} (vals filtered-map))))</span>
</pre></div>
</div>
<p>We can also go through all of a given entity’s attributes and collect
all the values of attributes of type <code class="docutils literal"><span class="pre">:db/ref</span></code>, and by that extract
all the outgoing references from that entity. This is done by the
<code class="docutils literal"><span class="pre">outgoing-refs</span></code> function.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(defn outgoing-refs [db ts ent-id &amp; ref-names]
   (let [val-filter-fn (if ref-names #(vals (select-keys ref-names %)) vals)]
   (if-not ent-id []
     (-&gt;&gt; (entity-at db ts ent-id)
          (:attrs) (val-filter-fn) (filter ref?) (mapcat :value)))))
</pre></div>
</div>
<p>These two functions act as the basic building blocks for any graph
traversal operation, as they are the ones that raise the level of
abstraction from entities and attributes to nodes and links in a graph.
Once we have the ability to look at our database as a graph, we can
provide various graph traversing and querying APIs. We leave this as a
solved exercise to the reader; one solution can be found in the
chapter's source code (see <code class="docutils literal"><span class="pre">graph.clj</span></code>).</p>
<p class="rubric" id="querying-the-database">Querying the Database</p>
<p>The second library we present provides querying capabilities, which is
the main concern of this section. A database is not very useful to its
users without a powerful query mechanism. This feature is usually
exposed to users through a <em>query language</em> that is used to
declaratively specify the set of data of interest.</p>
<p>Our data model is based on accumulation of facts (i.e., datoms) over
time. For this model, a natural place to look for the right query
language is <em>logic programming</em>. A commonly used query language
influenced by logic programming is <em>Datalog</em> which, in addition to being
well-suited for our data model, has a very elegant adaptation to
Clojure’s syntax. Our query engine will implement a subset of the
Datalog language from the <a class="reference external" href="http://docs.datomic.com/query.html">Datomic database</a>.</p>
<p class="rubric" id="query-language">Query Language</p>
<p>Let's look at an example query in our proposed language. This query
asks: &quot;What are the names and birthdays of entities who like pizza,
speak English, and who have a birthday this month?&quot;</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>{  :find [?nm ?bd ]
   :where [
      [?e  :likes &quot;pizza&quot;]
      [?e  :name  ?nm]
      [?e  :speak &quot;English&quot;]
      [?e  :bday (bday-mo? ?bd)]]}
</pre></div>
</div>
<p class="rubric" id="syntax">Syntax</p>
<p>We use the syntax of Clojure’s data literals directly to provide the
basic syntax for our queries. This allows us to avoid having to write a
specialized parser, while still providing a form that is familiar and
easily readable to programmers familiar with Clojure.</p>
<p>A query is a map with two items:</p>
<ul class="simple">
<li>An item with <code class="docutils literal"><span class="pre">:where</span></code> as a key, and with a <em>rule</em> as a value. A
rule is a vector of <em>clauses</em>, and a clause is a vector composed of
three <em>predicates</em>, each of which operates on a different component
of a datom. In the example above, <code class="docutils literal"><span class="pre">[?e</span>&#160; <span class="pre">:likes</span> <span class="pre">&quot;pizza&quot;]</span></code> is a
clause. This <code class="docutils literal"><span class="pre">:where</span></code> item defines a rule that acts as a filter on
datoms in our database (like a SQL <code class="docutils literal"><span class="pre">WHERE</span></code> clause.)</li>
<li>An item with <code class="docutils literal"><span class="pre">:find</span></code> as a key, and with a vector as a value. The
vector defines which components of the selected datom should be
projected into the results (like a SQL <code class="docutils literal"><span class="pre">SELECT</span></code> clause.)</li>
</ul>
<p>The description above omits a crucial requirement: how to make different
clauses sync on a value (i.e., make a join operation between them), and
how to structure the found values in the output (specified by the
<code class="docutils literal"><span class="pre">:find</span></code> part).</p>
<p>We fulfill both of these requirements using <em>variables</em>, which are
denoted with a leading <code class="docutils literal"><span class="pre">?</span></code>. The only exception to this definition is
the &quot;don't care&quot; variable <code class="docutils literal"><span class="pre">_</span></code> (underscore).</p>
<p>A clause in a query is composed of three predicates; Table 10.2 defines
what can act as a predicate in our query language.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="68%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Name</td>
<td>Meaning</td>
<td>Example</td>
</tr>
<tr class="row-even"><td>Constant</td>
<td>Is the value of the item in the datom equal to the constant?</td>
<td>:likes</td>
</tr>
<tr class="row-odd"><td>Variable</td>
<td>Bind the value of the item in the datom to the variable and return true.</td>
<td>?e</td>
</tr>
<tr class="row-even"><td>Don’t-care</td>
<td>Always returns true.</td>
<td>_</td>
</tr>
<tr class="row-odd"><td>Unary operator</td>
<td>Unary operation that takes a variable as its operand.
Bind the datom's item's value to the variable (unless it's an '_').
Replace the variable with the value of the item in the datom.
Return the application of the operation.</td>
<td>(bday-mo? _)</td>
</tr>
<tr class="row-even"><td>Binary operator</td>
<td>A binary operation that must have a variable as one of its operands.
Bind the datom's item's value to the variable (unless it's an '_').
Replace the variable with the value of the item in the datom.
Return the result of the operation.</td>
<td>(&gt; ?age 20)</td>
</tr>
</tbody>
</table>
<p>: <strong>Table 10.2</strong> - Predicates</p>
<p class="rubric" id="limitations-of-our-query-language">Limitations of our Query Language</p>
<p>Engineering is all about managing tradeoffs, and designing our query
engine is no different. In our case, the main tradeoff we must address
is feature-richness versus complexity. Resolving this tradeoff requires
us to look at common use-cases of the system, and from there deciding
what limitations would be acceptable.</p>
<p>In our database, we decided to build a query engine with the following
limitations:</p>
<ul class="simple">
<li>Users cannot define logical operations between the clauses; they are
always ‘ANDed’ together. (This can be worked around by using unary or
binary predicates.)</li>
<li>If there is more than one clause in a query, there must be one
variable that is found in all of the clauses of that query. This
variable acts as a joining variable. This limitation simplifies the
query optimizer.</li>
<li>A query is only executed on a single database.</li>
</ul>
<p>While these design decisions result in a query language that is less
rich than Datalog, we are still able to support many types of simple but
useful queries.</p>
<p class="rubric" id="query-engine-design">Query Engine Design</p>
<p>While our query language allows the user to specify <em>what</em> they want to
access, it hides the details of <em>how</em> this will be accomplished. The
query engine is the database component responsible for yielding the data
for a given query.</p>
<p>This involves four steps:</p>
<ol class="arabic simple">
<li>Transformation to internal representation: Transform the query from
its textual form into a data structure that is consumed by the query
planner.</li>
<li>Building a query plan: Determine an efficient <em>plan</em> for yielding the
results of the given query. In our case, a query plan is a function
to be invoked.</li>
<li>Executing the plan: Execute the plan and send its results to the next
phase.</li>
<li>Unification and reporting: Extract only the results that need to be
reported and format them as specified.</li>
</ol>
<p class="rubric" id="phase-1-transformation">Phase 1: Transformation</p>
<p>In this phase, we transform the given query from a representation that
is easy for the user to understand into a representation that can be
consumed efficiently by the query planner.</p>
<p>The <code class="docutils literal"><span class="pre">:find</span></code> part of the query is transformed into a set of the given
variable names:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defmacro</span> <span class="n">symbol</span><span class="o">-</span><span class="n">col</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="nb">set</span> <span class="p">[</span><span class="n">coll</span><span class="p">]</span> <span class="p">(</span><span class="nb">set</span> <span class="p">(</span><span class="nb">map</span> <span class="nb">str</span> <span class="n">coll</span><span class="p">)))</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">:where</span></code> part of the query retains its nested vector structure.
However, each of the terms in each of the clauses is replaced with a
predicate according to Table 10.2.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(defmacro clause-term-expr [clause-term]
   (cond
    (variable? (str clause-term)) ;variable
      #(= % %)
    (not (coll? clause-term)) ;constant
      `#(= % ~clause-term)
    (= 2 (count clause-term)) ;unary operator
      `#(~(first clause-term) %)
    (variable? (str (second clause-term)));binary operator, 1st operand is variable
      `#(~(first clause-term) % ~(last clause-term))
    (variable? (str (last clause-term)));binary operator, 2nd operand is variable
      `#(~(first clause-term) ~(second clause-term) %)))
</pre></div>
</div>
<p>For each clause, a vector with the variable names used in that clause is
set as its metadata.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(defmacro clause-term-meta [clause-term]
   (cond
   (coll? clause-term)  (first (filter #(variable? % false) (map str clause-term)))
   (variable? (str clause-term) false) (str clause-term)
   :no-variable-in-clause nil))
</pre></div>
</div>
<p>We use <code class="docutils literal"><span class="pre">pred-clause</span></code> to iterate over the terms in each clause:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defmacro</span> <span class="n">pred</span><span class="o">-</span><span class="n">clause</span> <span class="p">[</span><span class="n">clause</span><span class="p">]</span>
   <span class="p">(</span><span class="n">loop</span> <span class="p">[[</span><span class="n">trm</span><span class="c1"># &amp; rst-trm#] clause exprs# [] metas# []]</span>
     <span class="p">(</span><span class="k">if</span>  <span class="n">trm</span><span class="c1">#</span>
          <span class="p">(</span><span class="n">recur</span> <span class="n">rst</span><span class="o">-</span><span class="n">trm</span><span class="c1"># (conj exprs# `(clause-term-expr ~ trm#))</span>
                       <span class="p">(</span><span class="n">conj</span> <span class="n">metas</span><span class="c1">#`(clause-term-meta ~ trm#)))</span>
          <span class="p">(</span><span class="k">with</span><span class="o">-</span><span class="n">meta</span> <span class="n">exprs</span><span class="c1"># {:db/variable metas#}))))</span>
</pre></div>
</div>
<p>Iterating over the clauses themselves happens in
<code class="docutils literal"><span class="pre">q-clauses-to-pred-clauses</span></code>:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defmacro</span>  <span class="n">q</span><span class="o">-</span><span class="n">clauses</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">pred</span><span class="o">-</span><span class="n">clauses</span> <span class="p">[</span><span class="n">clauses</span><span class="p">]</span>
     <span class="p">(</span><span class="n">loop</span> <span class="p">[[</span><span class="n">frst</span><span class="c1"># &amp; rst#] clauses preds-vecs# []]</span>
       <span class="p">(</span><span class="k">if</span><span class="o">-</span><span class="ow">not</span> <span class="n">frst</span><span class="c1">#  preds-vecs#</span>
         <span class="p">(</span><span class="n">recur</span> <span class="n">rst</span><span class="c1"># `(conj ~preds-vecs# (pred-clause ~frst#))))))</span>
</pre></div>
</div>
<p>We are once again relying on the fact that macros do not eagerly
evaluate their arguments. This allows us to define a simpler API where
users provide variable names as symbols (e.g., <code class="docutils literal"><span class="pre">?name</span></code>) instead of
asking the user to understand the internals of the engine by providing
variable names as strings ( e.g., <code class="docutils literal"><span class="pre">&quot;?name&quot;</span></code>), or even worse, quoting
the variable name (e.g., <code class="docutils literal"><span class="pre">'?name</span></code>).</p>
<p>At the end of this phase, our example yields the following set for the
<code class="docutils literal"><span class="pre">:find</span></code> part:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="c1">#{&quot;?nm&quot; &quot;?bd&quot;}</span>
</pre></div>
</div>
<p>and the following structure in Table 10.3 for the <code class="docutils literal"><span class="pre">:where</span></code> part. (Each
cell in the <em>Predicate Clause</em> column holds the metadata found in its
neighbor at the <em>Meta Clause</em> column.)</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="47%" />
<col width="21%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Query Clause</td>
<td>Predicate Clause</td>
<td>Meta Clause</td>
</tr>
<tr class="row-even"><td>[?e&nbsp;&nbsp;:likes &quot;pizza&quot;]</td>
<td>[#(= % %) #(= % :likes) #(= % &quot;pizza&quot;)]</td>
<td>[&quot;?e&quot; nil nil]</td>
</tr>
<tr class="row-odd"><td>[?e&nbsp;&nbsp;:name&nbsp;&nbsp;?nm]</td>
<td>[#(= % %) #(= % :name) #(= % %)]</td>
<td>[&quot;?e&quot; nil &quot;?nm&quot;]</td>
</tr>
<tr class="row-even"><td>[?e&nbsp;&nbsp;:speak &quot;English&quot;]</td>
<td>[#(= % %) #(= % :speak) #(= % &quot;English&quot;)]</td>
<td>[&quot;?e&quot; nil nil]</td>
</tr>
<tr class="row-odd"><td>[?e&nbsp;&nbsp;:bday (bday-mo? ?bd)]</td>
<td>[#(= % %) #(= % :bday) #(bday-mo? %)]</td>
<td>[&quot;?e&quot; nil &quot;?bd&quot;]</td>
</tr>
</tbody>
</table>
<p>: <strong>Table 10.3</strong> - Clauses</p>
<p>This structure acts as the query that is executed in a later phase, once
the engine decides on the right plan of execution.</p>
<p class="rubric" id="phase-2-making-a-plan">Phase 2: Making a Plan</p>
<p>In this phase, we inspect the query in order to construct a good plan to
produce the result it describes.</p>
<p>In general, this will involve choosing the appropriate index (Table
10.4) and constructing a plan in the form of a function. We choose the
index based on the <em>single</em> joining variable (that can operate on only a
single kind of element).</p>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Joining variable operates on</td>
<td>Index to use</td>
</tr>
<tr class="row-even"><td>Entity IDs</td>
<td>AVET</td>
</tr>
<tr class="row-odd"><td>Attribute names</td>
<td>VEAT</td>
</tr>
<tr class="row-even"><td>Attribute values</td>
<td>EAVT</td>
</tr>
</tbody>
</table>
<p>: <strong>Table 10.4</strong> - Index Selection</p>
<p>The reasoning behind this mapping will become clearer in the next
section, when we actually execute the plan produced. For now, just note
that the key here is to select an index whose leaves hold the elements
that the joining variable operates on.</p>
<p>Locating the index of the joining variable is done by
<code class="docutils literal"><span class="pre">index-of-joining-variable</span></code>:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">index</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">joining</span><span class="o">-</span><span class="n">variable</span> <span class="p">[</span><span class="n">query</span><span class="o">-</span><span class="n">clauses</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">metas</span><span class="o">-</span><span class="n">seq</span>  <span class="p">(</span><span class="nb">map</span> <span class="c1">#(:db/variable (meta %)) query-clauses)</span>
         <span class="n">collapsing</span><span class="o">-</span><span class="n">fn</span> <span class="p">(</span><span class="n">fn</span> <span class="p">[</span><span class="n">accV</span> <span class="n">v</span><span class="p">]</span> <span class="p">(</span><span class="nb">map</span> <span class="c1">#(when (= %1 %2) %1)  accV v))</span>
         <span class="n">collapsed</span> <span class="p">(</span><span class="n">reduce</span> <span class="n">collapsing</span><span class="o">-</span><span class="n">fn</span> <span class="n">metas</span><span class="o">-</span><span class="n">seq</span><span class="p">)]</span>
     <span class="p">(</span><span class="n">first</span> <span class="p">(</span><span class="n">keep</span><span class="o">-</span><span class="n">indexed</span> <span class="c1">#(when (variable? %2 false) %1)  collapsed))))</span>
</pre></div>
</div>
<p>We begin by extracting the metadata of each clause in the query. This
extracted metadata is a 3-element vector; each element is either a
variable name or nil. (Note that there is no more than one variable name
in that vector.) Once the vector is extracted, we produce from it (by
reducing it) a single value, which is either a variable name or nil. If
a variable name is produced, then it appeared in all of the metadata
vectors at the same index; i.e., this is the joining variable. We can
thus choose to use the index relevant for this joining variable based on
the mapping described above.</p>
<p>Once the index is chosen, we construct our plan, which is a function
that closes over the query and the index name and executes the
operations necessary to return the query results.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">build</span><span class="o">-</span><span class="n">query</span><span class="o">-</span><span class="n">plan</span> <span class="p">[</span><span class="n">query</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">term</span><span class="o">-</span><span class="n">ind</span> <span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">joining</span><span class="o">-</span><span class="n">variable</span> <span class="n">query</span><span class="p">)</span>
         <span class="n">ind</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">use</span> <span class="p">(</span><span class="n">case</span> <span class="n">term</span><span class="o">-</span><span class="n">ind</span> <span class="mi">0</span> <span class="p">:</span><span class="n">AVET</span> <span class="mi">1</span> <span class="p">:</span><span class="n">VEAT</span> <span class="mi">2</span> <span class="p">:</span><span class="n">EAVT</span><span class="p">)]</span>
      <span class="p">(</span><span class="n">partial</span> <span class="n">single</span><span class="o">-</span><span class="n">index</span><span class="o">-</span><span class="n">query</span><span class="o">-</span><span class="n">plan</span> <span class="n">query</span> <span class="n">ind</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">use</span><span class="p">)))</span>
</pre></div>
</div>
<p>In our example the chosen index is the <code class="docutils literal"><span class="pre">AVET</span></code> index, as the joining
variable acts on the entity IDs.</p>
<p class="rubric" id="phase-3-execution-of-the-plan">Phase 3: Execution of the Plan</p>
<p>We saw in the previous phase that our query plan ends by calling
<code class="docutils literal"><span class="pre">single-index-query-plan</span></code>. This function will:</p>
<ol class="arabic simple">
<li>Apply each predicate clause on an index (each predicate on its
appropriate index level).</li>
<li>Perform an AND operation across the results.</li>
<li>Merge the results into a simpler data structure.</li>
</ol>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">single</span><span class="o">-</span><span class="n">index</span><span class="o">-</span><span class="n">query</span><span class="o">-</span><span class="n">plan</span> <span class="p">[</span><span class="n">query</span> <span class="n">indx</span> <span class="n">db</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">q</span><span class="o">-</span><span class="n">res</span> <span class="p">(</span><span class="n">query</span><span class="o">-</span><span class="n">index</span> <span class="p">(</span><span class="n">indx</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="n">indx</span><span class="p">)</span> <span class="n">query</span><span class="p">)]</span>
     <span class="p">(</span><span class="n">bind</span><span class="o">-</span><span class="n">variables</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">query</span> <span class="n">q</span><span class="o">-</span><span class="n">res</span> <span class="p">(</span><span class="n">indx</span><span class="o">-</span><span class="n">at</span> <span class="n">db</span> <span class="n">indx</span><span class="p">))))</span>
</pre></div>
</div>
<p>To better explain this process we'll demonstrate it using our exemplary
query, assuming that our database holds the entities in Table 10.5.</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="35%" />
<col width="49%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Entity ID</td>
<td>Attribute Name</td>
<td>Attribute Value</td>
</tr>
<tr class="row-even"><td>1</td>
<td>:name :likes :speak :bday</td>
<td>USA Pizza English July 4, 1776</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>:name :likes :speak :bday</td>
<td>France Red wine French July 14, 1789</td>
</tr>
<tr class="row-even"><td>3</td>
<td>:name :likes :speak :bday</td>
<td>Canada Snow English July 1, 1867</td>
</tr>
</tbody>
</table>
<p>: <strong>Table 10.5</strong> - Example entities</p>
<p>Now it is time to go deeper into the rabbit hole and take a look at the
<code class="docutils literal"><span class="pre">query-index</span></code> function, where our query finally begins to yield some
results:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">query</span><span class="o">-</span><span class="n">index</span> <span class="p">[</span><span class="n">index</span> <span class="n">pred</span><span class="o">-</span><span class="n">clauses</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">result</span><span class="o">-</span><span class="n">clauses</span> <span class="p">(</span><span class="nb">filter</span><span class="o">-</span><span class="n">index</span> <span class="n">index</span> <span class="n">pred</span><span class="o">-</span><span class="n">clauses</span><span class="p">)</span>
         <span class="n">relevant</span><span class="o">-</span><span class="n">items</span> <span class="p">(</span><span class="n">items</span><span class="o">-</span><span class="n">that</span><span class="o">-</span><span class="n">answer</span><span class="o">-</span><span class="nb">all</span><span class="o">-</span><span class="n">conditions</span> <span class="p">(</span><span class="nb">map</span> <span class="n">last</span> <span class="n">result</span><span class="o">-</span><span class="n">clauses</span><span class="p">)</span>
                                                          <span class="p">(</span><span class="n">count</span> <span class="n">pred</span><span class="o">-</span><span class="n">clauses</span><span class="p">))</span>
         <span class="n">cleaned</span><span class="o">-</span><span class="n">result</span><span class="o">-</span><span class="n">clauses</span> <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="n">partial</span> <span class="n">mask</span><span class="o">-</span><span class="n">path</span><span class="o">-</span><span class="n">leaf</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">items</span>
                                              <span class="n">relevant</span><span class="o">-</span><span class="n">items</span><span class="p">)</span>
                                     <span class="n">result</span><span class="o">-</span><span class="n">clauses</span><span class="p">)]</span>
     <span class="p">(</span><span class="nb">filter</span> <span class="c1">#(not-empty (last %)) cleaned-result-clauses)))</span>
</pre></div>
</div>
<p>This function starts by applying the predicate clauses on the previously
chosen index. Each application of a predicate clause on an index returns
a <em>result clause</em>.</p>
<p>The main characteristics of a result are:</p>
<ol class="arabic simple">
<li>It is built of three items, each from a different level of the index,
and each passed its respective predicate.</li>
<li>The order of items matches the index's levels structure. (Predicate
clauses are always in EAV order.) The re-ordering is done when
applying the index's <code class="docutils literal"><span class="pre">from-eav</span></code> on the predicate clause.</li>
<li>The metadata of the predicate clause is attached to it.</li>
</ol>
<p>All of this is done in the function <code class="docutils literal"><span class="pre">filter-index</span></code>.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="nb">filter</span><span class="o">-</span><span class="n">index</span> <span class="p">[</span><span class="n">index</span> <span class="n">predicate</span><span class="o">-</span><span class="n">clauses</span><span class="p">]</span>
   <span class="p">(</span><span class="k">for</span> <span class="p">[</span><span class="n">pred</span><span class="o">-</span><span class="n">clause</span> <span class="n">predicate</span><span class="o">-</span><span class="n">clauses</span>
         <span class="p">:</span><span class="n">let</span> <span class="p">[[</span><span class="n">lvl1</span><span class="o">-</span><span class="n">prd</span> <span class="n">lvl2</span><span class="o">-</span><span class="n">prd</span> <span class="n">lvl3</span><span class="o">-</span><span class="n">prd</span><span class="p">]</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="n">from</span><span class="o">-</span><span class="n">eav</span> <span class="n">index</span><span class="p">)</span> <span class="n">pred</span><span class="o">-</span><span class="n">clause</span><span class="p">)]</span>
         <span class="p">[</span><span class="n">k1</span> <span class="n">l2map</span><span class="p">]</span> <span class="n">index</span>  <span class="p">;</span> <span class="n">keys</span> <span class="ow">and</span> <span class="n">values</span> <span class="n">of</span> <span class="n">the</span> <span class="n">first</span> <span class="n">level</span>
         <span class="p">:</span><span class="n">when</span> <span class="p">(</span><span class="k">try</span> <span class="p">(</span><span class="n">lvl1</span><span class="o">-</span><span class="n">prd</span> <span class="n">k1</span><span class="p">)</span> <span class="p">(</span><span class="n">catch</span> <span class="ne">Exception</span> <span class="n">e</span> <span class="n">false</span><span class="p">))</span>

         <span class="p">[</span><span class="n">k2</span>  <span class="n">l3</span><span class="o">-</span><span class="nb">set</span><span class="p">]</span> <span class="n">l2map</span>  <span class="p">;</span> <span class="n">keys</span> <span class="ow">and</span> <span class="n">values</span> <span class="n">of</span> <span class="n">the</span> <span class="n">second</span> <span class="n">level</span>
         <span class="p">:</span><span class="n">when</span> <span class="p">(</span><span class="k">try</span> <span class="p">(</span><span class="n">lvl2</span><span class="o">-</span><span class="n">prd</span> <span class="n">k2</span><span class="p">)</span> <span class="p">(</span><span class="n">catch</span> <span class="ne">Exception</span> <span class="n">e</span> <span class="n">false</span><span class="p">))</span>
         <span class="p">:</span><span class="n">let</span> <span class="p">[</span><span class="n">res</span> <span class="p">(</span><span class="nb">set</span> <span class="p">(</span><span class="nb">filter</span> <span class="n">lvl3</span><span class="o">-</span><span class="n">prd</span> <span class="n">l3</span><span class="o">-</span><span class="nb">set</span><span class="p">))]</span> <span class="p">]</span>
     <span class="p">(</span><span class="k">with</span><span class="o">-</span><span class="n">meta</span> <span class="p">[</span><span class="n">k1</span> <span class="n">k2</span> <span class="n">res</span><span class="p">]</span> <span class="p">(</span><span class="n">meta</span> <span class="n">pred</span><span class="o">-</span><span class="n">clause</span><span class="p">))))</span>
</pre></div>
</div>
<p>Assuming the query was executed on July 4th, the results of executing it
on the above data are seen in Table 10.6.</p>
<table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="38%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Result Clause</td>
<td>Result Meta</td>
</tr>
<tr class="row-even"><td>[:likes Pizza #{1}]</td>
<td>[&quot;?e&quot; nil nil]</td>
</tr>
<tr class="row-odd"><td>[:name USA #{1}]</td>
<td>[&quot;?e&quot; nil &quot;?nm&quot;]</td>
</tr>
<tr class="row-even"><td>[:speak &quot;English&quot; #{1, 3}]</td>
<td>[&quot;?e&quot; nil nil]</td>
</tr>
<tr class="row-odd"><td>[:bday &quot;July 4, 1776&quot; #{1}]</td>
<td>[&quot;?e&quot; nil &quot;?bd&quot;]</td>
</tr>
<tr class="row-even"><td>[:name France #{2}]</td>
<td>[&quot;?e&quot; nil &quot;?nm&quot;]</td>
</tr>
<tr class="row-odd"><td>[:bday &quot;July 14, 1789&quot; #{2}]</td>
<td>[&quot;?e&quot; nil &quot;?bd&quot;]</td>
</tr>
<tr class="row-even"><td>[:name Canada #{3}]</td>
<td>[&quot;?e&quot; nil &quot;?nm&quot;]</td>
</tr>
<tr class="row-odd"><td>[:bday &quot;July 1, 1867&quot; {3}]</td>
<td>[&quot;?e&quot; nil &quot;?bd&quot;]</td>
</tr>
</tbody>
</table>
<p>: <strong>Table 10.6</strong> - Query results</p>
<p>Once we have produced all of the result clauses, we need to perform an
<code class="docutils literal"><span class="pre">AND</span></code> operation between them. This is done by finding all of the
elements that passed all the predicate clauses:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">items</span><span class="o">-</span><span class="n">that</span><span class="o">-</span><span class="n">answer</span><span class="o">-</span><span class="nb">all</span><span class="o">-</span><span class="n">conditions</span> <span class="p">[</span><span class="n">items</span><span class="o">-</span><span class="n">seq</span> <span class="n">num</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">conditions</span><span class="p">]</span>
   <span class="p">(</span><span class="o">-&gt;&gt;</span> <span class="n">items</span><span class="o">-</span><span class="n">seq</span> <span class="p">;</span> <span class="n">take</span> <span class="n">the</span> <span class="n">items</span><span class="o">-</span><span class="n">seq</span>
         <span class="p">(</span><span class="nb">map</span> <span class="n">vec</span><span class="p">)</span> <span class="p">;</span> <span class="n">make</span> <span class="n">each</span> <span class="n">collection</span> <span class="p">(</span><span class="n">actually</span> <span class="n">a</span> <span class="nb">set</span><span class="p">)</span> <span class="n">into</span> <span class="n">a</span> <span class="n">vector</span>
         <span class="p">(</span><span class="n">reduce</span> <span class="n">into</span> <span class="p">[])</span> <span class="p">;</span><span class="n">reduce</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">vectors</span> <span class="n">into</span> <span class="n">one</span> <span class="n">vector</span>
         <span class="p">(</span><span class="n">frequencies</span><span class="p">)</span> <span class="p">;</span><span class="n">count</span> <span class="k">for</span> <span class="n">each</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">how</span> <span class="n">many</span> <span class="n">collections</span> <span class="p">(</span><span class="n">sets</span><span class="p">)</span> <span class="n">it</span> <span class="n">was</span> <span class="ow">in</span>
         <span class="p">(</span><span class="nb">filter</span> <span class="c1">#(&lt;= num-of-conditions (last %))) ;items that answered all conditions</span>
         <span class="p">(</span><span class="nb">map</span> <span class="n">first</span><span class="p">)</span> <span class="p">;</span> <span class="n">take</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">duos</span> <span class="n">the</span> <span class="n">items</span> <span class="n">themselves</span>
         <span class="p">(</span><span class="nb">set</span><span class="p">)))</span> <span class="p">;</span> <span class="k">return</span> <span class="n">it</span> <span class="k">as</span> <span class="nb">set</span>
</pre></div>
</div>
<p>In our example, the result of this step is a set that holds the value
<em>1</em> (which is the entity ID of USA).</p>
<p>We now have to remove the items that didn’t pass all of the conditions:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">mask</span><span class="o">-</span><span class="n">path</span><span class="o">-</span><span class="n">leaf</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">items</span> <span class="p">[</span><span class="n">relevant</span><span class="o">-</span><span class="n">items</span> <span class="n">path</span><span class="p">]</span>
     <span class="p">(</span><span class="n">update</span><span class="o">-</span><span class="ow">in</span> <span class="n">path</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">CS</span><span class="o">/</span><span class="n">intersection</span> <span class="n">relevant</span><span class="o">-</span><span class="n">items</span><span class="p">))</span>
</pre></div>
</div>
<p>Finally, we remove all of the result clauses that are &quot;empty&quot; (i.e.,
their last item is empty). We do this in the last line of the
<code class="docutils literal"><span class="pre">query-index</span></code> function. Our example leaves us with the items in Table
10.7.</p>
<table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="39%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Result Clause</td>
<td>Result Meta</td>
</tr>
<tr class="row-even"><td>[:likes Pizza #{1}]</td>
<td>[&quot;?e&quot; nil nil]</td>
</tr>
<tr class="row-odd"><td>[:name USA #{1}]</td>
<td>[&quot;?e&quot; nil &quot;?nm&quot;]</td>
</tr>
<tr class="row-even"><td>[:bday &quot;July 4, 1776&quot; #{1}]</td>
<td>[&quot;?e&quot; nil &quot;?bd&quot;]</td>
</tr>
<tr class="row-odd"><td>[:speak &quot;English&quot; #{1}]</td>
<td>[&quot;?e&quot; nil nil]</td>
</tr>
</tbody>
</table>
<p>: <strong>Table 10.7</strong> - Filtered query results</p>
<p>We are now ready to report the results. The result clause structure is
unwieldy for this purpose, so we will convert it into an an index-like
structure (map of maps)—with a significant twist.</p>
<p>To understand the twist, we must first introduce the idea of a <em>binding
pair</em>, which is a pair that matches a variable name to its value. The
variable name is the one used at the predicate clauses, and the value is
the value found in the result clauses.</p>
<p>The twist to the index structure is that now we hold a binding pair of
the entity-id / attr-name / value in the location where we held an
entity-id / attr-name / value in an index:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">bind</span><span class="o">-</span><span class="n">variables</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">query</span> <span class="p">[</span><span class="n">q</span><span class="o">-</span><span class="n">res</span> <span class="n">index</span><span class="p">]</span>
   <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">seq</span><span class="o">-</span><span class="n">res</span><span class="o">-</span><span class="n">path</span> <span class="p">(</span><span class="n">mapcat</span> <span class="p">(</span><span class="n">partial</span> <span class="n">combine</span><span class="o">-</span><span class="n">path</span><span class="o">-</span><span class="ow">and</span><span class="o">-</span><span class="n">meta</span> <span class="p">(</span><span class="n">from</span><span class="o">-</span><span class="n">eav</span> <span class="n">index</span><span class="p">))</span>
                               <span class="n">q</span><span class="o">-</span><span class="n">res</span><span class="p">)</span>

         <span class="n">res</span><span class="o">-</span><span class="n">path</span> <span class="p">(</span><span class="nb">map</span> <span class="c1">#(-&gt;&gt; %1 (partition 2)(apply (to-eav index))) seq-res-path)]</span>
     <span class="p">(</span><span class="n">reduce</span> <span class="c1">#(assoc-in %1  (butlast %2) (last %2)) {} res-path)))</span>
<span class="p">(</span><span class="n">defn</span> <span class="n">combine</span><span class="o">-</span><span class="n">path</span><span class="o">-</span><span class="ow">and</span><span class="o">-</span><span class="n">meta</span> <span class="p">[</span><span class="n">from</span><span class="o">-</span><span class="n">eav</span><span class="o">-</span><span class="n">fn</span> <span class="n">path</span><span class="p">]</span>
    <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">expanded</span><span class="o">-</span><span class="n">path</span> <span class="p">[(</span><span class="n">repeat</span> <span class="p">(</span><span class="n">first</span> <span class="n">path</span><span class="p">))</span> <span class="p">(</span><span class="n">repeat</span> <span class="p">(</span><span class="n">second</span> <span class="n">path</span><span class="p">))</span> <span class="p">(</span><span class="n">last</span> <span class="n">path</span><span class="p">)]</span>
          <span class="n">meta</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">path</span> <span class="p">(</span><span class="n">apply</span> <span class="n">from</span><span class="o">-</span><span class="n">eav</span><span class="o">-</span><span class="n">fn</span> <span class="p">(</span><span class="nb">map</span> <span class="n">repeat</span> <span class="p">(:</span><span class="n">db</span><span class="o">/</span><span class="n">variable</span> <span class="p">(</span><span class="n">meta</span> <span class="n">path</span><span class="p">))))</span>
          <span class="n">combined</span><span class="o">-</span><span class="n">data</span><span class="o">-</span><span class="ow">and</span><span class="o">-</span><span class="n">meta</span><span class="o">-</span><span class="n">path</span> <span class="p">(</span><span class="n">interleave</span> <span class="n">meta</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">path</span> <span class="n">expanded</span><span class="o">-</span><span class="n">path</span><span class="p">)]</span>
       <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="n">partial</span> <span class="nb">map</span> <span class="n">vector</span><span class="p">)</span> <span class="n">combined</span><span class="o">-</span><span class="n">data</span><span class="o">-</span><span class="ow">and</span><span class="o">-</span><span class="n">meta</span><span class="o">-</span><span class="n">path</span><span class="p">)))</span>
</pre></div>
</div>
<p>At the end of phase 3 of our example execution, we have the following
structure at hand:</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">{[</span><span class="mi">1</span> <span class="s2">&quot;?e&quot;</span><span class="p">]{</span>
    <span class="p">{[:</span><span class="n">likes</span> <span class="n">nil</span><span class="p">]</span>    <span class="p">[</span><span class="s2">&quot;Pizza&quot;</span> <span class="n">nil</span><span class="p">]}</span>
    <span class="p">{[:</span><span class="n">name</span> <span class="n">nil</span><span class="p">]</span>     <span class="p">[</span><span class="s2">&quot;USA&quot;</span> <span class="s2">&quot;?nm&quot;</span><span class="p">]}</span>
    <span class="p">{[:</span><span class="n">speaks</span> <span class="n">nil</span><span class="p">]</span>   <span class="p">[</span><span class="s2">&quot;English&quot;</span> <span class="n">nil</span><span class="p">]}</span>
    <span class="p">{[:</span><span class="n">bday</span> <span class="n">nil</span><span class="p">]</span> <span class="p">[</span><span class="s2">&quot;July 4, 1776&quot;</span> <span class="s2">&quot;?bd&quot;</span><span class="p">]}</span>
<span class="p">}}</span>
</pre></div>
</div>
<p class="rubric" id="phase-4-unify-and-report">Phase 4: Unify and Report</p>
<p>At this point, we’ve produced a superset of the results that the user
initially asked for. In this phase, we'll extract the values that the
user wants. This process is called <em>unification</em>: it is here that we
will unify the binding pairs structure with the vector of variable names
that the user defined in the <code class="docutils literal"><span class="pre">:find</span></code> clause of the query.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">defn</span> <span class="n">unify</span> <span class="p">[</span><span class="n">binded</span><span class="o">-</span><span class="n">res</span><span class="o">-</span><span class="n">col</span> <span class="n">needed</span><span class="o">-</span><span class="nb">vars</span><span class="p">]</span>
   <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="n">partial</span> <span class="n">locate</span><span class="o">-</span><span class="nb">vars</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">query</span><span class="o">-</span><span class="n">res</span> <span class="n">needed</span><span class="o">-</span><span class="nb">vars</span><span class="p">)</span> <span class="n">binded</span><span class="o">-</span><span class="n">res</span><span class="o">-</span><span class="n">col</span><span class="p">))</span>
</pre></div>
</div>
<p>Each unification step is handled by <code class="docutils literal"><span class="pre">locate-vars-in-query-result</span></code>,
which iterates over a query result (structured as an index entry, but
with binding pairs) to detect all the variables and values that the user
asked for.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(defn locate-vars-in-query-res [vars-set q-res]
   (let [[e-pair av-map]  q-res
         e-res (resultify-bind-pair vars-set [] e-pair)]
     (map (partial resultify-av-pair vars-set e-res)  av-map)))
(defn resultify-bind-pair [vars-set accum pair]
   (let [[ var-name _] pair]
      (if (contains? vars-set var-name) (conj accum pair) accum)))
(defn resultify-av-pair [vars-set accum-res av-pair]
   (reduce (partial resultify-bind-pair vars-set) accum-res av-pair))
</pre></div>
</div>
<p>At the end of this phase, the results for our example are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="s2">&quot;?nm&quot;</span> <span class="s2">&quot;USA&quot;</span><span class="p">)</span> <span class="p">(</span><span class="s2">&quot;?bd&quot;</span> <span class="s2">&quot;July 4, 1776&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p class="rubric" id="running-the-show">Running the Show</p>
<p>We've finally built all of the components we need for our user-facing
query mechanism, the <code class="docutils literal"><span class="pre">q</span></code> macro, which receives as arguments a database
and a query.</p>
<div class="code clojure highlight-default"><div class="highlight"><pre><span></span>(defmacro q
  [db query]
  `(let [pred-clauses#  (q-clauses-to-pred-clauses ~(:where query))
         needed-vars# (symbol-col-to-set  ~(:find query))
         query-plan# (build-query-plan pred-clauses#)
         query-internal-res# (query-plan# ~db)]
     (unify query-internal-res# needed-vars#)))
</pre></div>
</div>
<p class="rubric" id="summary">Summary</p>
<p>Our journey started with a conception of a different kind of database,
and ended with one that:</p>
<ul class="simple">
<li>Supports ACI transactions (durability was lost when we decided to
have the data stored in-memory).</li>
<li>Supports &quot;what if&quot; interactions.</li>
<li>Answers time-related questions.</li>
<li>Handles simple datalog queries that are optimized with indexes.</li>
<li>Provides APIs for graph queries.</li>
<li>Introduces and implements the notion of evolutionary queries.</li>
</ul>
<p>There are still many things that we could improve: We could add caching
to several components to improve performance; support richer queries;
and add real storage support to provide data durability, to name a few.</p>
<p>However, our final product can do a great many things, and was
implemented in 488 lines of Clojure source code, 73 of which are blank
lines and 55 of which are docstrings.</p>
<p>Finally, there's one thing that is still missing: a name. The only
sensible option for an in-memory, index-optimized, query-supporting,
library developer-friendly, time-aware functional database implemented
in 360 lines of Clojure code is CircleDB.</p>
</div></div></div></div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Learn-Computer-and-Math-again</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="blockcode-a-visual-programming-toolkit.html">500 Lines or Less | Blockcode: A visual programming toolkit</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, timger.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/chapters/an-archaeology-inspired-database.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>