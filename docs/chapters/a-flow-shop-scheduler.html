
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>500 Lines or Less | A Flow Shop Scheduler &#8212; Learn-Computer-and-Math-again 0.0.1 文档</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lines-or-less-a-flow-shop-scheduler">
<h1>500 Lines or Less | A Flow Shop Scheduler<a class="headerlink" href="#lines-or-less-a-flow-shop-scheduler" title="永久链接至标题">¶</a></h1>
<div class="container"><div class="row"><div class="hero-unit"><p><a href="#id1"><span class="problematic" id="id2">``</span></a>_
.. rubric:: A Flow Shop Scheduler</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">a-flow-shop-scheduler</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p class="author rubric" id="dr-christian-muise">Dr. Christian Muise</p>
</div></div><div class="row"><div id="content" class="span10 offset1"><p><em>`Dr. Christian Muise`_ is a Research Fellow with the `MERS group`_ at
`MIT's CSAIL`_. He is interested in a variety of topics including AI,
data-driven projects, mapping, graph theory, and data visualization, as
well as celtic music, carving, soccer, and coffee.</em></p>
<p class="rubric" id="a-flow-shop-scheduler">A Flow Shop Scheduler</p>
<p><em>Flow shop scheduling</em> is one of the most challenging and well-studied
problems in operations research. Like many challenging optimization
problems, finding the best solution is just not possible for problems of
a practical size. In this chapter we consider the implementation of a
flow shop scheduling solver that uses a technique called <em>local search</em>.
Local search allows us to find a solution that is &quot;pretty good&quot; when
finding the best solution isn't possible. The solver will try and find
new solutions to the problem for a given amount of time, and finish by
returning the best solution found.</p>
<p>The idea behind local search is to improve an existing solution
heuristically by considering similar solutions that may be a little
better. The solver uses a variety of strategies to (1) try and find
similar solutions, and (2) choose one that is promising to explore next.
The implementation is written in Python, and has no external
requirements. By leveraging some of Python's lesser-known functionality,
the solver dynamically changes its search strategy during the solving
process based on which strategies work well.</p>
<p>First, we provide some background material on the flow shop scheduling
problem and local search techniques. We then look in detail at the
general solver code and the various heuristics and neighbourhood
selection strategies that we use. Next we consider the dynamic strategy
selection that the solver uses to tie everything together. Finally, we
conclude with a summary of the project and some lessons learned through
the implementation process.</p>
<p class="rubric" id="background">Background</p>
<p class="rubric" id="flow-shop-scheduling">Flow Shop Scheduling</p>
<p>The flow shop scheduling problem is an optimization problem in which we
must determine the processing time for various tasks in a job in order
to schedule the tasks to minimize the total time it takes to complete
the job. Take, for example, a car manufacturer with an assembly line
where each part of the car is completed in sequence on different
machines. Different orders may have custom requirements, making the task
of painting the body, for example, vary from one car to the next. In our
example, each car is a new <em>job</em> and each part for the car is called a
<em>task</em>. Every job will have the same sequence of tasks to complete.</p>
<p>The objective in flow shop scheduling is to minimize the total time it
takes to process all of the tasks from every job to completion.
(Typically, this total time is referred to as the <em>makespan</em>.) This
problem has many applications, but is most related to optimizing
production facilities.</p>
<p>Every flow shop problem consists of \(n\) machines and \(m\) jobs.
In our car example, there will be \(n\) stations to work on the car
and \(m\) cars to make in total. Each job is made up of exactly
\(n\) tasks, and we can assume that the \(i\)-th task of a job must
use machine \(i\) and requires a predetermined amount of processing
time: \(p(j,i)\) is the processing time for the \(i\)th task of job
\(j\). Further, the order of the tasks for any given job should follow
the order of the machines available; for a given job, task \(i\) must
be completed prior to the start of task \(i+1\). In our car example,
we wouldn't want to start painting the car before the frame was
assembled. The final restriction is that no two tasks can be processed
on a machine simultaneously.</p>
<p>Because the order of tasks within a job is predetermined, a solution to
the flow shop scheduling problem can be represented as a permutation of
the jobs. The order of jobs processed on a machine will be the same for
every machine, and given a permutation, a task for machine \(i\) in
job \(j\) is scheduled to be the latest of the following two
possibilities:</p>
<ol class="arabic simple">
<li>The completion of the task for machine \(i\) in job \(j-1\)
(i.e., the most recent task on the same machine), or</li>
<li>The completion of the task for machine \(i-1\) in job \(j\)
(i.e., the most recent task on the same job)</li>
</ol>
<p>Because we select the maximum of these two values, idle time for either
machine \(i\) or job \(j\) will be created. It is this idle time
that we ultimately want to minimize, as it will push the total makespan
to be larger.</p>
<p>Due to the simple form of the problem, any permutation of jobs is a
valid solution, and the optimal solution will correspond to <em>some</em>
permutation. Thus, we search for improved solutions by changing the
permutation of jobs and measuring the corresponding makespan. In what
follows, we refer to a permutation of the jobs as a <em>candidate</em>.</p>
<p>Let's consider a simple example with two jobs and two machines. The
first job has tasks \(\mathbf{A}\) and \(\mathbf{B}\), which take
1 and 2 minutes to complete respectively. The second job has tasks
\(\mathbf{C}\) and \(\mathbf{D}\), which take 2 and 1 minutes to
complete respectively. Recall that \(\mathbf{A}\) must come before
\(\mathbf{B}\) and \(\mathbf{C}\) must come before
\(\mathbf{D}\). Because there are two jobs, we have just two
permutations to consider. If we order job 2 before job 1, the makespan
is 5 (<a class="reference external" href="#figure-9.1">Figure 9.1</a>); on the other hand, if we order job 1 before job 2,
the makespan is only 4 (<a class="reference external" href="#figure-9.2">Figure 9.2</a>).</p>
<div class="center figure"><p><img alt="Figure 9.1 - Flow Shop Example 1" src="chapters/flow-shop-images/example1.png" /></p>
</div><p>Figure 9.1 - Flow Shop Example 1</p>
<div class="center figure"><p><img alt="Figure 9.2 - Flow Shop Example 2" src="chapters/flow-shop-images/example2.png" /></p>
</div><p>Figure 9.2 - Flow Shop Example 2</p>
<p>Notice that there is no budge room to push any of the tasks earlier. A
guiding principle for a good permutation is to minimize the time in
which any machine is left without a task to process.</p>
<p class="rubric" id="local-search">Local Search</p>
<p>Local search is a strategy for solving optimization problems when the
optimal solution is too hard to compute. Intuitively, it moves from one
solution that seems pretty good to another solution that seems even
better. Rather than considering every possible solution as a candidate
to focus on next, we define what is known as a <em>neighbourhood</em>: the set
of solutions considered to be similar to the current solution. Because
any permutation of jobs is a valid solution, we can view any mechanism
that shuffles the jobs around as a local search procedure (this is in
fact what we do below).</p>
<p>To use local search formally, we must answer a few questions:</p>
<ol class="arabic simple">
<li>What solution should we start with?</li>
<li>Given a solution, what are the neighbouring solutions that we should
consider?</li>
<li>Given the set of candidate neighbours, which one should we consider
moving to next?</li>
</ol>
<p>The following three sections address these questions in turn.</p>
<p class="rubric" id="general-solver">General Solver</p>
<p>In this section we provide the general framework for the flow shop
scheduler. To begin, we have the necessary Python imports and the
settings for the solver:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>

<span class="kn">import</span> <span class="nn">neighbourhood</span> <span class="k">as</span> <span class="nn">neigh</span>
<span class="kn">import</span> <span class="nn">heuristics</span> <span class="k">as</span> <span class="nn">heur</span>

<span class="c1">##############</span>
<span class="c1">## Settings ##</span>
<span class="c1">##############</span>
<span class="n">TIME_LIMIT</span> <span class="o">=</span> <span class="mf">300.0</span> <span class="c1"># Time (in seconds) to run the solver</span>
<span class="n">TIME_INCREMENT</span> <span class="o">=</span> <span class="mf">13.0</span> <span class="c1"># Time (in seconds) in between heuristic measurements</span>
<span class="n">DEBUG_SWITCH</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Displays intermediate heuristic info when True</span>
<span class="n">MAX_LNS_NEIGHBOURHOODS</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c1"># Maximum number of neighbours to explore in LNS</span>
</pre></div>
</div>
<p>There are two settings that should be explained further. The
<code class="docutils literal"><span class="pre">TIME_INCREMENT</span></code> setting will be used as part of the dynamic strategy
selection, and the <code class="docutils literal"><span class="pre">MAX_LNS_NEIGHBOURHOODS</span></code> setting will be used as
part of the neighbourhood selection strategy. Both are described in more
detail below.</p>
<p>These settings could be exposed to the user as command line parameters,
but at this stage we instead provide the input data as parameters to the
program. The input problem—a problem from the Taillard benchmark set—is
assumed to be in a standard format for flow shop scheduling. The
following code is used as the <code class="docutils literal"><span class="pre">__main__</span></code> method for the solver file,
and calls the appropriate functions based on the number of parameters
input to the program:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">parse_problem</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">parse_problem</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Usage: python flow.py &lt;Taillard problem file&gt; [&lt;instance number&gt;]</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">ms</span><span class="p">)</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">print_solution</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
</pre></div>
</div>
<p>We will describe the parsing of Taillard problem files shortly. (The
files are <a class="reference external" href="http://mistic.heig-vd.ch/taillard/problemes.dir/ordonnancement.dir/ordonnancement.html">available online</a>.)</p>
<p>The <code class="docutils literal"><span class="pre">solve</span></code> method expects the <code class="docutils literal"><span class="pre">data</span></code> variable to be a list of
integers containing the activity durations for each job. The <code class="docutils literal"><span class="pre">solve</span></code>
method starts by initializing a global set of strategies (to be
described below). The key is that we use <code class="docutils literal"><span class="pre">strat_*</span></code> variables to
maintain statistics on each of the strategies. This aids in selecting
the strategy dynamically during the solving process.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solves an instance of the flow shop scheduling problem&quot;&quot;&quot;</span>

    <span class="c1"># We initialize the strategies here to avoid cyclic import issues</span>
    <span class="n">initialize_strategies</span><span class="p">()</span>
    <span class="k">global</span> <span class="n">STRATEGIES</span>

    <span class="c1"># Record the following for each strategy:</span>
    <span class="c1">#  improvements: The amount a solution was improved by this strategy</span>
    <span class="c1">#  time_spent: The amount of time spent on the strategy</span>
    <span class="c1">#  weights: The weights that correspond to how good a strategy is</span>
    <span class="c1">#  usage: The number of times we use a strategy</span>
    <span class="n">strat_improvements</span> <span class="o">=</span> <span class="p">{</span><span class="n">strategy</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">STRATEGIES</span><span class="p">}</span>
    <span class="n">strat_time_spent</span> <span class="o">=</span> <span class="p">{</span><span class="n">strategy</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">STRATEGIES</span><span class="p">}</span>
    <span class="n">strat_weights</span> <span class="o">=</span> <span class="p">{</span><span class="n">strategy</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">STRATEGIES</span><span class="p">}</span>
    <span class="n">strat_usage</span> <span class="o">=</span> <span class="p">{</span><span class="n">strategy</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">STRATEGIES</span><span class="p">}</span>
</pre></div>
</div>
<p>One appealing feature of the flow shop scheduling problem is that
<em>every</em> permutation is a valid solution, and at least one will have the
optimal makespan (though many will have horrible makespans). Thankfully,
this allows us to forgo checking that we stay within the space of
feasible solutions when going from one permutation to another—everything
is feasible!</p>
<p>However, to start a local search in the space of permutations, we must
have an initial permutation. To keep things simple, we seed our local
search by shuffling the list of jobs randomly:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Start with a random permutation of the jobs</span>
<span class="n">perm</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we initialize the variables that allow us to keep track of the
best permutation found so far, as well as the timing information for
providing output.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Keep track of the best solution</span>
<span class="n">best_make</span> <span class="o">=</span> <span class="n">makespan</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
<span class="n">best_perm</span> <span class="o">=</span> <span class="n">perm</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">best_make</span>

<span class="c1"># Maintain statistics and timing for the iterations</span>
<span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">time_limit</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">TIME_LIMIT</span>
<span class="n">time_last_switch</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="n">time_delta</span> <span class="o">=</span> <span class="n">TIME_LIMIT</span> <span class="o">/</span> <span class="mi">10</span>
<span class="n">checkpoint</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">time_delta</span>
<span class="n">percent_complete</span> <span class="o">=</span> <span class="mi">10</span>

<span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Solving...&quot;</span>
</pre></div>
</div>
<p>As this is a local search solver, we simply continue to try and improve
solutions as long as the time limit has not been reached. We provide
output indicating the progress of the solver and keep track of the
number of iterations we have computed:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">time_limit</span><span class="p">:</span>

    <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">checkpoint</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot; </span><span class="si">%d</span><span class="s2"> </span><span class="si">%%</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">percent_complete</span>
        <span class="n">percent_complete</span> <span class="o">+=</span> <span class="mi">10</span>
        <span class="n">checkpoint</span> <span class="o">+=</span> <span class="n">time_delta</span>

    <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Below we describe how the strategy is picked, but for now it is
sufficient to know that the strategy provides a <code class="docutils literal"><span class="pre">neighbourhood</span></code>
function and a <code class="docutils literal"><span class="pre">heuristic</span></code> function. The former gives us a set of
<em>next candidates</em> to consider while the latter chooses the <em>best
candidate</em> from the set. From these functions, we have a new permutation
(<code class="docutils literal"><span class="pre">perm</span></code>) and a new makespan result (<code class="docutils literal"><span class="pre">res</span></code>):</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Heuristically choose the best strategy</span>
<span class="n">strategy</span> <span class="o">=</span> <span class="n">pick_strategy</span><span class="p">(</span><span class="n">STRATEGIES</span><span class="p">,</span> <span class="n">strat_weights</span><span class="p">)</span>

<span class="n">old_val</span> <span class="o">=</span> <span class="n">res</span>
<span class="n">old_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="c1"># Use the current strategy&#39;s heuristic to pick the next permutation from</span>
<span class="c1"># the set of candidates generated by the strategy&#39;s neighbourhood</span>
<span class="n">candidates</span> <span class="o">=</span> <span class="n">strategy</span><span class="o">.</span><span class="n">neighbourhood</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
<span class="n">perm</span> <span class="o">=</span> <span class="n">strategy</span><span class="o">.</span><span class="n">heuristic</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">candidates</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">makespan</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
</pre></div>
</div>
<p>The code for computing the makespan is quite simple: we can compute it
from a permutation by evaluating when the final job completes. We will
see below how <code class="docutils literal"><span class="pre">compile_solution</span></code> works, but for now it suffices to
know that a 2D array is returned and the element at <code class="docutils literal"><span class="pre">[-1][-1]</span></code>
corresponds to the start time of the final job in the schedule:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">makespan</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the makespan of the provided solution&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">compile_solution</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>To help select a strategy, we keep statistics on (1) how much the
strategy has improved the solution, (2) how much time the strategy has
spent computing information, and (3) how many times the strategy was
used. We also update the variables for the best permutation if we
stumble upon a better solution:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Record the statistics on how the strategy did</span>
<span class="n">strat_improvements</span><span class="p">[</span><span class="n">strategy</span><span class="p">]</span> <span class="o">+=</span> <span class="n">res</span> <span class="o">-</span> <span class="n">old_val</span>
<span class="n">strat_time_spent</span><span class="p">[</span><span class="n">strategy</span><span class="p">]</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">old_time</span>
<span class="n">strat_usage</span><span class="p">[</span><span class="n">strategy</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">if</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="n">best_make</span><span class="p">:</span>
    <span class="n">best_make</span> <span class="o">=</span> <span class="n">res</span>
    <span class="n">best_perm</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[:]</span>
</pre></div>
</div>
<p>At regular intervals, the statistics for strategy use are updated. We
removed the associated snippet for readability, and detail the code
below. As a final step, once the while loop is complete (i.e., the time
limit is reached) we output some statistics about the solving process
and return the best permutation along with its makespan:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="s2">&quot; </span><span class="si">%d</span><span class="s2"> </span><span class="si">%%</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">percent_complete</span>
<span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Went through </span><span class="si">%d</span><span class="s2"> iterations.&quot;</span> <span class="o">%</span> <span class="n">iteration</span>

<span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(usage) Strategy:&quot;</span>
<span class="n">results</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([(</span><span class="n">strat_weights</span><span class="p">[</span><span class="n">STRATEGIES</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">i</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">STRATEGIES</span><span class="p">))],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
    <span class="nb">print</span> <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2">) </span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">strat_usage</span><span class="p">[</span><span class="n">STRATEGIES</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">STRATEGIES</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="k">return</span> <span class="p">(</span><span class="n">best_perm</span><span class="p">,</span> <span class="n">best_make</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric" id="parsing-problems">Parsing Problems</p>
<p>As input to the parsing procedure, we provide the file name where the
input can be found and the example number that should be used. (Each
file contains a number of instances.)</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_problem</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s2">&quot;&quot;&quot;Parse the kth instance of a Taillard problem file</span>

<span class="s2">    The Taillard problem files are a standard benchmark set for the problem</span>
<span class="s2">    of flow shop scheduling.</span>

<span class="s2">    print &quot;</span><span class="se">\n</span><span class="s2">Parsing...&quot;</span>
</pre></div>
</div>
<p>We start the parsing by reading in the file and identifying the line
that separates each of the problem instances:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># Identify the string that separates instances</span>
    <span class="n">problem_line</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;/number of jobs, number of machines, initial seed, &#39;</span>
                    <span class="s1">&#39;upper bound and lower bound :/&#39;</span><span class="p">)</span>

    <span class="c1"># Strip spaces and newline characters from every line</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">strip</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">())</span>
</pre></div>
</div>
<p>To make locating the correct instance easier, we assume that lines will
be separated by a '/' character. This allows us to split the file based
on a common string that appears at the top of every instance, and adding
a '/' character to the start of the first line allows the string
processing below to work correctly regardless of the instance we choose.
We also detect when a provided instance number is out of range given the
collection of instances found in the file.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># We prep the first line for later</span>
<span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># We also know &#39;/&#39; does not appear in the files, so we can use it as</span>
<span class="c1">#  a separator to find the right lines for the kth problem instance</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">problem_line</span><span class="p">)[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>
<span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
    <span class="n">max_instances</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">problem_line</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Error: Instance must be within 1 and </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">max_instances</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>We parse the data directly, converting the processing time of each task
to an integer and storing it in a list. Finally, we zip the data to
invert the rows and columns so that the format respects what is expected
by the solving code above. (Every item in <code class="docutils literal"><span class="pre">data</span></code> should correspond to
a particular job.)</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span>    <span class="c1"># Split every line based on spaces and convert each item to an int</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>

<span class="c1"># We return the zipped data to rotate the rows and columns, making each</span>
<span class="c1">#  item in data the durations of tasks for a particular job</span>
<span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric" id="compiling-solutions">Compiling Solutions</p>
<p>A solution to the flow shop scheduling problem consists of precise
timing for each task in every job. Because we represent a solution
implicitly with a permutation of the jobs, we introduce the
<code class="docutils literal"><span class="pre">compile_solution</span></code> function to convert a permutation to precise times.
As input, the function takes in the data for the problem (giving us the
duration of every task) and a permutation of jobs.</p>
<p>The function begins by initializing the data structure used to store the
starting time for each task, and then including the tasks from the first
job in the permutation.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compile_solution</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compiles a scheduling on the machines given a permutation of jobs&quot;&quot;&quot;</span>

    <span class="n">num_machines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Note that using [[]] * m would be incorrect, as it would simply</span>
    <span class="c1">#  copy the same list m times (as opposed to creating m distinct lists).</span>
    <span class="n">machine_times</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_machines</span><span class="p">)]</span>

    <span class="c1"># Assign the initial job to the machines</span>
    <span class="n">machine_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">mach</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num_machines</span><span class="p">):</span>
        <span class="c1"># Start the next task in the job when the previous finishes</span>
        <span class="n">machine_times</span><span class="p">[</span><span class="n">mach</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">machine_times</span><span class="p">[</span><span class="n">mach</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                                   <span class="n">data</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">mach</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>We then add all the tasks for the remaining jobs. The first task in a
job will always start as soon as the first task in the previous job
completes. For the remaining tasks, we schedule the job as early as
possible: the maximum out of the completion time of the previous task in
the same job and the completion time of the previous task on the same
machine.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Assign the remaining jobs</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)):</span>

    <span class="c1"># The first machine never contains any idle time</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">machine_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">machine_times</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># For the remaining machines, the start time is the max of when the</span>
    <span class="c1">#  previous task in the job completed, or when the current machine</span>
    <span class="c1">#  completes the task for the previous job.</span>
    <span class="k">for</span> <span class="n">mach</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_machines</span><span class="p">):</span>
        <span class="n">machine_times</span><span class="p">[</span><span class="n">mach</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span>
            <span class="n">machine_times</span><span class="p">[</span><span class="n">mach</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">mach</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">machine_times</span><span class="p">[</span><span class="n">mach</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">mach</span><span class="p">]))</span>

<span class="k">return</span> <span class="n">machine_times</span>
</pre></div>
</div>
<p class="rubric" id="printing-solutions">Printing Solutions</p>
<p>When the solving process is complete, the program outputs information
about the solution in a compact form. Rather than providing the precise
timing of every task for every job, we output the following pieces of
information:</p>
<ol class="arabic simple">
<li>The permutation of jobs that yielded the best makespan</li>
<li>The computed makespan of the permutation</li>
<li>The start time, finish time, and idle time for every machine</li>
<li>The start time, finish time, and idle time for every job</li>
</ol>
<p>The start time for a job or machine corresponds to the start of the
first task in the job or on the machine. Similarly, the finish time for
a job or machine corresponds to the end of the final task in the job or
on the machine. The idle time is the amount of slack in between tasks
for a particular job or machine. Ideally we would like to reduce the
amount of idle time, as it means the overall process time will be
reduced as well.</p>
<p>The code to compile the solution (i.e., to compute the start times for
every task) has already been discussed, and outputting the permutation
and makespan are trivial:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_solution</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prints statistics on the computed solution&quot;&quot;&quot;</span>

    <span class="n">sol</span> <span class="o">=</span> <span class="n">compile_solution</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>

    <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Permutation: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">])</span>

    <span class="nb">print</span> <span class="s2">&quot;Makespan: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">makespan</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we use the string formatting functionality in Python to print the
table of start, end, and idle times for each of the machines and jobs.
Note that the idle time for a job is the time from when the job started
to its completion, minus the sum of the processing times for each task
in the job. We compute the idle time for a machine in a similar fashion.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">row_format</span> <span class="o">=</span><span class="s2">&quot;</span><span class="si">{:&gt;15}</span><span class="s2">&quot;</span> <span class="o">*</span> <span class="mi">4</span>
<span class="nb">print</span> <span class="n">row_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Machine&#39;</span><span class="p">,</span> <span class="s1">&#39;Start Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Finish Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Idle Time&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">mach</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
    <span class="n">finish_time</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">mach</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">mach</span><span class="p">]</span>
    <span class="n">idle_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">finish_time</span> <span class="o">-</span> <span class="n">sol</span><span class="p">[</span><span class="n">mach</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">([</span><span class="n">job</span><span class="p">[</span><span class="n">mach</span><span class="p">]</span> <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
    <span class="nb">print</span> <span class="n">row_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mach</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">sol</span><span class="p">[</span><span class="n">mach</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">finish_time</span><span class="p">,</span> <span class="n">idle_time</span><span class="p">)</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
    <span class="n">finish_time</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">idle_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">finish_time</span> <span class="o">-</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">([</span><span class="n">time</span> <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]])</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">finish_time</span><span class="p">,</span> <span class="n">idle_time</span><span class="p">))</span>

<span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
<span class="nb">print</span> <span class="n">row_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Job&#39;</span><span class="p">,</span> <span class="s1">&#39;Start Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Finish Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Idle Time&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">row_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span>

<span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Note: Idle time does not include initial or final wait time.</span><span class="se">\n</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p class="rubric" id="neighbourhoods">Neighbourhoods</p>
<p>The idea behind local search is to move <em>locally</em> from one solution to
other solutions nearby. We refer to the <em>neighbourhood</em> of a given
solution as the other solutions that are local to it. In this section,
we detail four potential neighbourhoods, each of increasing complexity.</p>
<p>The first neighbourhood produces a given number of random permutations.
This neighbourhood does not even consider the solution that we begin
with, and so the term &quot;neighbourhood&quot; stretches the truth. However,
including some randomness in the search is good practice, as it promotes
exploration of the search space.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">neighbours_random</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Returns &lt;num&gt; random job permutations, including the current one</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[:]</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">candidates</span>
</pre></div>
</div>
<p>For the next neighbourhood, we consider swapping any two jobs in the
permutation. By using the <code class="docutils literal"><span class="pre">combinations</span></code> function from the
<code class="docutils literal"><span class="pre">itertools</span></code> package, we can easily iterate through every pair of
indices and create a new permutation that corresponds to swapping the
jobs located at each index. In a sense, this neighbourhood creates
permutations that are very similar to the one we began with.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">neighbours_swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
    <span class="c1"># Returns the permutations corresponding to swapping every pair of jobs</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span><span class="p">]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[:]</span>
        <span class="n">candidate</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">candidate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">candidate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">candidates</span>
</pre></div>
</div>
<p>The next neighbourhood we consider uses information specific to the
problem at hand. We find the jobs with the most idle time and consider
swapping them in every way possible. We take in a value <code class="docutils literal"><span class="pre">size</span></code> which
is the number of jobs we consider: the <code class="docutils literal"><span class="pre">size</span></code> most idle jobs. The
first step in the process is to compute the idle time for every job in
the permutation:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">neighbours_idle</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="c1"># Returns the permutations of the &lt;size&gt; most idle jobs</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span><span class="p">]</span>

    <span class="c1"># Compute the idle time for each job</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">compile_solution</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
        <span class="n">finish_time</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">idle_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">finish_time</span> <span class="o">-</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]])</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">idle_time</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
</pre></div>
</div>
<p>Next, we compute the list of <code class="docutils literal"><span class="pre">size</span></code> jobs that have the most idle time.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Take the &lt;size&gt; most idle jobs</span>
<span class="n">subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">job_ind</span> <span class="k">for</span> <span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="n">job_ind</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">results</span><span class="p">))][:</span><span class="n">size</span><span class="p">]</span>
</pre></div>
</div>
<p>Finally, we construct the neighbourhood by considering every permutation
of the most idle jobs that we have identified. To find the permutations,
we make use of the <code class="docutils literal"><span class="pre">permutations</span></code> function from the <code class="docutils literal"><span class="pre">itertools</span></code>
package.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Enumerate the permutations of the idle jobs</span>
<span class="k">for</span> <span class="n">ordering</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">subset</span><span class="p">):</span>
    <span class="n">candidate</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[:]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ordering</span><span class="p">)):</span>
        <span class="n">candidate</span><span class="p">[</span><span class="n">subset</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">ordering</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

<span class="k">return</span> <span class="n">candidates</span>
</pre></div>
</div>
<p>The final neighbourhood that we consider is commonly referred to as
<em>Large Neighbourhood Search</em> (LNS). Intuitively, LNS works by
considering small subsets of the current permutation in
isolation—locating the best permutation of the subset of jobs gives us a
single candidate for the LNS neighbourhood. By repeating this process
for several (or all) subsets of a particular size, we can increase the
number of candidates in the neighbourhood. We limit the number that are
considered through the <code class="docutils literal"><span class="pre">MAX_LNS_NEIGHBOURHOODS</span></code> parameter, as the
number of neighbours can grow quite quickly. The first step in the LNS
computation is to compute the random list of job sets that we will
consider swapping using the <code class="docutils literal"><span class="pre">combinations</span></code> function of the
<code class="docutils literal"><span class="pre">itertools</span></code> package:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">neighbours_LNS</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
    <span class="c1"># Returns the Large Neighbourhood Search neighbours</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span><span class="p">]</span>

    <span class="c1"># Bound the number of neighbourhoods in case there are too many jobs</span>
    <span class="n">neighbourhoods</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)),</span> <span class="n">size</span><span class="p">))</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">neighbourhoods</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we iterate through the subsets to find the best permutation of
jobs in each one. We have seen similar code above for iterating through
all permutations of the most idle jobs. The key difference here is that
we record only the best permutation for the subset, as the larger
neighbourhood is constructed by choosing one permutation for each subset
of the considered jobs.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">neighbourhoods</span><span class="p">[:</span><span class="n">flow</span><span class="o">.</span><span class="n">MAX_LNS_NEIGHBOURHOODS</span><span class="p">]:</span>

    <span class="c1"># Keep track of the best candidate for each neighbourhood</span>
    <span class="n">best_make</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">makespan</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
    <span class="n">best_perm</span> <span class="o">=</span> <span class="n">perm</span>

    <span class="c1"># Enumerate every permutation of the selected neighbourhood</span>
    <span class="k">for</span> <span class="n">ordering</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">subset</span><span class="p">):</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ordering</span><span class="p">)):</span>
            <span class="n">candidate</span><span class="p">[</span><span class="n">subset</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">ordering</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">makespan</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="n">best_make</span><span class="p">:</span>
            <span class="n">best_make</span> <span class="o">=</span> <span class="n">res</span>
            <span class="n">best_perm</span> <span class="o">=</span> <span class="n">candidate</span>

    <span class="c1"># Record the best candidate as part of the larger neighbourhood</span>
    <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_perm</span><span class="p">)</span>

<span class="k">return</span> <span class="n">candidates</span>
</pre></div>
</div>
<p>If we were to set the <code class="docutils literal"><span class="pre">size</span></code> parameter to be equal to the number of
jobs, then every permutation would be considered and the best one
selected. In practice, however, we need to limit the size of the subset
to around 3 or 4; anything larger would cause the <code class="docutils literal"><span class="pre">neighbours_LNS</span></code>
function to take a prohibitive amount of time.</p>
<p class="rubric" id="heuristics">Heuristics</p>
<p>A heuristic returns a single candidate permutation from a set of
provided candidates. The heuristic is also given access to the problem
data in order to evaluate which candidate might be preferred.</p>
<p>The first heuristic that we consider is <code class="docutils literal"><span class="pre">heur_random</span></code>. This heuristic
randomly selects a candidate from the list without evaluating which one
might be preferred:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">heur_random</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">candidates</span><span class="p">):</span>
    <span class="c1"># Returns a random candidate choice</span>
    <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
</pre></div>
</div>
<p>The next heuristic <code class="docutils literal"><span class="pre">heur_hillclimbing</span></code> uses the other extreme. Rather
than randomly selecting a candidate, it selects the candidate that has
the best makespan. Note that the list <code class="docutils literal"><span class="pre">scores</span></code> will contain tuples of
the form <code class="docutils literal"><span class="pre">(make,perm)</span></code> where <code class="docutils literal"><span class="pre">make</span></code> is the makespan value for
permutation <code class="docutils literal"><span class="pre">perm</span></code>. Sorting such a list places the tuple with the best
makespan at the start of the list; from this tuple we return the
permutation.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">heur_hillclimbing</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">candidates</span><span class="p">):</span>
    <span class="c1"># Returns the best candidate in the list</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="p">[(</span><span class="n">flow</span><span class="o">.</span><span class="n">makespan</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">),</span> <span class="n">perm</span><span class="p">)</span> <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">scores</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>The final heuristic, <code class="docutils literal"><span class="pre">heur_random_hillclimbing</span></code>, combines both the
random and hillclimbing heuristics above. When performing local search,
you may not always want to choose a random candidate, or even the best
one. The <code class="docutils literal"><span class="pre">heur_random_hillclimbing</span></code> heuristic returns a &quot;pretty good&quot;
solution by choosing the best candidate with probability 0.5, then the
second best with probability 0.25, and so on. The while-loop essentially
flips a coin at every iteration to see if it should continue increasing
the index (with a limit on the size of the list). The final index chosen
corresponds to the candidate that the heuristic selects.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">heur_random_hillclimbing</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">candidates</span><span class="p">):</span>
    <span class="c1"># Returns a candidate with probability proportional to its rank in sorted quality</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="p">[(</span><span class="n">flow</span><span class="o">.</span><span class="n">makespan</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">),</span> <span class="n">perm</span><span class="p">)</span> <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">scores</span><span class="p">)[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Because makespan is the criteria that we are trying to optimize,
hillclimbing will steer the local search process towards solutions with
a better makespan. Introducing randomness allows us to explore the
neighbourhood instead of going blindly towards the best-looking solution
at every step.</p>
<p class="rubric" id="dynamic-strategy-selection">Dynamic Strategy Selection</p>
<p>At the heart of the local search for a good permutation is the use of a
particular heuristic and neighbourhood function to jump from one
solution to another. How do we choose one set of options over another?
In practice, it frequently pays off to switch strategies during the
search. The dynamic strategy selection that we use will switch between
combinations of heuristic and neighbourhood functions to try and shift
dynamically to those strategies that work best. For us, a <em>strategy</em> is
a particular configuration of heuristic and neighbourhood functions
(including their parameter values.)</p>
<p>To begin, our code constructs the range of strategies that we want to
consider during solving. In the strategy initialization, we use the
<code class="docutils literal"><span class="pre">partial</span></code> function from the <code class="docutils literal"><span class="pre">functools</span></code> package to partially assign
the parameters for each of the neighbourhoods. Additionally, we
construct a list of the heuristic functions, and finally we use the
product operator to add every combination of neighbourhood and heuristic
function as a new strategy.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1">################</span>
<span class="c1">## Strategies ##</span>
<span class="c1">#################################################</span>
<span class="c1">## A strategy is a particular configuration</span>
<span class="c1">##  of neighbourhood generator (to compute</span>
<span class="c1">##  the next set of candidates) and heuristic</span>
<span class="c1">##  computation (to select the best candidate).</span>
<span class="c1">##</span>

<span class="n">STRATEGIES</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Using a namedtuple is a little cleaner than using dictionaries.</span>
<span class="c1">#  E.g., strategy[&#39;name&#39;] versus strategy.name</span>
<span class="n">Strategy</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Strategy&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;neighbourhood&#39;</span><span class="p">,</span> <span class="s1">&#39;heuristic&#39;</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">initialize_strategies</span><span class="p">():</span>

    <span class="k">global</span> <span class="n">STRATEGIES</span>

    <span class="c1"># Define the neighbourhoods (and parameters) that we would like to use</span>
    <span class="n">neighbourhoods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;Random Permutation&#39;</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">neighbours_random</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">)),</span>
        <span class="p">(</span><span class="s1">&#39;Swapped Pairs&#39;</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">neighbours_swap</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;Large Neighbourhood Search (2)&#39;</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">neighbours_LNS</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)),</span>
        <span class="p">(</span><span class="s1">&#39;Large Neighbourhood Search (3)&#39;</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">neighbours_LNS</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)),</span>
        <span class="p">(</span><span class="s1">&#39;Idle Neighbourhood (3)&#39;</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">neighbours_idle</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)),</span>
        <span class="p">(</span><span class="s1">&#39;Idle Neighbourhood (4)&#39;</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">neighbours_idle</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">)),</span>
        <span class="p">(</span><span class="s1">&#39;Idle Neighbourhood (5)&#39;</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">neighbours_idle</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
    <span class="p">]</span>

    <span class="c1"># Define the heuristics that we would like to use</span>
    <span class="n">heuristics</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;Hill Climbing&#39;</span><span class="p">,</span> <span class="n">heur</span><span class="o">.</span><span class="n">heur_hillclimbing</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;Random Selection&#39;</span><span class="p">,</span> <span class="n">heur</span><span class="o">.</span><span class="n">heur_random</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;Biased Random Selection&#39;</span><span class="p">,</span> <span class="n">heur</span><span class="o">.</span><span class="n">heur_random_hillclimbing</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># Combine every neighbourhood and heuristic strategy</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">neighbourhoods</span><span class="p">,</span> <span class="n">heuristics</span><span class="p">):</span>
        <span class="n">STRATEGIES</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Strategy</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> / </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>Once the strategies are defined, we do not necessarily want to stick
with a single option during search. Instead, we select randomly any one
of the strategies, but <em>weight the selection</em> based on how well the
strategy has performed. We describe the weighting below, but for the
<code class="docutils literal"><span class="pre">pick_strategy</span></code> function, we need only a list of strategies and a
corresponding list of relative weights (any number will do). To select a
random strategy with the given weights, we pick a number uniformly
between 0 and the sum of all weights. Subsequently, we find the lowest
index \(i\) such that the sum of all of the weights for indices
smaller than \(i\) is greater than the random number that we have
chosen. This technique, sometimes referred to as <em>roulette wheel
selection</em>, will randomly pick a strategy for us and give a greater
chance to those strategies with higher weight.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pick_strategy</span><span class="p">(</span><span class="n">strategies</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="c1"># Picks a random strategy based on its weight: roulette wheel selection</span>
    <span class="c1">#  Rather than selecting a strategy entirely at random, we bias the</span>
    <span class="c1">#  random selection towards strategies that have worked well in the</span>
    <span class="c1">#  past (according to the weight value).</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">weights</span><span class="p">[</span><span class="n">strategy</span><span class="p">]</span> <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">strategies</span><span class="p">])</span>
    <span class="n">pick</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">strategies</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">pick</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">strategies</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">strategies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>What remains is to describe how the weights are augmented during the
search for a solution. This occurs in the main while loop of the solver
at regularly timed intervals (defined with the <code class="docutils literal"><span class="pre">TIME_INCREMENT</span></code>
variable):</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># At regular intervals, switch the weighting on the strategies available.</span>
<span class="c1">#  This way, the search can dynamically shift towards strategies that have</span>
<span class="c1">#  proven more effective recently.</span>
<span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">time_last_switch</span> <span class="o">+</span> <span class="n">TIME_INCREMENT</span><span class="p">:</span>

    <span class="n">time_last_switch</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</pre></div>
</div>
<p>Recall that <code class="docutils literal"><span class="pre">strat_improvements</span></code> stores the sum of all improvements
that a strategy has made while <code class="docutils literal"><span class="pre">strat_time_spent</span></code> stores the time that
the strategy has been given during the last interval. We normalize the
improvements made by the total time spent for each strategy to get a
metric of how well each strategy has performed in the last interval.
Because a strategy may not have had a chance to run at all, we choose a
small amount of time as a default value.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Normalize the improvements made by the time it takes to make them</span>
<span class="n">results</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span>
    <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">strat_improvements</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">strat_time_spent</span><span class="p">[</span><span class="n">s</span><span class="p">]),</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">STRATEGIES</span><span class="p">])</span>
</pre></div>
</div>
<p>Now that we have a ranking of how well each strategy has performed, we
add \(k\) to the weight of the best strategy (assuming we had \(k\)
strategies), \(k-1\) to the next best strategy, etc. Each strategy
will have its weight increased, and the worst strategy in the list will
see an increase of only 1.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Boost the weight for the successful strategies</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">STRATEGIES</span><span class="p">)):</span>
    <span class="n">strat_weights</span><span class="p">[</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">STRATEGIES</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span>
</pre></div>
</div>
<p>As an extra measure, we artificially bump up all of the strategies that
were not used. This is done so that we do not forget about a strategy
entirely. While one strategy may appear to perform badly in the
beginning, later in the search it can prove quite useful.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Additionally boost the unused strategies to avoid starvation</span>
<span class="k">if</span> <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">strat_weights</span><span class="p">[</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">STRATEGIES</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we output some information about the strategy ranking (if the
<code class="docutils literal"><span class="pre">DEBUG_SWITCH</span></code> flag is set), and we reset the <code class="docutils literal"><span class="pre">strat_improvements</span></code>
and <code class="docutils literal"><span class="pre">strat_time_spent</span></code> variables for the next interval.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">DEBUG_SWITCH</span><span class="p">:</span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Computing another switch...&quot;</span>
    <span class="nb">print</span> <span class="s2">&quot;Best: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span> <span class="s2">&quot;Worst: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span> <span class="n">results</span>
    <span class="nb">print</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">strat_weights</span><span class="p">[</span><span class="n">STRATEGIES</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">STRATEGIES</span><span class="p">))])</span>

<span class="n">strat_improvements</span> <span class="o">=</span> <span class="p">{</span><span class="n">strategy</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">STRATEGIES</span><span class="p">}</span>
<span class="n">strat_time_spent</span> <span class="o">=</span> <span class="p">{</span><span class="n">strategy</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">STRATEGIES</span><span class="p">}</span>
</pre></div>
</div>
<p class="rubric" id="discussion">Discussion</p>
<p>In this chapter we have seen what can be accomplished with a relatively
small amount of code to solve the complex optimization problem of flow
shop scheduling. Finding the best solution to a large optimization
problem such as the flow shop can be difficult. In a case like this, we
can turn to approximation techniques such as local search to compute a
solution that is <em>good enough</em>. With local search we can move from one
solution to another, aiming to find one of good quality.</p>
<p>The general intuition behind local search can be applied to a wide range
of problems. We focused on (1) generating a neighbourhood of related
solutions to a problem from one candidate solution, and (2) establishing
ways to evaluate and compare solutions. With these two components in
hand, we can use the local search paradigm to find a valuable solution
when the best option is simply too difficult to compute.</p>
<p>Rather than using any one strategy to solve the problem, we saw how a
strategy can be chosen dynamically to shift during the solving process.
This simple and powerful technique gives the program the ability to mix
and match partial strategies for the problem at hand, and it also means
that the developer does not have to hand-tailor the strategy.</p>
</div></div></div></div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Learn-Computer-and-Math-again</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="blockcode-a-visual-programming-toolkit.html">500 Lines or Less | Blockcode: A visual programming toolkit</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, timger.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/chapters/a-flow-shop-scheduler.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>